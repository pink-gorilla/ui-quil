["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/graphlib/lib/alg/dijkstra.js"],"~:js","shadow$provide.module$node_modules$graphlib$lib$alg$dijkstra=function(global,require,module,exports){function runDijkstra(g,source,weightFn,edgeFn){var results={},pq=new PriorityQueue,updateNeighbors=function(edge){var w=edge.v!==v$jscomp$0?edge.v:edge.w,wEntry=results[w],weight=weightFn(edge),distance=vEntry.distance+weight;if(0>weight)throw Error(\"dijkstra does not allow negative edge weights. Bad edge: \"+edge+\" Weight: \"+weight);distance<wEntry.distance&&(wEntry.distance=distance,wEntry.predecessor=\nv$jscomp$0,pq.decrease(w,distance))};for(g.nodes().forEach(function(v){var distance=v===source?0:Number.POSITIVE_INFINITY;results[v]={distance};pq.add(v,distance)});0<pq.size();){var v$jscomp$0=pq.removeMin();var vEntry=results[v$jscomp$0];if(vEntry.distance===Number.POSITIVE_INFINITY)break;edgeFn(v$jscomp$0).forEach(updateNeighbors)}return results}global=require(\"module$node_modules$graphlib$lib$lodash\");var PriorityQueue=require(\"module$node_modules$graphlib$lib$data$priority_queue\");module.exports=\nfunction(g,source,weightFn,edgeFn){return runDijkstra(g,String(source),weightFn||DEFAULT_WEIGHT_FUNC,edgeFn||function(v){return g.outEdges(v)})};var DEFAULT_WEIGHT_FUNC=global.constant(1)}","~:source","shadow$provide[\"module$node_modules$graphlib$lib$alg$dijkstra\"] = function(global,require,module,exports) {\nvar _ = require(\"../lodash\");\nvar PriorityQueue = require(\"../data/priority-queue\");\n\nmodule.exports = dijkstra;\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction dijkstra(g, source, weightFn, edgeFn) {\n  return runDijkstra(g, String(source),\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn || function(v) { return g.outEdges(v); });\n}\n\nfunction runDijkstra(g, source, weightFn, edgeFn) {\n  var results = {};\n  var pq = new PriorityQueue();\n  var v, vEntry;\n\n  var updateNeighbors = function(edge) {\n    var w = edge.v !== v ? edge.v : edge.w;\n    var wEntry = results[w];\n    var weight = weightFn(edge);\n    var distance = vEntry.distance + weight;\n\n    if (weight < 0) {\n      throw new Error(\"dijkstra does not allow negative edge weights. \" +\n                      \"Bad edge: \" + edge + \" Weight: \" + weight);\n    }\n\n    if (distance < wEntry.distance) {\n      wEntry.distance = distance;\n      wEntry.predecessor = v;\n      pq.decrease(w, distance);\n    }\n  };\n\n  g.nodes().forEach(function(v) {\n    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;\n    results[v] = { distance: distance };\n    pq.add(v, distance);\n  });\n\n  while (pq.size() > 0) {\n    v = pq.removeMin();\n    vEntry = results[v];\n    if (vEntry.distance === Number.POSITIVE_INFINITY) {\n      break;\n    }\n\n    edgeFn(v).forEach(updateNeighbors);\n  }\n\n  return results;\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$graphlib$lib$data$priority_queue","~$shadow.js","~$module$node_modules$graphlib$lib$lodash"]],"~:properties",["^5",["distance","predecessor"]],"~:compiled-at",1621210442094,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$graphlib$lib$alg$dijkstra.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,6CAAA,CAAkE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAc1GC,QAASA,YAAW,CAACC,CAAD,CAAIC,MAAJ,CAAYC,QAAZ,CAAsBC,MAAtB,CAA8B,CAChD,IAAIC,QAAU,EAAd,CACIC,GAAK,IAAIC,aADb,CAIIC,gBAAkBA,QAAQ,CAACC,IAAD,CAAO,CACnC,IAAIC,EAAID,IAAKE,CAAAA,CAAL,GAAWA,UAAX,CAAeF,IAAKE,CAAAA,CAApB,CAAwBF,IAAKC,CAAAA,CAArC,CACIE,OAASP,OAAA,CAAQK,CAAR,CADb,CAEIG,OAASV,QAAA,CAASM,IAAT,CAFb,CAGIK,SAAWC,MAAOD,CAAAA,QAAlBA,CAA6BD,MAEjC,IAAa,CAAb,CAAIA,MAAJ,CACE,KAAUG,MAAJ,CAAU,2DAAV,CACyBP,IADzB,CACgC,WADhC,CAC8CI,MAD9C,CAAN,CAIEC,QAAJ,CAAeF,MAAOE,CAAAA,QAAtB,GACEF,MAAOE,CAAAA,QAEP,CAFkBA,QAElB,CADAF,MAAOK,CAAAA,WACP;AADqBN,UACrB,CAAAL,EAAGY,CAAAA,QAAH,CAAYR,CAAZ,CAAeI,QAAf,CAHF,CAXmC,CAwBrC,KANAb,CAAEkB,CAAAA,KAAF,EAAUC,CAAAA,OAAV,CAAkB,QAAQ,CAACT,CAAD,CAAI,CAC5B,IAAIG,SAAWH,CAAA,GAAMT,MAAN,CAAe,CAAf,CAAmBmB,MAAOC,CAAAA,iBACzCjB,QAAA,CAAQM,CAAR,CAAA,CAAa,CAAYG,QAAZ,CACbR,GAAGiB,CAAAA,GAAH,CAAOZ,CAAP,CAAUG,QAAV,CAH4B,CAA9B,CAMA,CAAmB,CAAnB,CAAOR,EAAGkB,CAAAA,IAAH,EAAP,CAAA,CAAsB,CACpB,IAAAb,WAAIL,EAAGmB,CAAAA,SAAH,EACJ,KAAAV,OAASV,OAAA,CAAQM,UAAR,CACT,IAAII,MAAOD,CAAAA,QAAX,GAAwBO,MAAOC,CAAAA,iBAA/B,CACE,KAGFlB,OAAA,CAAOO,UAAP,CAAUS,CAAAA,OAAV,CAAkBZ,eAAlB,CAPoB,CAUtB,MAAOH,QAvCyC,CAb9CqB,MAAAA,CAAI7B,OAAA,CAAQ,yCAAR,CACR,KAAIU,cAAgBV,OAAA,CAAQ,sDAAR,CAEpBC,OAAOC,CAAAA,OAAP;AAIA4B,QAAiB,CAAC1B,CAAD,CAAIC,MAAJ,CAAYC,QAAZ,CAAsBC,MAAtB,CAA8B,CAC7C,MAAOJ,YAAA,CAAYC,CAAZ,CAAe2B,MAAA,CAAO1B,MAAP,CAAf,CACLC,QADK,EACO0B,mBADP,CAELzB,MAFK,EAEK,QAAQ,CAACO,CAAD,CAAI,CAAE,MAAOV,EAAE6B,CAAAA,QAAF,CAAWnB,CAAX,CAAT,CAFjB,CADsC,CAF/C,KAAIkB,oBAAsBH,MAAEK,CAAAA,QAAF,CAAW,CAAX,CANgF;\",\n\"sources\":[\"node_modules/graphlib/lib/alg/dijkstra.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$graphlib$lib$alg$dijkstra\\\"] = function(global,require,module,exports) {\\nvar _ = require(\\\"../lodash\\\");\\nvar PriorityQueue = require(\\\"../data/priority-queue\\\");\\n\\nmodule.exports = dijkstra;\\n\\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\\n\\nfunction dijkstra(g, source, weightFn, edgeFn) {\\n  return runDijkstra(g, String(source),\\n    weightFn || DEFAULT_WEIGHT_FUNC,\\n    edgeFn || function(v) { return g.outEdges(v); });\\n}\\n\\nfunction runDijkstra(g, source, weightFn, edgeFn) {\\n  var results = {};\\n  var pq = new PriorityQueue();\\n  var v, vEntry;\\n\\n  var updateNeighbors = function(edge) {\\n    var w = edge.v !== v ? edge.v : edge.w;\\n    var wEntry = results[w];\\n    var weight = weightFn(edge);\\n    var distance = vEntry.distance + weight;\\n\\n    if (weight < 0) {\\n      throw new Error(\\\"dijkstra does not allow negative edge weights. \\\" +\\n                      \\\"Bad edge: \\\" + edge + \\\" Weight: \\\" + weight);\\n    }\\n\\n    if (distance < wEntry.distance) {\\n      wEntry.distance = distance;\\n      wEntry.predecessor = v;\\n      pq.decrease(w, distance);\\n    }\\n  };\\n\\n  g.nodes().forEach(function(v) {\\n    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;\\n    results[v] = { distance: distance };\\n    pq.add(v, distance);\\n  });\\n\\n  while (pq.size() > 0) {\\n    v = pq.removeMin();\\n    vEntry = results[v];\\n    if (vEntry.distance === Number.POSITIVE_INFINITY) {\\n      break;\\n    }\\n\\n    edgeFn(v).forEach(updateNeighbors);\\n  }\\n\\n  return results;\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"runDijkstra\",\"g\",\"source\",\"weightFn\",\"edgeFn\",\"results\",\"pq\",\"PriorityQueue\",\"updateNeighbors\",\"edge\",\"w\",\"v\",\"wEntry\",\"weight\",\"distance\",\"vEntry\",\"Error\",\"predecessor\",\"decrease\",\"nodes\",\"forEach\",\"Number\",\"POSITIVE_INFINITY\",\"add\",\"size\",\"removeMin\",\"_\",\"dijkstra\",\"String\",\"DEFAULT_WEIGHT_FUNC\",\"outEdges\",\"constant\"]\n}\n"]