["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-parser/build/vega-parser.js"],"~:js","shadow$provide.module$node_modules$vega_parser$build$vega_parser=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_util$build$vega_util\"),require(\"module$node_modules$vega_functions$build$vega_functions\"),require(\"module$node_modules$vega_event_selector$build$vega_event_selector\"),require(\"module$node_modules$vega_scale$build$vega_scale\"),require(\"module$node_modules$vega_dataflow$build$vega_dataflow\")):\n\"function\"===typeof define&&define.amd?define(\"exports vega-util vega-functions vega-event-selector vega-scale vega-dataflow\".split(\" \"),factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.vega,global.vega,global.vega))})(this,function(exports,vegaUtil,vegaFunctions,vegaEventSelector,vegaScale,vegaDataflow){function parseAutosize(spec){return vegaUtil.isObject(spec)?spec:{type:spec||\"pad\"}}function parsePadding(spec){vegaUtil.isObject(spec)?\nspec=spec.signal?spec:{top:+spec.top||0,bottom:+spec.bottom||0,left:+spec.left||0,right:+spec.right||0}:(spec=+spec||0,spec={top:spec,bottom:spec,left:spec,right:spec});return spec}function addEncode(object,name,value,set){return null!=value?(vegaUtil.isObject(value)&&!vegaUtil.isArray(value)||vegaUtil.isArray(value)&&value.length&&vegaUtil.isObject(value[0])?object.update[name]=value:object[set||\"enter\"][name]={value},1):0}function addEncoders(object,enter,update){for(const name in enter)addEncode(object,\nname,enter[name]);for(const name in update)addEncode(object,name,update[name],\"update\")}function extendEncode(encode,extra,skip){for(const name in extra)skip&&vegaUtil.hasOwnProperty(skip,name)||(encode[name]=vegaUtil.extend(encode[name]||{},extra[name]));return encode}function has(key,encode){return encode&&(encode.enter&&encode.enter[key]||encode.update&&encode.update[key])}function applyDefaults(encode,type,role,style,config){const defaults={},enter={};let update,key$jscomp$0;key$jscomp$0=\"lineBreak\";\n\"text\"!==type||null==config[key$jscomp$0]||has(key$jscomp$0,encode)||applyDefault(defaults,key$jscomp$0,config[key$jscomp$0]);if(\"legend\"==role||String(role).startsWith(\"axis\"))role=null;role=\"frame\"===role?config.group:\"mark\"===role?vegaUtil.extend({},config.mark,config[type]):null;for(key$jscomp$0 in role)(type=has(key$jscomp$0,encode)||(\"fill\"===key$jscomp$0||\"stroke\"===key$jscomp$0)&&(has(\"fill\",encode)||has(\"stroke\",encode)))||applyDefault(defaults,key$jscomp$0,role[key$jscomp$0]);vegaUtil.array(style).forEach(name=>\n{name=config.style&&config.style[name];for(const key in name)has(key,encode)||applyDefault(defaults,key,name[key])});encode=vegaUtil.extend({},encode);for(key$jscomp$0 in defaults)role=defaults[key$jscomp$0],role.signal?(update=update||{})[key$jscomp$0]=role:enter[key$jscomp$0]=role;encode.enter=vegaUtil.extend(enter,encode.enter);update&&(encode.update=vegaUtil.extend(update,encode.update));return encode}function applyDefault(defaults,key,value){defaults[key]=value&&value.signal?{signal:value.signal}:\n{value}}function entry$jscomp$0(enc){if(null!=enc.gradient)return gradient(enc);if(enc.signal)var JSCompiler_temp=`(${enc.signal})`;else enc.color?(JSCompiler_temp=enc.color,JSCompiler_temp=JSCompiler_temp.c?_color(\"hcl\",JSCompiler_temp.h,JSCompiler_temp.c,JSCompiler_temp.l):JSCompiler_temp.h||JSCompiler_temp.s?_color(\"hsl\",JSCompiler_temp.h,JSCompiler_temp.s,JSCompiler_temp.l):JSCompiler_temp.l||JSCompiler_temp.a?_color(\"lab\",JSCompiler_temp.l,JSCompiler_temp.a,JSCompiler_temp.b):JSCompiler_temp.r||\nJSCompiler_temp.g||JSCompiler_temp.b?_color(\"rgb\",JSCompiler_temp.r,JSCompiler_temp.g,JSCompiler_temp.b):null):JSCompiler_temp=null!=enc.field?field$jscomp$0(enc.field):void 0!==enc.value?vegaUtil.stringValue(enc.value):void 0;if(null!=enc.scale){{const scale=scaleRef(enc.scale);null!=enc.range?JSCompiler_temp=`lerp(_range(${scale}), ${+enc.range})`:(void 0!==JSCompiler_temp&&(JSCompiler_temp=`_scale(${scale}, ${JSCompiler_temp})`),enc.band&&(JSCompiler_temp=(JSCompiler_temp?JSCompiler_temp+\"+\":\"\")+\n`_bandwidth(${scale})`+(1===+enc.band?\"\":\"*\"+property$jscomp$0(enc.band)),enc.extra&&(JSCompiler_temp=`(datum.extra ? _scale(${scale}, datum.extra.value) : ${JSCompiler_temp})`)),null==JSCompiler_temp&&(JSCompiler_temp=\"0\"))}}void 0===JSCompiler_temp&&(JSCompiler_temp=null);null!=enc.exponent&&(JSCompiler_temp=`pow(${JSCompiler_temp},${property$jscomp$0(enc.exponent)})`);null!=enc.mult&&(JSCompiler_temp+=`*${property$jscomp$0(enc.mult)}`);null!=enc.offset&&(JSCompiler_temp+=`+${property$jscomp$0(enc.offset)}`);\nenc.round&&(JSCompiler_temp=`round(${JSCompiler_temp})`);return JSCompiler_temp}function gradient(enc){const args=[enc.start,enc.stop,enc.count].map(_=>null==_?null:vegaUtil.stringValue(_));for(;args.length&&null==vegaUtil.peek(args);)args.pop();args.unshift(scaleRef(enc.gradient));return`gradient(${args.join(\",\")})`}function property$jscomp$0(property){return vegaUtil.isObject(property)?\"(\"+entry$jscomp$0(property)+\")\":property}function field$jscomp$0(ref){return resolveField(vegaUtil.isObject(ref)?\nref:{datum:ref})}function resolveField(ref){let object;if(ref.signal){object=\"datum\";var level=ref.signal}else if(ref.group||ref.parent){level=Math.max(1,ref.level||1);for(object=\"item\";0<level--;)object+=\".mark.group\";ref.parent?(level=ref.parent,object+=\".datum\"):level=ref.group}else ref.datum?(object=\"datum\",level=ref.datum):vegaUtil.error(\"Invalid field reference: \"+vegaUtil.stringValue(ref));ref.signal||(level=vegaUtil.isString(level)?vegaUtil.splitAccessPath(level).map(vegaUtil.stringValue).join(\"][\"):\nresolveField(level));return object+\"[\"+level+\"]\"}function rule$jscomp$0(enc){let code=\"\";enc.forEach(rule=>{const value=entry$jscomp$0(rule);code+=rule.test?`(${rule.test})?${value}:`:value});\":\"===vegaUtil.peek(code)&&(code+=\"null\");return code}function parseEncode(encode,type,role,style,scope$jscomp$0,params$jscomp$0){const enc={};params$jscomp$0=params$jscomp$0||{};params$jscomp$0.encoders={$encode:enc};encode=applyDefaults(encode,type,role,style,scope$jscomp$0.config);for(const key in encode){{role=\nencode[key];style=type;var params=params$jscomp$0,scope=scope$jscomp$0;const channels={},fields={};for(const name in role)if(null!=role[name]){var JSCompiler_inline_result=role[name];JSCompiler_inline_result=vegaUtil.isArray(JSCompiler_inline_result)?rule$jscomp$0(JSCompiler_inline_result):entry$jscomp$0(JSCompiler_inline_result);channels[name]=parse(JSCompiler_inline_result,scope,params,fields)}role={$expr:{marktype:style,channels},$fields:Object.keys(fields),$output:Object.keys(role)}}enc[key]=\nrole}return params$jscomp$0}function parse(code,scope,params,fields){code=vegaFunctions.parseExpression(code,scope);code.$fields.forEach(name=>fields[name]=1);vegaUtil.extend(params,code.$params);return code.$expr}function outerError(prefix,name){vegaUtil.error(prefix+' for \"outer\" push: '+vegaUtil.stringValue(name))}function parseSignal(signal,scope){const name=signal.name;if(\"outer\"===signal.push)scope.signals[name]||outerError(\"No prior signal definition\",name),OUTER_INVALID.forEach(prop=>{void 0!==\nsignal[prop]&&outerError(\"Invalid property \",prop)});else{const op=scope.addSignal(name,signal.value);!1===signal.react&&(op.react=!1);signal.bind&&scope.addBinding(name,signal.bind)}}function Entry(type,value,params,parent){this.id=-1;this.type=type;this.value=value;this.params=params;parent&&(this.parent=parent)}function ref$jscomp$0(op){const ref={$ref:op.id};0>op.id&&(op.refs=op.refs||[]).push(ref);return ref}function fieldRef(field,name){return name?{$field:field,$name:name}:{$field:field}}function keyRef(fields,\nflat){fields={$key:fields};flat&&(fields.$flat=!0);return fields}function aggrField(op,field){return(op&&op.signal?\"$\"+op.signal:op||\"\")+(op&&field?\"_\":\"\")+(field&&field.signal?\"$\"+field.signal:field||\"\")}function isSignal(_){return _&&_.signal}function hasSignal(_){if(isSignal(_))return!0;if(vegaUtil.isObject(_))for(const key in _)if(hasSignal(_[key]))return!0;return!1}function value$jscomp$0(specValue,defaultValue){return null!=specValue?specValue:defaultValue}function deref(v){return v&&v.signal||\nv}function parseStream(stream,scope){return(stream.merge?mergeStream:stream.stream?nestedStream:stream.type?eventStream:vegaUtil.error(\"Invalid stream specification: \"+vegaUtil.stringValue(stream)))(stream,scope)}function mergeStream(stream,scope){const list=stream.merge.map(s=>parseStream(s,scope));stream=streamParameters({merge:list},stream,scope);return scope.addStream(stream).id}function nestedStream(stream,scope){const id=parseStream(stream.stream,scope);stream=streamParameters({stream:id},stream,\nscope);return scope.addStream(stream).id}function eventStream(stream,scope){if(\"timer\"===stream.type){var id=scope.event(\"timer\",stream.throttle);stream={between:stream.between,filter:stream.filter}}else id=stream.source,id=scope.event.call(scope,\"scope\"===id?\"view\":id||\"view\",stream.type);stream=streamParameters({stream:id},stream,scope);return 1===Object.keys(stream).length?id:scope.addStream(stream).id}function streamParameters(entry,stream,scope){let param=stream.between;param&&(2!==param.length&&\nvegaUtil.error('Stream \"between\" parameter must have 2 entries: '+vegaUtil.stringValue(stream)),entry.between=[parseStream(param[0],scope),parseStream(param[1],scope)]);param=stream.filter?[].concat(stream.filter):[];if(stream.marktype||stream.markname||stream.markrole){var JSCompiler_temp_const=param,type=stream.marktype,name=stream.markname,role=stream.markrole;JSCompiler_temp_const.push.call(JSCompiler_temp_const,\"event.item\"+(type&&\"*\"!==type?\"\\x26\\x26event.item.mark.marktype\\x3d\\x3d\\x3d'\"+type+\n\"'\":\"\")+(role?\"\\x26\\x26event.item.mark.role\\x3d\\x3d\\x3d'\"+role+\"'\":\"\")+(name?\"\\x26\\x26event.item.mark.name\\x3d\\x3d\\x3d'\"+name+\"'\":\"\"))}\"scope\"===stream.source&&param.push(\"inScope(event.item)\");param.length&&(entry.filter=vegaFunctions.parseExpression(\"(\"+param.join(\")\\x26\\x26(\")+\")\",scope).$expr);null!=(param=stream.throttle)&&(entry.throttle=+param);null!=(param=stream.debounce)&&(entry.debounce=+param);stream.consume&&(entry.consume=!0);return entry}function parseUpdate(spec,scope,target){const encode=\nspec.encode,entry={target};target=spec.events;let update=spec.update,sources=[];target||vegaUtil.error(\"Signal update missing events specification.\");vegaUtil.isString(target)&&(target=vegaEventSelector.selector(target,scope.isSubscope()?\"scope\":\"view\"));target=vegaUtil.array(target).filter(s=>s.signal||s.scale?(sources.push(s),0):1);1<sources.length&&(sources=[mergeSources(sources)]);target.length&&sources.push(1<target.length?{merge:target}:target[0]);null!=encode&&(update&&vegaUtil.error(\"Signal encode and update are mutually exclusive.\"),\nupdate=\"encode(item(),\"+vegaUtil.stringValue(encode)+\")\");entry.update=vegaUtil.isString(update)?vegaFunctions.parseExpression(update,scope):null!=update.expr?vegaFunctions.parseExpression(update.expr,scope):null!=update.value?update.value:null!=update.signal?{$expr:OP_VALUE_EXPR,$params:{$value:scope.signalRef(update.signal)}}:vegaUtil.error(\"Invalid signal update specification.\");spec.force&&(entry.options={force:!0});sources.forEach(source=>{var JSCompiler_temp_const=scope.addUpdate,JSCompiler_temp_const$jscomp$0=\nvegaUtil.extend;source={source:source.signal?scope.signalRef(source.signal):source.scale?scope.scaleRef(source.scale):parseStream(source,scope)};return JSCompiler_temp_const.call(scope,JSCompiler_temp_const$jscomp$0.call(vegaUtil,source,entry))})}function mergeSources(sources){return{signal:\"[\"+sources.map(s=>s.scale?'scale(\"'+s.scale+'\")':s.signal)+\"]\"}}function parseSignalUpdates(signal,scope){const op=scope.getSignal(signal.name);let expr=signal.update;signal.init&&(expr?vegaUtil.error(\"Signals can not include both init and update expressions.\"):\n(expr=signal.init,op.initonly=!0));expr&&(expr=vegaFunctions.parseExpression(expr,scope),op.update=expr.$expr,op.params=expr.$params);signal.on&&signal.on.forEach(_=>parseUpdate(_,scope,op.id))}function parseLiteral(v,scope){return vegaUtil.isObject(v)?v.signal?scope.signalRef(v.signal):vegaUtil.error(\"Unsupported object: \"+vegaUtil.stringValue(v)):v}function parseArray(v$jscomp$0,scope){return v$jscomp$0.signal?scope.signalRef(v$jscomp$0.signal):v$jscomp$0.map(v=>parseLiteral(v,scope))}function dataLookupError(name){vegaUtil.error(\"Can not find data set: \"+\nvegaUtil.stringValue(name))}function parseScaleDomain(domain,spec,scope){if(domain)return domain.signal?scope.signalRef(domain.signal):(vegaUtil.isArray(domain)?explicitDomain:domain.fields?multipleDomain:singularDomain)(domain,spec,scope);null==spec.domainMin&&null==spec.domainMax||vegaUtil.error(\"No scale domain defined for domainMin/domainMax to override.\")}function explicitDomain(domain,spec,scope){return domain.map(v=>parseLiteral(v,scope))}function singularDomain(domain,spec,scope){const data=\nscope.getData(domain.data);data||dataLookupError(domain.data);return vegaScale.isDiscrete(spec.type)?data.valuesRef(scope,domain.field,parseSort(domain.sort,!1)):vegaScale.isQuantile(spec.type)?data.domainRef(scope,domain.field):data.extentRef(scope,domain.field)}function multipleDomain(domain,spec,scope){const data$jscomp$0=domain.data,fields=domain.fields.reduce((dom,d)=>{if(vegaUtil.isString(d))d={data:data$jscomp$0,field:d};else if(vegaUtil.isArray(d)||d.signal){{var data=d;d=\"_:vega:_\"+FIELD_REF_ID++;\nconst coll=Collect({});vegaUtil.isArray(data)?coll.value={$ingest:data}:data.signal&&(data=\"setdata(\"+vegaUtil.stringValue(d)+\",\"+data.signal+\")\",coll.params.input=scope.signalRef(data));scope.addDataPipeline(d,[coll,Sieve({})]);d={data:d,field:\"data\"}}}dom.push(d);return dom},[]);return(vegaScale.isDiscrete(spec.type)?ordinalMultipleDomain:vegaScale.isQuantile(spec.type)?quantileMultipleDomain:numericMultipleDomain)(domain,scope,fields)}function ordinalMultipleDomain(domain,scope,fields){const sort=\nparseSort(domain.sort,!0);domain=fields.map(f=>{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.countsRef(scope,f.field,sort)});const p={groupby:keyFieldRef,pulse:domain};sort&&(domain=sort.op||\"count\",fields=sort.field?aggrField(domain,sort.field):\"count\",p.ops=[MULTIDOMAIN_SORT_OPS[domain]],p.fields=[scope.fieldRef(fields)],p.as=[fields]);domain=scope.add(Aggregate(p));domain=scope.add(Collect({pulse:ref$jscomp$0(domain)}));fields=scope.add(Values({field:keyFieldRef,sort:scope.sortRef(sort),\npulse:ref$jscomp$0(domain)}));return ref$jscomp$0(fields)}function parseSort(sort,multidomain){sort&&(sort.field||sort.op?sort.field||\"count\"===sort.op?multidomain&&sort.field&&sort.op&&!MULTIDOMAIN_SORT_OPS[sort.op]&&vegaUtil.error(\"Multiple domain scales can not be sorted using \"+sort.op):vegaUtil.error(\"No field provided for sort aggregate op: \"+sort.op):vegaUtil.isObject(sort)?sort.field=\"key\":sort={field:\"key\"});return sort}function quantileMultipleDomain(domain,scope,fields){domain=fields.map(f=>\n{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.domainRef(scope,f.field)});return ref$jscomp$0(scope.add(MultiValues({values:domain})))}function numericMultipleDomain(domain,scope,fields){domain=fields.map(f=>{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.extentRef(scope,f.field)});return ref$jscomp$0(scope.add(MultiExtent({extents:domain})))}function parseScaleRange(spec,scope,params){const config=scope.config.range;let range=spec.range;if(range.signal)return scope.signalRef(range.signal);\nif(vegaUtil.isString(range)){if(config&&vegaUtil.hasOwnProperty(config,range))return spec=vegaUtil.extend({},spec,{range:config[range]}),parseScaleRange(spec,scope,params);\"width\"===range?range=[0,{signal:\"width\"}]:\"height\"===range?range=vegaScale.isDiscrete(spec.type)?[0,{signal:\"height\"}]:[{signal:\"height\"},0]:vegaUtil.error(\"Unrecognized scale range value: \"+vegaUtil.stringValue(range))}else{if(range.scheme){params.scheme=vegaUtil.isArray(range.scheme)?parseArray(range.scheme,scope):parseLiteral(range.scheme,\nscope);range.extent&&(params.schemeExtent=parseArray(range.extent,scope));range.count&&(params.schemeCount=parseLiteral(range.count,scope));return}if(range.step){params.rangeStep=parseLiteral(range.step,scope);return}if(vegaScale.isDiscrete(spec.type)&&!vegaUtil.isArray(range))return parseScaleDomain(range,spec,scope);vegaUtil.isArray(range)||vegaUtil.error(\"Unsupported range type: \"+vegaUtil.stringValue(range))}return range.map(v=>(vegaUtil.isArray(v)?parseArray:parseLiteral)(v,scope))}function parseParameter(_$jscomp$0,\nname,scope){return vegaUtil.isArray(_$jscomp$0)?_$jscomp$0.map(_=>parseParameter(_,name,scope)):vegaUtil.isObject(_$jscomp$0)?_$jscomp$0.signal?scope.signalRef(_$jscomp$0.signal):\"fit\"===name?_$jscomp$0:vegaUtil.error(\"Unsupported parameter object: \"+vegaUtil.stringValue(_$jscomp$0)):_$jscomp$0}function guideGroup(mark){mark.type=\"group\";mark.interactive=mark.interactive||!1;return mark}function lookup$jscomp$0(spec,config){const _=(name,dflt)=>value$jscomp$0(spec[name],value$jscomp$0(config[name],\ndflt));_.isVertical=s=>\"vertical\"===value$jscomp$0(spec.direction,config.direction||(s?config.symbolDirection:config.gradientDirection));_.gradientLength=()=>value$jscomp$0(spec.gradientLength,config.gradientLength||config.gradientWidth);_.gradientThickness=()=>value$jscomp$0(spec.gradientThickness,config.gradientThickness||config.gradientHeight);_.entryColumns=()=>value$jscomp$0(spec.columns,value$jscomp$0(config.columns,+_.isVertical(!0)));return _}function getEncoding(name,encode){return(name=\nencode&&(encode.update&&encode.update[name]||encode.enter&&encode.enter[name]))&&name.signal?name:name?name.value:null}function anchorExpr(s,e,m){return`item.anchor === '${\"start\"}' ? ${s} : item.anchor === '${\"end\"}' ? ${e} : ${m}`}function extendOffset(value,offset){return offset?value?vegaUtil.isObject(value)?Object.assign({},value,{offset:extendOffset(value.offset,offset)}):{value,offset}:offset:value}function guideMark(mark,extras){extras?(mark.name=extras.name,mark.style=extras.style||mark.style,\nmark.interactive=!!extras.interactive,mark.encode=extendEncode(mark.encode,extras,Skip)):mark.interactive=!1;return mark}function legendGradient(spec,scale,config,userEncode){spec=lookup$jscomp$0(spec,config);var vertical=spec.isVertical();config=spec.gradientThickness();const length=spec.gradientLength();let enter,stop,width;vertical?(vertical=[0,1],stop=[0,0],width=config,config=length):(vertical=[0,0],stop=[1,0],width=length);scale={enter:enter={opacity:zero$jscomp$0,x:zero$jscomp$0,y:zero$jscomp$0,\nwidth:encoder(width),height:encoder(config)},update:vegaUtil.extend({},enter,{opacity:one,fill:{gradient:scale,start:vertical,stop}}),exit:{opacity:zero$jscomp$0}};addEncoders(scale,{stroke:spec(\"gradientStrokeColor\"),strokeWidth:spec(\"gradientStrokeWidth\")},{opacity:spec(\"gradientOpacity\")});return guideMark({type:\"rect\",role:\"legend-gradient\",encode:scale},userEncode)}function legendGradientDiscrete(spec,scale,config,userEncode,dataRef){spec=lookup$jscomp$0(spec,config);const vertical=spec.isVertical();\nconfig=spec.gradientThickness();const length=spec.gradientLength();var u;let v,uu,vv,adjust=\"\";vertical?(u=\"y\",uu=\"y2\",v=\"x\",vv=\"width\",adjust=\"1-\"):(u=\"x\",uu=\"x2\",v=\"y\",vv=\"height\");scale={opacity:zero$jscomp$0,fill:{scale,field:\"value\"}};scale[u]={signal:adjust+\"datum.perc\",mult:length};scale[v]=zero$jscomp$0;scale[uu]={signal:adjust+\"datum.perc2\",mult:length};scale[vv]=encoder(config);u={enter:scale,update:vegaUtil.extend({},scale,{opacity:one}),exit:{opacity:zero$jscomp$0}};addEncoders(u,{stroke:spec(\"gradientStrokeColor\"),\nstrokeWidth:spec(\"gradientStrokeWidth\")},{opacity:spec(\"gradientOpacity\")});return guideMark({type:\"rect\",role:\"legend-band\",key:\"value\",from:dataRef,encode:u},userEncode)}function legendGradientLabels(spec,config,userEncode,dataRef){const _=lookup$jscomp$0(spec,config);var vertical=_.isVertical();const thickness=encoder(_.gradientThickness()),length=_.gradientLength();let overlap=_(\"labelOverlap\"),enter,update,v,adjust=\"\";const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one,\ntext:{field:\"label\"}},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{fill:_(\"labelColor\"),fillOpacity:_(\"labelOpacity\"),font:_(\"labelFont\"),fontSize:_(\"labelFontSize\"),fontStyle:_(\"labelFontStyle\"),fontWeight:_(\"labelFontWeight\"),limit:value$jscomp$0(spec.labelLimit,config.gradientLabelLimit)});vertical?(enter.align={value:\"left\"},enter.baseline=update.baseline={signal:'datum.perc\\x3c\\x3d0?\"bottom\":datum.perc\\x3e\\x3d1?\"top\":\"middle\"'},vertical=\"y\",v=\"x\",adjust=\"1-\"):(enter.align=update.align={signal:'datum.perc\\x3c\\x3d0?\"left\":datum.perc\\x3e\\x3d1?\"right\":\"center\"'},\nenter.baseline={value:\"top\"},vertical=\"x\",v=\"y\");enter[vertical]=update[vertical]={signal:adjust+\"datum.perc\",mult:length};enter[v]=update[v]=thickness;thickness.offset=value$jscomp$0(spec.labelOffset,config.gradientLabelOffset)||0;overlap=overlap?{separation:_(\"labelSeparation\"),method:overlap,order:\"datum.index\"}:void 0;return guideMark({type:\"text\",role:\"legend-label\",style:\"guide-label\",key:\"value\",from:dataRef,encode,overlap},userEncode)}function legendSymbolGroups(spec,config,userEncode,dataRef,\ncolumns){var _=lookup$jscomp$0(spec,config);const entries=userEncode.entries,interactive=!(!entries||!entries.interactive),name=entries?entries.name:void 0,height=_(\"clipHeight\"),symbolOffset=_(\"symbolOffset\"),valueRef={data:\"value\"},xSignal=`(${columns}) ? datum.${\"offset\"} : datum.${\"size\"}`,yEncode=height?encoder(height):{field:\"size\"},ncols=`max(1, ${columns})`;let enter,update;yEncode.mult=.5;var encode={enter:enter={opacity:zero$jscomp$0,x:{signal:xSignal,mult:.5,offset:symbolOffset},y:yEncode},\nupdate:update={opacity:one,x:enter.x,y:enter.y},exit:{opacity:zero$jscomp$0}};let baseFill=null,baseStroke=null;spec.fill||(baseFill=config.symbolBaseFillColor,baseStroke=config.symbolBaseStrokeColor);addEncoders(encode,{fill:_(\"symbolFillColor\",baseFill),shape:_(\"symbolType\"),size:_(\"symbolSize\"),stroke:_(\"symbolStrokeColor\",baseStroke),strokeDash:_(\"symbolDash\"),strokeDashOffset:_(\"symbolDashOffset\"),strokeWidth:_(\"symbolStrokeWidth\")},{opacity:_(\"symbolOpacity\")});LegendScales.forEach(scale=>{spec[scale]&&\n(update[scale]=enter[scale]={scale:spec[scale],field:\"value\"})});config=guideMark({type:\"symbol\",role:\"legend-symbol\",key:\"value\",from:valueRef,clip:height?!0:void 0,encode},userEncode.symbols);encode=encoder(symbolOffset);encode.offset=_(\"labelOffset\");encode={enter:enter={opacity:zero$jscomp$0,x:{signal:xSignal,offset:encode},y:yEncode},update:update={opacity:one,text:{field:\"label\"},x:enter.x,y:enter.y},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{align:_(\"labelAlign\"),baseline:_(\"labelBaseline\"),\nfill:_(\"labelColor\"),fillOpacity:_(\"labelOpacity\"),font:_(\"labelFont\"),fontSize:_(\"labelFontSize\"),fontStyle:_(\"labelFontStyle\"),fontWeight:_(\"labelFontWeight\"),limit:_(\"labelLimit\")});userEncode=guideMark({type:\"text\",role:\"legend-label\",style:\"guide-label\",key:\"value\",from:valueRef,encode},userEncode.labels);encode={enter:{noBound:{value:!height},width:zero$jscomp$0,height:height?encoder(height):zero$jscomp$0,opacity:zero$jscomp$0},exit:{opacity:zero$jscomp$0},update:update={opacity:one,row:{signal:null},\ncolumn:{signal:null}}};_.isVertical(!0)?(_=`ceil(item.mark.items.length / ${ncols})`,update.row.signal=`${\"datum.index\"}%${_}`,update.column.signal=`floor(${\"datum.index\"} / ${_})`,_={field:[\"row\",\"datum.index\"]}):(update.row.signal=`floor(${\"datum.index\"} / ${ncols})`,update.column.signal=`${\"datum.index\"} % ${ncols}`,_={field:\"datum.index\"});update.column.signal=`(${columns})?${update.column.signal}:${\"datum.index\"}`;dataRef={facet:{data:dataRef,name:\"value\",groupby:\"index\"}};return guideGroup({role:\"scope\",\nfrom:dataRef,encode:extendEncode(encode,entries,Skip),marks:[config,userEncode],name,interactive,sort:_})}function legendSymbolLayout(spec,config){spec=lookup$jscomp$0(spec,config);return{align:spec(\"gridAlign\"),columns:spec.entryColumns(),center:{row:!0,column:!1},padding:{row:spec(\"rowPadding\"),column:spec(\"columnPadding\")}}}function legendTitle(spec,config,userEncode,dataRef){config=lookup$jscomp$0(spec,config);const encode={enter:{opacity:zero$jscomp$0},update:{opacity:one,x:{field:{group:\"padding\"}},\ny:{field:{group:\"padding\"}}},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{orient:config(\"titleOrient\"),_anchor:config(\"titleAnchor\"),anchor:{signal:'item._anchor || ((item.orient \\x3d\\x3d\\x3d \"left\" || item.orient \\x3d\\x3d\\x3d \"right\") ? \"middle\" : \"start\")'},angle:{signal:'datum.vgrad \\x26\\x26 (item.orient \\x3d\\x3d\\x3d \"left\" || item.orient \\x3d\\x3d\\x3d \"right\") ? (item.orient \\x3d\\x3d\\x3d \"left\" ? -90 : 90) : 0'},align:{signal:exprAlign},baseline:{signal:exprBaseline},text:spec.title,fill:config(\"titleColor\"),\nfillOpacity:config(\"titleOpacity\"),font:config(\"titleFont\"),fontSize:config(\"titleFontSize\"),fontStyle:config(\"titleFontStyle\"),fontWeight:config(\"titleFontWeight\"),limit:config(\"titleLimit\"),lineHeight:config(\"titleLineHeight\")},{align:config(\"titleAlign\"),baseline:config(\"titleBaseline\")});return guideMark({type:\"text\",role:\"legend-title\",style:\"guide-title\",from:dataRef,encode},userEncode)}function clip$jscomp$0(clip,scope){let expr;vegaUtil.isObject(clip)&&(clip.signal?expr=clip.signal:clip.path?\nexpr=\"pathShape(\"+param$jscomp$0(clip.path)+\")\":clip.sphere&&(expr=\"geoShape(\"+param$jscomp$0(clip.sphere)+', {type: \"Sphere\"})'));return expr?scope.signalRef(expr):!!clip}function param$jscomp$0(value){return vegaUtil.isObject(value)&&value.signal?value.signal:vegaUtil.stringValue(value)}function getRole(spec){const role=spec.role||\"\";return role.indexOf(\"axis\")&&role.indexOf(\"legend\")&&role.indexOf(\"title\")?\"group\"===spec.type?\"scope\":role||\"mark\":role}function definition(spec){return{marktype:spec.type,\nname:spec.name||void 0,role:spec.role||getRole(spec),zindex:+spec.zindex||void 0,aria:spec.aria,description:spec.description}}function interactive(spec,scope){return spec&&spec.signal?scope.signalRef(spec.signal):!1===spec?!1:!0}function parseTransform(spec,scope){const def=vegaDataflow.definition(spec.type);def||vegaUtil.error(\"Unrecognized transform type: \"+vegaUtil.stringValue(spec.type));var JSCompiler_inline_result=def.type.toLowerCase();var params=parseParameters(def,spec,scope);JSCompiler_inline_result=\nnew Entry(JSCompiler_inline_result,null,params,void 0);spec.signal&&scope.addSignal(spec.signal,scope.proxy(JSCompiler_inline_result));JSCompiler_inline_result.metadata=def.metadata||{};return JSCompiler_inline_result}function parseParameters(def,spec,scope){const params={},n=def.params.length;for(let i=0;i<n;++i){const pdef=def.params[i];params[pdef.name]=parseParameter$1(pdef,spec,scope)}return params}function parseParameter$1(def,spec,scope){const type=def.type,value=spec[def.name];if(\"index\"===\ntype)return parseIndexParameter(def,spec,scope);if(void 0===value)def.required&&vegaUtil.error(\"Missing required \"+vegaUtil.stringValue(spec.type)+\" parameter: \"+vegaUtil.stringValue(def.name));else return\"param\"===type?parseSubParameters(def,spec,scope):\"projection\"===type?scope.projectionRef(spec[def.name]):def.array&&!isSignal(value)?value.map(v=>parameterValue(def,v,scope)):parameterValue(def,value,scope)}function parameterValue(def,value,scope){const type=def.type;return isSignal(value)?\"expr\"===\ntype?vegaUtil.error(\"Expression references can not be signals.\"):\"field\"===type?scope.fieldRef(value):\"compare\"===type?scope.compareRef(value):scope.signalRef(value.signal):(def=def.expr||\"field\"===type)&&value&&value.expr?scope.exprRef(value.expr,value.as):def&&value&&value.field?fieldRef(value.field,value.as):\"expr\"===type?vegaFunctions.parseExpression(value,scope):\"data\"===type?ref$jscomp$0(scope.getData(value).values):\"field\"===type?fieldRef(value):\"compare\"===type?scope.compareRef(value):value}\nfunction parseIndexParameter(def,spec,scope){vegaUtil.isString(spec.from)||vegaUtil.error('Lookup \"from\" parameter must be a string literal.');return scope.getData(spec.from).lookupRef(scope,spec.key)}function parseSubParameters(def,spec,scope){spec=spec[def.name];return def.array?(vegaUtil.isArray(spec)||vegaUtil.error(\"Expected an array of sub-parameters. Instead: \"+vegaUtil.stringValue(spec)),spec.map(v=>parseSubParameter(def,v,scope))):parseSubParameter(def,spec,scope)}function parseSubParameter(def,\nvalue,scope){const n=def.params.length;let pdef;for(let i=0;i<n;++i){pdef=def.params[i];for(const k in pdef.key)if(pdef.key[k]!==value[k]){pdef=null;break}if(pdef)break}pdef||vegaUtil.error(\"Unsupported parameter: \"+vegaUtil.stringValue(value));def=vegaUtil.extend(parseParameters(pdef,value,scope),pdef.key);return ref$jscomp$0(scope.add(Params(def)))}function parseData(from,group,scope){let facet,key,dataRef,parent;if(!from)dataRef=ref$jscomp$0(scope.add(Collect(null,[{}])));else if(facet=from.facet)group||\nvegaUtil.error(\"Only group marks can be faceted.\"),null!=facet.field?dataRef=parent=getDataRef(facet,scope):(from.data?parent=ref$jscomp$0(scope.getData(from.data).aggregate):(group=parseTransform(vegaUtil.extend({type:\"aggregate\",groupby:vegaUtil.array(facet.groupby)},facet.aggregate),scope),group.params.key=scope.keyRef(facet.groupby),group.params.pulse=getDataRef(facet,scope),dataRef=parent=ref$jscomp$0(scope.add(group))),key=scope.keyRef(facet.groupby,!0));dataRef||(dataRef=getDataRef(from,scope));\nreturn{key,pulse:dataRef,parent}}function getDataRef(from,scope){return from.$ref?from:from.data&&from.data.$ref?from.data:ref$jscomp$0(scope.getData(from.data).output)}function DataScope(scope,input,output,values,aggr){this.scope=scope;this.input=input;this.output=output;this.values=values;this.aggregate=aggr;this.index={}}function fieldKey(field){return vegaUtil.isString(field)?field:null}function addSortField(scope,p,sort){const as=aggrField(sort.op,sort.field);let s;if(p.ops)for(let i=0,n=p.as.length;i<\nn;++i){if(p.as[i]===as)return}else p.ops=[\"count\"],p.fields=[null],p.as=[\"count\"];sort.op&&(p.ops.push((s=sort.op.signal)?scope.signalRef(s):sort.op),p.fields.push(scope.fieldRef(sort.field)),p.as.push(as))}function cache$jscomp$0(scope,ds,name,optype,field,counts,index){name=ds[name]||(ds[name]={});var JSCompiler_inline_result=vegaUtil.isObject(counts)?(\"descending\"===counts.order?\"-\":\"+\")+aggrField(counts.op,counts.field):\"\";let k=fieldKey(field);if(null!=k){scope=ds.scope;k+=JSCompiler_inline_result?\n\"|\"+JSCompiler_inline_result:\"\";var v=name[k]}v||(v=counts?{field:keyFieldRef,pulse:ds.countsRef(scope,field,counts)}:{field:scope.fieldRef(field),pulse:ref$jscomp$0(ds.output)},JSCompiler_inline_result&&(v.sort=scope.sortRef(counts)),scope=scope.add(new Entry(optype,void 0,v,void 0)),index&&(ds.index[field]=scope),v=ref$jscomp$0(scope),null!=k&&(name[k]=v));return v}function parseFacet(spec,scope,group){var facet=spec.from.facet;const name=facet.name,data=getDataRef(facet,scope);let op;facet.name||\nvegaUtil.error(\"Facet must have a name: \"+vegaUtil.stringValue(facet));facet.data||vegaUtil.error(\"Facet must reference a data set: \"+vegaUtil.stringValue(facet));facet.field?op=scope.add(PreFacet({field:scope.fieldRef(facet.field),pulse:data})):facet.groupby?op=scope.add(Facet({key:scope.keyRef(facet.groupby),group:ref$jscomp$0(scope.proxy(group.parent)),pulse:data})):vegaUtil.error(\"Facet must specify groupby or field: \"+vegaUtil.stringValue(facet));scope=scope.fork();group=scope.add(Collect());\nfacet=scope.add(Sieve({pulse:ref$jscomp$0(group)}));scope.addData(name,new DataScope(scope,group,group,facet));scope.addSignal(\"parent\",null);op.params.subflow={$subflow:scope.parse(spec).toRuntime()}}function parseSubflow(spec,scope,input){input=scope.add(PreFacet({pulse:input.pulse}));scope=scope.fork();scope.add(Sieve());scope.addSignal(\"parent\",null);input.params.subflow={$subflow:scope.parse(spec).toRuntime()}}function parseTrigger(spec,scope,name){const remove=spec.remove,insert=spec.insert,\ntoggle=spec.toggle,modify=spec.modify,values=spec.values,op=scope.add(new Entry(\"operator\",void 0,void 0,void 0));spec=\"if(\"+spec.trigger+',modify(\"'+name+'\",'+[insert,remove,toggle,modify,values].map(_=>null==_?\"null\":_).join(\",\")+\"),0)\";scope=vegaFunctions.parseExpression(spec,scope);op.update=scope.$expr;op.params=scope.$params}function parseMark(spec,scope){var role=getRole(spec),group=\"group\"===spec.type,facet=spec.from&&spec.from.facet;const overlap=spec.overlap;let layout=spec.layout||\"scope\"===\nrole||\"frame\"===role,ops,op,store,enc,name,layoutRef;const nested=\"mark\"===role||layout||facet,input=parseData(spec.from,group,scope);op=scope.add(DataJoin({key:input.key||(spec.key?fieldRef(spec.key):void 0),pulse:input.pulse,clean:!group}));const joinRef=ref$jscomp$0(op);op=store=scope.add(Collect({pulse:joinRef}));op=scope.add(Mark({markdef:definition(spec),interactive:interactive(spec.interactive,scope),clip:clip$jscomp$0(spec.clip,scope),context:{$context:!0},groups:scope.lookup(),parent:scope.signals.parent?\nscope.signalRef(\"parent\"):null,index:scope.markpath(),pulse:ref$jscomp$0(op)}));var boundRef=ref$jscomp$0(op);op=enc=scope.add(Encode(parseEncode(spec.encode,spec.type,role,spec.style,scope,{mod:!1,pulse:boundRef})));op.params.parent=scope.encode();spec.transform&&spec.transform.forEach(_=>{_=parseTransform(_,scope);const md=_.metadata;(md.generates||md.changes)&&vegaUtil.error(\"Mark transforms should not generate new data.\");md.nomod||(enc.params.mod=!0);_.params.pulse=ref$jscomp$0(op);scope.add(op=\n_)});spec.sort&&(op=scope.add(SortItems({sort:scope.compareRef(spec.sort),pulse:ref$jscomp$0(op)})));role=ref$jscomp$0(op);if(facet||layout)layout=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,mark:boundRef,pulse:role})),layoutRef=ref$jscomp$0(layout);const bound=scope.add(Bound({mark:boundRef,pulse:layoutRef||role}));boundRef=ref$jscomp$0(bound);group&&(nested&&(ops=scope.operators,ops.pop(),layout&&ops.pop()),scope.pushState(role,layoutRef||boundRef,joinRef),\nfacet?parseFacet(spec,scope,input):nested?parseSubflow(spec,scope,input):scope.parse(spec),scope.popState(),nested&&(layout&&ops.push(layout),ops.push(bound)));overlap&&(boundRef=parseOverlap(overlap,boundRef,scope));group=scope.add(Render({pulse:boundRef}));facet=scope.add(Sieve({pulse:ref$jscomp$0(group)},void 0,scope.parent()));null!=spec.name&&(name=spec.name,scope.addData(name,new DataScope(scope,store,group,facet)),spec.on&&spec.on.forEach(on=>{(on.insert||on.remove||on.toggle)&&vegaUtil.error(\"Marks only support modify triggers.\");\nparseTrigger(on,scope,name)}))}function parseOverlap(overlap,source,scope){const method=overlap.method,bound=overlap.bound,sep=overlap.separation;source={separation:isSignal(sep)?scope.signalRef(sep.signal):sep,method:isSignal(method)?scope.signalRef(method.signal):method,pulse:source};overlap.order&&(source.sort=scope.compareRef({field:overlap.order}));bound&&(overlap=bound.tolerance,source.boundTolerance=isSignal(overlap)?scope.signalRef(overlap.signal):+overlap,source.boundScale=scope.scaleRef(bound.scale),\nsource.boundOrient=bound.orient);return ref$jscomp$0(scope.add(Overlap(source)))}function parseLegend(spec,scope){const config=scope.config.legend,encode=spec.encode||{},_=lookup$jscomp$0(spec,config),legendEncode=encode.legend||{},name=legendEncode.name||void 0,interactive=legendEncode.interactive,style=legendEncode.style,scales={};let scale=0,entryLayout,params;LegendScales.forEach(s=>spec[s]?(scales[s]=spec[s],scale=scale||spec[s]):0);scale||vegaUtil.error(\"Missing valid scale for legend.\");var children=\nlegendType(spec,scope.scaleType(scale));const datum={title:null!=spec.title,scales,type:children,vgrad:\"symbol\"!==children&&_.isVertical()},dataRef=ref$jscomp$0(scope.add(Collect(null,[datum]))),entryRef=ref$jscomp$0(scope.add(LegendEntries(params={type:children,scale:scope.scaleRef(scale),count:scope.objectProperty(_(\"tickCount\")),limit:scope.property(_(\"symbolLimit\")),values:scope.objectProperty(spec.values),minstep:scope.property(spec.tickMinStep),formatType:scope.property(spec.formatType),formatSpecifier:scope.property(spec.format)})));\n\"gradient\"===children?(children=[legendGradient(spec,scale,config,encode.gradient),legendGradientLabels(spec,config,encode.labels,entryRef)],params.count=params.count||scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`)):\"discrete\"===children?children=[legendGradientDiscrete(spec,scale,config,encode.gradient,entryRef),legendGradientLabels(spec,config,encode.labels,entryRef)]:(entryLayout=legendSymbolLayout(spec,config),children=[legendSymbolGroups(spec,config,encode,entryRef,deref(entryLayout.columns))],\nparams.size=sizeExpression(spec,scope,children[0].marks));children=[guideGroup({role:\"legend-entry\",from:dataRef,encode:{enter:{x:{value:0},y:{value:0}}},marks:children,layout:entryLayout,interactive})];datum.title&&children.push(legendTitle(spec,config,encode.title,dataRef));return parseMark(guideGroup({role:\"legend\",from:dataRef,encode:extendEncode(buildLegendEncode(_,spec,config),legendEncode,Skip),marks:children,aria:_(\"aria\"),description:_(\"description\"),zindex:_(\"zindex\"),name,interactive,style}),\nscope)}function legendType(spec,scaleType){let type=spec.type||\"symbol\";spec.type||1!==scaleCount(spec)||!spec.fill&&!spec.stroke||(type=vegaScale.isContinuous(scaleType)?\"gradient\":vegaScale.isDiscretizing(scaleType)?\"discrete\":\"symbol\");return\"gradient\"!==type?type:vegaScale.isDiscretizing(scaleType)?\"discrete\":\"gradient\"}function scaleCount(spec){return LegendScales.reduce((count,type)=>count+(spec[type]?1:0),0)}function buildLegendEncode(_,spec,config){const encode={enter:{},update:{}};addEncoders(encode,\n{orient:_(\"orient\"),offset:_(\"offset\"),padding:_(\"padding\"),titlePadding:_(\"titlePadding\"),cornerRadius:_(\"cornerRadius\"),fill:_(\"fillColor\"),stroke:_(\"strokeColor\"),strokeWidth:config.strokeWidth,strokeDash:config.strokeDash,x:_(\"legendX\"),y:_(\"legendY\"),format:spec.format,formatType:spec.formatType});return encode}function sizeExpression(spec,scope,marks){const size=deref(getChannel(\"size\",spec,marks));spec=deref(getChannel(\"strokeWidth\",spec,marks));(marks=getEncoding(\"fontSize\",marks[1].encode))||\n(marks=(marks=scope.config.style[\"guide-label\"])&&marks.fontSize);marks=deref(marks);return vegaFunctions.parseExpression(`max(ceil(sqrt(${size})+${spec}),${marks})`,scope)}function getChannel(name,spec,marks){return spec[name]?`scale(\"${spec[name]}\",datum)`:getEncoding(name,marks[0].encode)}function parseTitle(spec,scope){spec=vegaUtil.isString(spec)?{text:spec}:spec;const _=lookup$jscomp$0(spec,scope.config.title);var encode=spec.encode||{},userEncode=encode.group||{};const name=userEncode.name||\nvoid 0,interactive=userEncode.interactive,style=userEncode.style,children=[],dataRef=ref$jscomp$0(scope.add(Collect(null,[{}])));var JSCompiler_temp_const=children.push,JSCompiler_temp_const$jscomp$0=spec;var JSCompiler_inline_result=(JSCompiler_inline_result=spec.encode)&&JSCompiler_inline_result.title||vegaUtil.extend({name:spec.name,interactive:spec.interactive,style:spec.style},JSCompiler_inline_result);var zero={value:0};zero={enter:{opacity:zero},update:{opacity:{value:1}},exit:{opacity:zero}};\naddEncoders(zero,{text:JSCompiler_temp_const$jscomp$0.text,align:{signal:\"item.mark.group.align\"},angle:{signal:\"item.mark.group.angle\"},limit:{signal:\"item.mark.group.limit\"},baseline:\"top\",dx:_(\"dx\"),dy:_(\"dy\"),fill:_(\"color\"),font:_(\"font\"),fontSize:_(\"fontSize\"),fontStyle:_(\"fontStyle\"),fontWeight:_(\"fontWeight\"),lineHeight:_(\"lineHeight\")},{align:_(\"align\"),angle:_(\"angle\"),baseline:_(\"baseline\")});JSCompiler_temp_const$jscomp$0=guideMark({type:\"text\",role:\"title-text\",style:\"group-title\",from:dataRef,\nencode:zero},JSCompiler_inline_result);JSCompiler_temp_const.call(children,JSCompiler_temp_const$jscomp$0);spec.subtitle&&(JSCompiler_temp_const=children.push,encode=encode.subtitle,JSCompiler_temp_const$jscomp$0={value:0},JSCompiler_temp_const$jscomp$0={enter:{opacity:JSCompiler_temp_const$jscomp$0},update:{opacity:{value:1}},exit:{opacity:JSCompiler_temp_const$jscomp$0}},addEncoders(JSCompiler_temp_const$jscomp$0,{text:spec.subtitle,align:{signal:\"item.mark.group.align\"},angle:{signal:\"item.mark.group.angle\"},\nlimit:{signal:\"item.mark.group.limit\"},baseline:\"top\",dx:_(\"dx\"),dy:_(\"dy\"),fill:_(\"subtitleColor\"),font:_(\"subtitleFont\"),fontSize:_(\"subtitleFontSize\"),fontStyle:_(\"subtitleFontStyle\"),fontWeight:_(\"subtitleFontWeight\"),lineHeight:_(\"subtitleLineHeight\")},{align:_(\"align\"),angle:_(\"angle\"),baseline:_(\"baseline\")}),spec=guideMark({type:\"text\",role:\"title-subtitle\",style:\"group-subtitle\",from:dataRef,encode:JSCompiler_temp_const$jscomp$0},encode),JSCompiler_temp_const.call(children,spec));spec={enter:{},\nupdate:{}};addEncoders(spec,{orient:_(\"orient\"),anchor:_(\"anchor\"),align:{signal:alignExpr},angle:{signal:'item.orient\\x3d\\x3d\\x3d\"left\"?-90:item.orient\\x3d\\x3d\\x3d\"right\"?90:0'},limit:_(\"limit\"),frame:_(\"frame\"),offset:_(\"offset\")||0,padding:_(\"subtitlePadding\")});userEncode=extendEncode(spec,userEncode,Skip);return parseMark(guideGroup({role:\"title\",from:dataRef,encode:userEncode,marks:children,aria:_(\"aria\"),description:_(\"description\"),zindex:_(\"zindex\"),name,interactive,style}),scope)}function parseData$1(data,\nscope){const transforms=[];data.transform&&data.transform.forEach(tx=>{transforms.push(parseTransform(tx,scope))});data.on&&data.on.forEach(on=>{parseTrigger(on,scope,data.name)});scope.addDataPipeline(data.name,analyze(data,scope,transforms))}function analyze(data,scope,ops){const output=[];let source=null,modify=!1,generate=!1,upstream,n,t,m;data.values?isSignal(data.values)||hasSignal(data.format)?(output.push(load(scope,data)),output.push(source=collect())):output.push(source=collect({$ingest:data.values,\n$format:data.format})):data.url?hasSignal(data.url)||hasSignal(data.format)?(output.push(load(scope,data)),output.push(source=collect())):output.push(source=collect({$request:data.url,$format:data.format})):data.source&&(source=upstream=vegaUtil.array(data.source).map(d=>ref$jscomp$0(scope.getData(d).output)),output.push(null));data=0;for(n=ops.length;data<n;++data)t=ops[data],m=t.metadata,source||m.source||output.push(source=collect()),output.push(t),m.generates&&(generate=!0),m.modifies&&!generate&&\n(modify=!0),m.source?source=t:m.changes&&(source=null);upstream&&(n=upstream.length-1,output[0]=Relay({derive:modify,pulse:n?upstream:upstream[0]}),(modify||n)&&output.splice(1,0,collect()));source||output.push(collect());output.push(Sieve({}));return output}function collect(values){values=Collect({},values);values.metadata={source:!0};return values}function load(scope,data){return Load({url:data.url?scope.property(data.url):void 0,async:data.async?scope.property(data.async):void 0,values:data.values?\nscope.property(data.values):void 0,format:scope.objectProperty(data.format)})}function fallback(prop,config,axisConfig,style){let styleProp;if(config&&vegaUtil.hasOwnProperty(config,prop))return config[prop];if(vegaUtil.hasOwnProperty(axisConfig,prop))return axisConfig[prop];if(prop.startsWith(\"title\")){switch(prop){case \"titleColor\":styleProp=\"fill\";break;case \"titleFont\":case \"titleFontSize\":case \"titleFontWeight\":styleProp=prop[5].toLowerCase()+prop.slice(6)}return style[\"guide-title\"][styleProp]}if(prop.startsWith(\"label\")){switch(prop){case \"labelColor\":styleProp=\n\"fill\";break;case \"labelFont\":case \"labelFontSize\":styleProp=prop[5].toLowerCase()+prop.slice(6)}return style[\"guide-label\"][styleProp]}return null}function keys(objects){const map={};for(const obj of objects)if(obj)for(const key in obj)map[key]=1;return Object.keys(map)}function flushExpr(scale,threshold,a,b,c){return{signal:'flush(range(\"'+scale+'\"), scale(\"'+scale+'\", datum.value), '+threshold+\",\"+a+\",\"+b+\",\"+c+\")\"}}function autoLayout(_,orient,encode,userEncode){const auto=(value,dim)=>null!=\nvalue?(encode.update[dim]=patch(encoder(value),encode.update[dim]),!1):has(dim,userEncode)?!1:!0,autoY=auto(_(\"titleX\"),\"x\");_=auto(_(\"titleY\"),\"y\");encode.enter.auto=_===autoY?encoder(_):ifX(orient,encoder(_),encoder(autoY))}function parseScope(spec,scope,preprocessed){const signals=vegaUtil.array(spec.signals),scales=vegaUtil.array(spec.scales);preprocessed||signals.forEach(_=>parseSignal(_,scope));vegaUtil.array(spec.projections).forEach(_=>{{const config=scope.config.projection||{},params={};\nfor(const name in _)\"name\"!==name&&(params[name]=parseParameter(_[name],name,scope));for(const name in config)null==params[name]&&(params[name]=parseParameter(config[name],name,scope));scope.addProjection(_.name,params)}});scales.forEach(_=>{{const type=_.type||\"linear\";vegaScale.isValidScaleType(type)||vegaUtil.error(\"Unrecognized scale type: \"+vegaUtil.stringValue(type));scope.addScale(_.name,{type,domain:void 0})}});vegaUtil.array(spec.data).forEach(_=>parseData$1(_,scope));scales.forEach(_=>{{const params=\nscope.getScale(_.name).params;let key;params.domain=parseScaleDomain(_.domain,_,scope);null!=_.range&&(params.range=parseScaleRange(_,scope,params));if(null!=_.interpolate){var interpolate=_.interpolate,params$jscomp$0=params;params$jscomp$0.interpolate=parseLiteral(interpolate.type||interpolate);null!=interpolate.gamma&&(params$jscomp$0.interpolateGamma=parseLiteral(interpolate.gamma))}null!=_.nice&&(interpolate=_.nice,interpolate=vegaUtil.isObject(interpolate)?{interval:parseLiteral(interpolate.interval),\nstep:parseLiteral(interpolate.step)}:parseLiteral(interpolate),params.nice=interpolate);null!=_.bins&&(interpolate=_.bins,interpolate=interpolate.signal||vegaUtil.isArray(interpolate)?parseArray(interpolate,scope):scope.objectProperty(interpolate),params.bins=interpolate);for(key in _)vegaUtil.hasOwnProperty(params,key)||\"name\"===key||(params[key]=parseLiteral(_[key],scope))}});(preprocessed||signals).forEach(_=>parseSignalUpdates(_,scope));vegaUtil.array(spec.axes).forEach(_$jscomp$3=>{{var config=\nscope.config,style$jscomp$0=config.style,axis=config.axis,band$jscomp$0=\"band\"===scope.scaleType(_$jscomp$3.scale)&&config.axisBand,orient$jscomp$0=_$jscomp$3.orient,key;if(isSignal(orient$jscomp$0)){const xyKeys=keys([config.axisX,config.axisY]),orientKeys=keys([config.axisTop,config.axisBottom,config.axisLeft,config.axisRight]);var xy={};for(key of xyKeys)xy[key]=ifX(orient$jscomp$0,fallback(key,config.axisX,axis,style$jscomp$0),fallback(key,config.axisY,axis,style$jscomp$0));var or={};for(key of orientKeys){var JSCompiler_temp_const=\nor,JSCompiler_temp_const$jscomp$0=key,$orient=orient$jscomp$0.signal,t=fallback(key,config.axisTop,axis,style$jscomp$0),b=fallback(key,config.axisBottom,axis,style$jscomp$0),l=fallback(key,config.axisLeft,axis,style$jscomp$0),r=fallback(key,config.axisRight,axis,style$jscomp$0);var JSCompiler_inline_result={signal:(null!=l?`${$orient} === '${\"left\"}' ? (${toExpr(l)}) : `:\"\")+(null!=b?`${$orient} === '${\"bottom\"}' ? (${toExpr(b)}) : `:\"\")+(null!=r?`${$orient} === '${\"right\"}' ? (${toExpr(r)}) : `:\n\"\")+(null!=t?`${$orient} === '${\"top\"}' ? (${toExpr(t)}) : `:\"\")+\"(null)\"};JSCompiler_temp_const[JSCompiler_temp_const$jscomp$0]=JSCompiler_inline_result}}else xy=\"top\"===orient$jscomp$0||\"bottom\"===orient$jscomp$0?config.axisX:config.axisY,or=config[\"axis\"+orient$jscomp$0[0].toUpperCase()+orient$jscomp$0.slice(1)];var JSCompiler_inline_result$jscomp$0=xy||or||band$jscomp$0?vegaUtil.extend({},axis,xy,or,band$jscomp$0):axis;const encode$jscomp$0=_$jscomp$3.encode||{},axisEncode=encode$jscomp$0.axis||\n{},name=axisEncode.name||void 0,interactive=axisEncode.interactive,style=axisEncode.style,_$jscomp$0=lookup$jscomp$0(_$jscomp$3,JSCompiler_inline_result$jscomp$0);{var _$jscomp$1=_$jscomp$0;const v=_$jscomp$1(\"tickBand\");let offset=_$jscomp$1(\"tickOffset\"),band,extra;v?v.signal?(band={signal:`(${v.signal}) === 'extent' ? 1 : 0.5`},extra={signal:`(${v.signal}) === 'extent'`},vegaUtil.isObject(offset)||(offset={signal:`(${v.signal}) === 'extent' ? 0 : ${offset}`})):\"extent\"===v?(band=1,extra=!0,offset=\n0):(band=.5,extra=!1):(band=_$jscomp$1(\"bandPosition\"),extra=_$jscomp$1(\"tickExtra\"));var JSCompiler_object_inline_extra_6992=extra;var JSCompiler_object_inline_band_6993=band;var JSCompiler_object_inline_offset_6994=offset}const datum={scale:_$jscomp$3.scale,ticks:!!_$jscomp$0(\"ticks\"),labels:!!_$jscomp$0(\"labels\"),grid:!!_$jscomp$0(\"grid\"),domain:!!_$jscomp$0(\"domain\"),title:null!=_$jscomp$3.title},dataRef=ref$jscomp$0(scope.add(Collect({},[datum]))),ticksRef=ref$jscomp$0(scope.add(AxisTicks({scale:scope.scaleRef(_$jscomp$3.scale),\nextra:scope.property(JSCompiler_object_inline_extra_6992),count:scope.objectProperty(_$jscomp$3.tickCount),values:scope.objectProperty(_$jscomp$3.values),minstep:scope.property(_$jscomp$3.tickMinStep),formatType:scope.property(_$jscomp$3.formatType),formatSpecifier:scope.property(_$jscomp$3.format)}))),children=[];let size;if(datum.grid){var JSCompiler_temp_const$jscomp$1=children,JSCompiler_temp_const$jscomp$2=JSCompiler_temp_const$jscomp$1.push;{var userEncode=encode$jscomp$0.grid,dataRef$jscomp$0=\nticksRef;const _=lookup$jscomp$0(_$jscomp$3,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$3.orient,vscale=_$jscomp$3.gridScale,sign=getSign(orient,1,-1);a:{var offset$jscomp$0=_$jscomp$3.offset,sign$jscomp$0=sign;if(1!==sign$jscomp$0)if(vegaUtil.isObject(offset$jscomp$0)){let entry=offset$jscomp$0=vegaUtil.extend({},offset$jscomp$0);for(;null!=entry.mult;)if(vegaUtil.isObject(entry.mult))entry=entry.mult=vegaUtil.extend({},entry.mult);else{entry.mult=isSignal(sign$jscomp$0)?{signal:`(${entry.mult}) * (${sign$jscomp$0.signal})`}:\nentry.mult*sign$jscomp$0;var JSCompiler_inline_result$jscomp$1=offset$jscomp$0;break a}entry.mult=sign$jscomp$0}else offset$jscomp$0=isSignal(sign$jscomp$0)?{signal:`(${sign$jscomp$0.signal}) * (${offset$jscomp$0||0})`}:sign$jscomp$0*(offset$jscomp$0||0);JSCompiler_inline_result$jscomp$1=offset$jscomp$0}const offset=JSCompiler_inline_result$jscomp$1;let enter,exit,update;const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:exit={opacity:zero$jscomp$0}};addEncoders(encode,\n{stroke:_(\"gridColor\"),strokeCap:_(\"gridCap\"),strokeDash:_(\"gridDash\"),strokeDashOffset:_(\"gridDashOffset\"),strokeOpacity:_(\"gridOpacity\"),strokeWidth:_(\"gridWidth\")});const tickPos={scale:_$jscomp$3.scale,field:\"value\",band:JSCompiler_object_inline_band_6993,extra:JSCompiler_object_inline_extra_6992,offset:JSCompiler_object_inline_offset_6994,round:_(\"tickRound\")},sz=ifX(orient,{signal:\"height\"},{signal:\"width\"}),gridStart=vscale?{scale:vscale,range:0,mult:sign,offset}:{value:0,offset},gridEnd=vscale?\n{scale:vscale,range:1,mult:sign,offset}:vegaUtil.extend(sz,{mult:sign,offset});enter.x=update.x=ifX(orient,tickPos,gridStart);enter.y=update.y=ifY(orient,tickPos,gridStart);enter.x2=update.x2=ifY(orient,gridEnd);enter.y2=update.y2=ifX(orient,gridEnd);exit.x=ifX(orient,tickPos);exit.y=ifY(orient,tickPos);var JSCompiler_inline_result$jscomp$2=guideMark({type:\"rule\",role:\"axis-grid\",key:\"value\",from:dataRef$jscomp$0,encode},userEncode)}JSCompiler_temp_const$jscomp$2.call(JSCompiler_temp_const$jscomp$1,\nJSCompiler_inline_result$jscomp$2)}if(datum.ticks){size=_$jscomp$0(\"tickSize\");var JSCompiler_temp_const$jscomp$3=children,JSCompiler_temp_const$jscomp$4=JSCompiler_temp_const$jscomp$3.push;{var userEncode$jscomp$0=encode$jscomp$0.ticks,dataRef$jscomp$1=ticksRef,size$jscomp$0=size;const _=lookup$jscomp$0(_$jscomp$3,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$3.orient,sign=getSign(orient,-1,1);let enter,exit,update;const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},\nexit:exit={opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_(\"tickColor\"),strokeCap:_(\"tickCap\"),strokeDash:_(\"tickDash\"),strokeDashOffset:_(\"tickDashOffset\"),strokeOpacity:_(\"tickOpacity\"),strokeWidth:_(\"tickWidth\")});const tickSize=encoder(size$jscomp$0);tickSize.mult=sign;const tickPos={scale:_$jscomp$3.scale,field:\"value\",band:JSCompiler_object_inline_band_6993,extra:JSCompiler_object_inline_extra_6992,offset:JSCompiler_object_inline_offset_6994,round:_(\"tickRound\")};update.y=enter.y=ifX(orient,\nzero$jscomp$0,tickPos);update.y2=enter.y2=ifX(orient,tickSize);exit.x=ifX(orient,tickPos);update.x=enter.x=ifY(orient,zero$jscomp$0,tickPos);update.x2=enter.x2=ifY(orient,tickSize);exit.y=ifY(orient,tickPos);var JSCompiler_inline_result$jscomp$3=guideMark({type:\"rule\",role:\"axis-tick\",key:\"value\",from:dataRef$jscomp$1,encode},userEncode$jscomp$0)}JSCompiler_temp_const$jscomp$4.call(JSCompiler_temp_const$jscomp$3,JSCompiler_inline_result$jscomp$3)}if(datum.labels){size=datum.ticks?size:0;var JSCompiler_temp_const$jscomp$5=\nchildren,JSCompiler_temp_const$jscomp$6=JSCompiler_temp_const$jscomp$5.push;{var userEncode$jscomp$1=encode$jscomp$0.labels,dataRef$jscomp$2=ticksRef,size$jscomp$1=size;const _=lookup$jscomp$0(_$jscomp$3,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$3.orient,scale=_$jscomp$3.scale,sign=getSign(orient,-1,1),flush=deref(_(\"labelFlush\")),flushOffset=deref(_(\"labelFlushOffset\")),labelAlign=_(\"labelAlign\"),labelBaseline=_(\"labelBaseline\");let flushOn=0===flush||!!flush,update;const tickSize=encoder(size$jscomp$1);\ntickSize.mult=sign;tickSize.offset=encoder(_(\"labelPadding\")||0);tickSize.offset.mult=sign;const tickPos={scale,field:\"value\",band:.5,offset:extendOffset(JSCompiler_object_inline_offset_6994,_(\"labelOffset\"))};var JSCompiler_temp_const$jscomp$7=flushOn?flushExpr(scale,flush,'\"left\"','\"right\"','\"center\"'):{value:\"center\"},orient$jscomp$1=orient;var JSCompiler_inline_result$jscomp$4=isSignal(orient$jscomp$1)?ifExpr(`${orient$jscomp$1.signal} === '${\"right\"}'`,\"left\",\"right\"):\"right\"===orient$jscomp$1?\n{value:\"left\"}:{value:\"right\"};const align=ifX(orient,JSCompiler_temp_const$jscomp$7,JSCompiler_inline_result$jscomp$4),baseline=ifX(orient,ifTop(orient,\"bottom\",\"top\"),flushOn?flushExpr(scale,flush,'\"top\"','\"bottom\"','\"middle\"'):{value:\"middle\"}),offsetExpr=flushExpr(scale,flush,`-(${flushOffset})`,flushOffset,0);flushOn=flushOn&&flushOffset;const enter={opacity:zero$jscomp$0,x:ifX(orient,tickPos,tickSize),y:ifY(orient,tickPos,tickSize)},encode={enter,update:update={opacity:one,text:{field:\"label\"},\nx:enter.x,y:enter.y,align,baseline},exit:{opacity:zero$jscomp$0,x:enter.x,y:enter.y}};addEncoders(encode,{dx:!labelAlign&&flushOn?ifX(orient,offsetExpr):null,dy:!labelBaseline&&flushOn?ifY(orient,offsetExpr):null});addEncoders(encode,{angle:_(\"labelAngle\"),fill:_(\"labelColor\"),fillOpacity:_(\"labelOpacity\"),font:_(\"labelFont\"),fontSize:_(\"labelFontSize\"),fontWeight:_(\"labelFontWeight\"),fontStyle:_(\"labelFontStyle\"),limit:_(\"labelLimit\"),lineHeight:_(\"labelLineHeight\")},{align:labelAlign,baseline:labelBaseline});\nconst bound=_(\"labelBound\");let overlap=_(\"labelOverlap\");overlap=overlap||bound?{separation:_(\"labelSeparation\"),method:overlap,order:\"datum.index\",bound:bound?{scale,orient,tolerance:bound}:null}:void 0;update.align!==align&&(update.align=patch(update.align,align));update.baseline!==baseline&&(update.baseline=patch(update.baseline,baseline));var JSCompiler_inline_result$jscomp$5=guideMark({type:\"text\",role:\"axis-label\",style:\"guide-label\",key:\"value\",from:dataRef$jscomp$2,encode,overlap},userEncode$jscomp$1)}JSCompiler_temp_const$jscomp$6.call(JSCompiler_temp_const$jscomp$5,\nJSCompiler_inline_result$jscomp$5)}if(datum.domain){var JSCompiler_temp_const$jscomp$8=children,JSCompiler_temp_const$jscomp$9=JSCompiler_temp_const$jscomp$8.push;{var userEncode$jscomp$2=encode$jscomp$0.domain,dataRef$jscomp$3=dataRef;const _=lookup$jscomp$0(_$jscomp$3,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$3.orient;let enter,update;const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_(\"domainColor\"),strokeCap:_(\"domainCap\"),\nstrokeDash:_(\"domainDash\"),strokeDashOffset:_(\"domainDashOffset\"),strokeWidth:_(\"domainWidth\"),strokeOpacity:_(\"domainOpacity\")});const pos0={scale:_$jscomp$3.scale,range:0},pos1={scale:_$jscomp$3.scale,range:1};enter.x=update.x=ifX(orient,pos0,zero$jscomp$0);enter.x2=update.x2=ifX(orient,pos1);enter.y=update.y=ifY(orient,pos0,zero$jscomp$0);enter.y2=update.y2=ifY(orient,pos1);var JSCompiler_inline_result$jscomp$6=guideMark({type:\"rule\",role:\"axis-domain\",from:dataRef$jscomp$3,encode},userEncode$jscomp$2)}JSCompiler_temp_const$jscomp$9.call(JSCompiler_temp_const$jscomp$8,\nJSCompiler_inline_result$jscomp$6)}if(datum.title){var JSCompiler_temp_const$jscomp$10=children,JSCompiler_temp_const$jscomp$11=JSCompiler_temp_const$jscomp$10.push;{var userEncode$jscomp$3=encode$jscomp$0.title,dataRef$jscomp$4=dataRef;const _=lookup$jscomp$0(_$jscomp$3,JSCompiler_inline_result$jscomp$0),orient=_$jscomp$3.orient,sign=getSign(orient,-1,1);let enter,update;const encode={enter:enter={opacity:zero$jscomp$0,anchor:encoder(_(\"titleAnchor\",null)),align:{signal:alignExpr}},update:update=\nvegaUtil.extend({},enter,{opacity:one,text:encoder(_$jscomp$3.title)}),exit:{opacity:zero$jscomp$0}},titlePos={signal:`lerp(range(\"${_$jscomp$3.scale}\"), ${anchorExpr(0,1,.5)})`};update.x=ifX(orient,titlePos);update.y=ifY(orient,titlePos);var JSCompiler_temp_const$jscomp$12=enter,sign$jscomp$1=sign;var JSCompiler_inline_result$jscomp$7=isSignal(sign$jscomp$1)?{signal:`(${sign$jscomp$1.signal}) * ${90}`}:{value:90*sign$jscomp$1};JSCompiler_temp_const$jscomp$12.angle=ifX(orient,zero$jscomp$0,JSCompiler_inline_result$jscomp$7);\nenter.baseline=ifX(orient,ifTop(orient,\"bottom\",\"top\"),{value:\"bottom\"});update.angle=enter.angle;update.baseline=enter.baseline;addEncoders(encode,{fill:_(\"titleColor\"),fillOpacity:_(\"titleOpacity\"),font:_(\"titleFont\"),fontSize:_(\"titleFontSize\"),fontStyle:_(\"titleFontStyle\"),fontWeight:_(\"titleFontWeight\"),limit:_(\"titleLimit\"),lineHeight:_(\"titleLineHeight\")},{align:_(\"titleAlign\"),angle:_(\"titleAngle\"),baseline:_(\"titleBaseline\")});autoLayout(_,orient,encode,userEncode$jscomp$3);encode.update.align=\npatch(encode.update.align,enter.align);encode.update.angle=patch(encode.update.angle,enter.angle);encode.update.baseline=patch(encode.update.baseline,enter.baseline);var JSCompiler_inline_result$jscomp$8=guideMark({type:\"text\",role:\"axis-title\",style:\"guide-title\",from:dataRef$jscomp$4,encode},userEncode$jscomp$3)}JSCompiler_temp_const$jscomp$11.call(JSCompiler_temp_const$jscomp$10,JSCompiler_inline_result$jscomp$8)}{var _$jscomp$2=_$jscomp$0;const encode={enter:{},update:{}};addEncoders(encode,{orient:_$jscomp$2(\"orient\"),\noffset:_$jscomp$2(\"offset\")||0,position:value$jscomp$0(_$jscomp$3.position,0),titlePadding:_$jscomp$2(\"titlePadding\"),minExtent:_$jscomp$2(\"minExtent\"),maxExtent:_$jscomp$2(\"maxExtent\"),range:{signal:`abs(span(range(\"${_$jscomp$3.scale}\")))`},translate:_$jscomp$2(\"translate\"),format:_$jscomp$3.format,formatType:_$jscomp$3.formatType});var JSCompiler_inline_result$jscomp$9=encode}var JSCompiler_inline_result$jscomp$10=parseMark(guideGroup({role:\"axis\",from:dataRef,encode:extendEncode(JSCompiler_inline_result$jscomp$9,\naxisEncode,Skip),marks:children,aria:_$jscomp$0(\"aria\"),description:_$jscomp$0(\"description\"),zindex:_$jscomp$0(\"zindex\"),name,interactive,style}),scope)}return JSCompiler_inline_result$jscomp$10});vegaUtil.array(spec.marks).forEach(_=>parseMark(_,scope));vegaUtil.array(spec.legends).forEach(_=>parseLegend(_,scope));spec.title&&parseTitle(spec.title,scope);scope.parseLambdas();return scope}function parseView(spec,scope){var config=scope.config;const root=ref$jscomp$0(scope.root=scope.add(new Entry(\"operator\",\nvoid 0,void 0,void 0))),signals=collectSignals(spec,config);signals.forEach(_=>parseSignal(_,scope));scope.description=spec.description||config.description;scope.eventConfig=config.events;scope.legends=scope.objectProperty(config.legend&&config.legend.layout);scope.locale=config.locale;config=scope.add(Collect());const encode=scope.add(Encode(parseEncode(extendEncode({enter:{x:{value:0},y:{value:0}},update:{width:{signal:\"width\"},height:{signal:\"height\"}}},spec.encode),\"group\",\"frame\",spec.style,\nscope,{pulse:ref$jscomp$0(config)}))),parent=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,autosize:scope.signalRef(\"autosize\"),mark:root,pulse:ref$jscomp$0(encode)}));scope.operators.pop();scope.pushState(ref$jscomp$0(encode),ref$jscomp$0(parent),null);parseScope(spec,scope,signals);scope.operators.push(parent);spec=scope.add(Bound({mark:root,pulse:ref$jscomp$0(parent)}));spec=scope.add(Render({pulse:ref$jscomp$0(spec)}));spec=scope.add(Sieve({pulse:ref$jscomp$0(spec)}));\nscope.addData(\"root\",new DataScope(scope,config,config,spec));return scope}function signalObject(name,value){return value&&value.signal?{name,update:value.signal}:{name,value}}function collectSignals(spec,config){const _=name=>value$jscomp$0(spec[name],config[name]),signals=[signalObject(\"background\",_(\"background\")),signalObject(\"autosize\",parseAutosize(_(\"autosize\"))),signalObject(\"padding\",parsePadding(_(\"padding\"))),signalObject(\"width\",_(\"width\")||0),signalObject(\"height\",_(\"height\")||0)],pre=\nsignals.reduce((p,s)=>(p[s.name]=s,p),{}),map={};vegaUtil.array(spec.signals).forEach(s=>{vegaUtil.hasOwnProperty(pre,s.name)?s=vegaUtil.extend(pre[s.name],s):signals.push(s);map[s.name]=s});vegaUtil.array(config.signals).forEach(s=>{vegaUtil.hasOwnProperty(map,s.name)||vegaUtil.hasOwnProperty(pre,s.name)||signals.push(s)});return signals}function Scope$1(config,options){this.config=config||{};this.options=options||{};this.bindings=[];this.field={};this.signals={};this.lambdas={};this.scales={};this.events=\n{};this.data={};this.streams=[];this.updates=[];this.operators=[];this.locale=this.eventConfig=null;this._subid=this._id=0;this._nextsub=[0];this._parent=[];this._encode=[];this._lookup=[];this._markpath=[]}function Subscope(scope){this.config=scope.config;this.options=scope.options;this.legends=scope.legends;this.field=Object.create(scope.field);this.signals=Object.create(scope.signals);this.lambdas=Object.create(scope.lambdas);this.scales=Object.create(scope.scales);this.events=Object.create(scope.events);\nthis.data=Object.create(scope.data);this.streams=[];this.updates=[];this.operators=[];this._id=0;this._subid=++scope._nextsub[0];this._nextsub=scope._nextsub;this._parent=scope._parent.slice();this._encode=scope._encode.slice();this._lookup=scope._lookup.slice();this._markpath=scope._markpath}function propertyLambda(spec){return(vegaUtil.isArray(spec)?arrayLambda:objectLambda)(spec)}function arrayLambda(array){const n=array.length;let code=\"[\";for(let i=0;i<n;++i){const value=array[i];code+=(0<i?\n\",\":\"\")+(vegaUtil.isObject(value)?value.signal||propertyLambda(value):vegaUtil.stringValue(value))}return code+\"]\"}function objectLambda(obj){let code=\"{\",i=0,key,value;for(key in obj)value=obj[key],code+=(1<++i?\",\":\"\")+vegaUtil.stringValue(key)+\":\"+(vegaUtil.isObject(value)?value.signal||propertyLambda(value):vegaUtil.stringValue(value));return code+\"}\"}function defaults$jscomp$0(){return{description:\"Vega visualization\",padding:0,autosize:\"pad\",background:null,events:{defaults:{allow:[\"wheel\"]}},\ngroup:null,mark:null,arc:{fill:\"#4c78a8\"},area:{fill:\"#4c78a8\"},image:null,line:{stroke:\"#4c78a8\",strokeWidth:2},path:{stroke:\"#4c78a8\"},rect:{fill:\"#4c78a8\"},rule:{stroke:\"#000\"},shape:{stroke:\"#4c78a8\"},symbol:{fill:\"#4c78a8\",size:64},text:{fill:\"#000\",font:\"sans-serif\",fontSize:11},trail:{fill:\"#4c78a8\",size:2},style:{\"guide-label\":{fill:\"#000\",font:\"sans-serif\",fontSize:10},\"guide-title\":{fill:\"#000\",font:\"sans-serif\",fontSize:11,fontWeight:\"bold\"},\"group-title\":{fill:\"#000\",font:\"sans-serif\",\nfontSize:13,fontWeight:\"bold\"},\"group-subtitle\":{fill:\"#000\",font:\"sans-serif\",fontSize:12},point:{size:30,strokeWidth:2,shape:\"circle\"},circle:{size:30,strokeWidth:2},square:{size:30,strokeWidth:2,shape:\"square\"},cell:{fill:\"transparent\",stroke:\"#ddd\"}},title:{orient:\"top\",anchor:\"middle\",offset:4,subtitlePadding:3},axis:{minExtent:0,maxExtent:200,bandPosition:.5,domain:!0,domainWidth:1,domainColor:\"#888\",grid:!1,gridWidth:1,gridColor:\"#ddd\",labels:!0,labelAngle:0,labelLimit:180,labelOffset:0,labelPadding:2,\nticks:!0,tickColor:\"#888\",tickOffset:0,tickRound:!0,tickSize:5,tickWidth:1,titlePadding:4},axisBand:{tickOffset:-.5},projection:{type:\"mercator\"},legend:{orient:\"right\",padding:0,gridAlign:\"each\",columnPadding:10,rowPadding:2,symbolDirection:\"vertical\",gradientDirection:\"vertical\",gradientLength:200,gradientThickness:16,gradientStrokeColor:\"#ddd\",gradientStrokeWidth:0,gradientLabelOffset:2,labelAlign:\"left\",labelBaseline:\"middle\",labelLimit:160,labelOffset:4,labelOverlap:!0,symbolLimit:30,symbolType:\"circle\",\nsymbolSize:100,symbolOffset:0,symbolStrokeWidth:1.5,symbolBaseFillColor:\"transparent\",symbolBaseStrokeColor:\"#888\",titleLimit:180,titleOrient:\"top\",titlePadding:5,layout:{offset:18,direction:\"horizontal\",left:{direction:\"vertical\"},right:{direction:\"vertical\"}}},range:{category:{scheme:\"tableau10\"},ordinal:{scheme:\"blues\"},heatmap:{scheme:\"yellowgreenblue\"},ramp:{scheme:\"blues\"},diverging:{scheme:\"blueorange\",extent:[1,0]},symbol:\"circle square triangle-up cross diamond triangle-right triangle-down triangle-left\".split(\" \")}}}\nconst encoder=_=>vegaUtil.isObject(_)&&!vegaUtil.isArray(_)?vegaUtil.extend({},_):{value:_},scaleRef=scale=>vegaUtil.isString(scale)?vegaUtil.stringValue(scale):scale.signal?`(${scale.signal})`:field$jscomp$0(scale),_color=(type,x,y,z)=>`(${type}(${[x,y,z].map(entry$jscomp$0).join(\",\")})+'')`,OUTER_INVALID=[\"value\",\"update\",\"init\",\"react\",\"bind\"],keyFieldRef=fieldRef(\"key\"),OP_VALUE_EXPR={code:\"_.$value\",ast:{type:\"Identifier\",value:\"value\"}},transform$jscomp$0=name=>(params,value,parent)=>new Entry(name,\nvalue,params||void 0,parent),Aggregate=transform$jscomp$0(\"aggregate\"),AxisTicks=transform$jscomp$0(\"axisticks\"),Bound=transform$jscomp$0(\"bound\"),Collect=transform$jscomp$0(\"collect\"),Compare=transform$jscomp$0(\"compare\"),DataJoin=transform$jscomp$0(\"datajoin\"),Encode=transform$jscomp$0(\"encode\"),Expression=transform$jscomp$0(\"expression\"),Facet=transform$jscomp$0(\"facet\"),Field=transform$jscomp$0(\"field\"),Key=transform$jscomp$0(\"key\"),LegendEntries=transform$jscomp$0(\"legendentries\"),Load=transform$jscomp$0(\"load\"),\nMark=transform$jscomp$0(\"mark\"),MultiExtent=transform$jscomp$0(\"multiextent\"),MultiValues=transform$jscomp$0(\"multivalues\"),Overlap=transform$jscomp$0(\"overlap\"),Params=transform$jscomp$0(\"params\"),PreFacet=transform$jscomp$0(\"prefacet\"),Projection=transform$jscomp$0(\"projection\"),Proxy=transform$jscomp$0(\"proxy\"),Relay=transform$jscomp$0(\"relay\"),Render=transform$jscomp$0(\"render\"),Scale=transform$jscomp$0(\"scale\"),Sieve=transform$jscomp$0(\"sieve\"),SortItems=transform$jscomp$0(\"sortitems\"),ViewLayout=\ntransform$jscomp$0(\"viewlayout\"),Values=transform$jscomp$0(\"values\");let FIELD_REF_ID=0;const MULTIDOMAIN_SORT_OPS={min:\"min\",max:\"max\",count:\"sum\"},LegendScales=\"size shape fill stroke strokeWidth strokeDash opacity\".split(\" \"),Skip={name:1,style:1,interactive:1},zero$jscomp$0={value:0},one={value:1},alignExpr=anchorExpr(vegaUtil.stringValue(\"left\"),vegaUtil.stringValue(\"right\"),vegaUtil.stringValue(\"center\")),baseline$jscomp$0=anchorExpr('\"top\"','\"bottom\"','\"middle\"'),exprAlign=`datum.vgrad && ${'item.orient \\x3d\\x3d\\x3d \"right\"'} ? (${anchorExpr('\"right\"',\n'\"left\"','\"center\"')}) : (${'(item.orient \\x3d\\x3d\\x3d \"left\" || item.orient \\x3d\\x3d\\x3d \"right\")'} && !(datum.vgrad && ${'item.orient \\x3d\\x3d\\x3d \"left\"'})) ? \"left\" : ${alignExpr}`,exprBaseline=`${'(item.orient \\x3d\\x3d\\x3d \"left\" || item.orient \\x3d\\x3d\\x3d \"right\")'} ? (datum.vgrad ? (${'item.orient \\x3d\\x3d\\x3d \"right\"'} ? \"bottom\" : \"top\") : ${baseline$jscomp$0}) : \"top\"`;DataScope.fromEntries=function(scope,entries){const n=entries.length,values=entries[n-1],output=entries[n-2];let input=\nentries[0],aggr=null,i=1;input&&\"load\"===input.type&&(input=entries[1]);for(scope.add(entries[0]);i<n;++i)entries[i].params.pulse=ref$jscomp$0(entries[i-1]),scope.add(entries[i]),\"aggregate\"===entries[i].type&&(aggr=entries[i]);return new DataScope(scope,input,output,values,aggr)};DataScope.prototype={countsRef(scope,field,sort){const cache=this.counts||(this.counts={}),k=fieldKey(field);if(null!=k){scope=this.scope;var v=cache[k]}v?sort&&sort.field&&addSortField(scope,v.agg.params,sort):(v={groupby:scope.fieldRef(field,\n\"key\"),pulse:ref$jscomp$0(this.output)},sort&&sort.field&&addSortField(scope,v,sort),sort=scope.add(Aggregate(v)),v=scope.add(Collect({pulse:ref$jscomp$0(sort)})),v={agg:sort,ref:ref$jscomp$0(v)},null!=k&&(cache[k]=v));return v.ref},tuplesRef(){return ref$jscomp$0(this.values)},extentRef(scope,field){return cache$jscomp$0(scope,this,\"extent\",\"extent\",field,!1)},domainRef(scope,field){return cache$jscomp$0(scope,this,\"domain\",\"values\",field,!1)},valuesRef(scope,field,sort){return cache$jscomp$0(scope,\nthis,\"vals\",\"values\",field,sort||!0)},lookupRef(scope,field){return cache$jscomp$0(scope,this,\"lookup\",\"tupleindex\",field,!1)},indataRef(scope,field){return cache$jscomp$0(scope,this,\"indata\",\"tupleindex\",field,!0,!0)}};const getSign=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifExpr(`${orient} === '${\"left\"}' || ${orient} === '${\"top\"}'`,a,b)):a=\"left\"===orient||\"top\"===orient?a:b;return a},ifX=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifEnc(`${orient} === '${\"top\"}' || ${orient} === '${\"bottom\"}'`,\na,b)):a=\"bottom\"===orient||\"top\"===orient?a:b;return a},ifY=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifEnc(`${orient} !== '${\"top\"}' && ${orient} !== '${\"bottom\"}'`,a,b)):a=\"bottom\"===orient||\"top\"===orient?b:a;return a},ifTop=(orient,a,b)=>isSignal(orient)?ifExpr(`${orient.signal} === '${\"top\"}'`,a,b):\"top\"===orient?{value:a}:{value:b},ifEnc=(test,a,b)=>{a=null!=a?encoder(a):a;b=null!=b?encoder(b):b;if(null!=a&&1!==Object.keys(a).length||null!=b&&1!==Object.keys(b).length)return[vegaUtil.extend({test},\na)].concat(b||[]);a=a?a.signal||vegaUtil.stringValue(a.value):null;b=b?b.signal||vegaUtil.stringValue(b.value):null;return{signal:`${test} ? (${a}) : (${b})`}},ifExpr=(test,a,b)=>({signal:`${test} ? (${toExpr(a)}) : (${toExpr(b)})`}),toExpr=v=>isSignal(v)?v.signal:null==v?null:vegaUtil.stringValue(v),patch=(value,base)=>{const s=value.signal;return s&&s.endsWith(\"(null)\")?{signal:s.slice(0,-6)+base.signal}:value};Scope$1.prototype=Subscope.prototype={parse(spec){return parseScope(spec,this)},fork(){return new Subscope(this)},\nisSubscope(){return 0<this._subid},toRuntime(){this.finish();return{description:this.description,operators:this.operators,streams:this.streams,updates:this.updates,bindings:this.bindings,eventConfig:this.eventConfig,locale:this.locale}},id(){return(this._subid?this._subid+\":\":0)+this._id++},add(op){this.operators.push(op);op.id=this.id();op.refs&&(op.refs.forEach(ref=>{ref.$ref=op.id}),op.refs=null);return op},proxy(op){op=op instanceof Entry?ref$jscomp$0(op):op;return this.add(Proxy({value:op}))},\naddStream(stream){this.streams.push(stream);stream.id=this.id();return stream},addUpdate(update){this.updates.push(update);return update},finish(){function annotate(op,name,type){op&&(op=op.data||(op.data={}),name=op[name]||(op[name]=[]),name.push(type))}let name$jscomp$0,ds;this.root&&(this.root.root=!0);for(name$jscomp$0 in this.signals)this.signals[name$jscomp$0].signal=name$jscomp$0;for(name$jscomp$0 in this.scales)this.scales[name$jscomp$0].scale=name$jscomp$0;for(name$jscomp$0 in this.data){ds=\nthis.data[name$jscomp$0];annotate(ds.input,name$jscomp$0,\"input\");annotate(ds.output,name$jscomp$0,\"output\");annotate(ds.values,name$jscomp$0,\"values\");for(const field in ds.index)annotate(ds.index[field],name$jscomp$0,\"index:\"+field)}return this},pushState(encode,parent,lookup){this._encode.push(ref$jscomp$0(this.add(Sieve({pulse:encode}))));this._parent.push(parent);this._lookup.push(lookup?ref$jscomp$0(this.proxy(lookup)):null);this._markpath.push(-1)},popState(){this._encode.pop();this._parent.pop();\nthis._lookup.pop();this._markpath.pop()},parent(){return vegaUtil.peek(this._parent)},encode(){return vegaUtil.peek(this._encode)},lookup(){return vegaUtil.peek(this._lookup)},markpath(){const p=this._markpath;return++p[p.length-1]},fieldRef(field,name){if(vegaUtil.isString(field))return fieldRef(field,name);field.signal||vegaUtil.error(\"Unsupported field reference: \"+vegaUtil.stringValue(field));field=field.signal;var f=this.field[field];f||(f={name:this.signalRef(field)},name&&(f.as=name),this.field[field]=\nf=ref$jscomp$0(this.add(Field(f))));return f},compareRef(cmp){let signal=!1;const check=_=>isSignal(_)?(signal=!0,this.signalRef(_.signal)):_&&_.expr?(signal=!0,this.exprRef(_.expr)):_,fields=vegaUtil.array(cmp.field).map(check);cmp=vegaUtil.array(cmp.order).map(check);return signal?ref$jscomp$0(this.add(Compare({fields,orders:cmp}))):{$compare:fields,$order:cmp}},keyRef(fields,flat){let signal=!1;const sig=this.signals;fields=vegaUtil.array(fields).map(_=>isSignal(_)?(signal=!0,ref$jscomp$0(sig[_.signal])):\n_);return signal?ref$jscomp$0(this.add(Key({fields,flat}))):keyRef(fields,flat)},sortRef(sort){if(!sort)return sort;const a=aggrField(sort.op,sort.field);sort=sort.order||\"ascending\";return sort.signal?ref$jscomp$0(this.add(Compare({fields:a,orders:this.signalRef(sort.signal)}))):{$compare:a,$order:sort}},event(source,type){const key=source+\":\"+type;if(!this.events[key]){const id=this.id();this.streams.push({id,source,type});this.events[key]=id}return this.events[key]},hasOwnSignal(name){return vegaUtil.hasOwnProperty(this.signals,\nname)},addSignal(name,value){this.hasOwnSignal(name)&&vegaUtil.error(\"Duplicate signal name: \"+vegaUtil.stringValue(name));value=value instanceof Entry?value:this.add(new Entry(\"operator\",value,void 0,void 0));return this.signals[name]=value},getSignal(name){this.signals[name]||vegaUtil.error(\"Unrecognized signal name: \"+vegaUtil.stringValue(name));return this.signals[name]},signalRef(s){if(this.signals[s])return ref$jscomp$0(this.signals[s]);vegaUtil.hasOwnProperty(this.lambdas,s)||(this.lambdas[s]=\nthis.add(new Entry(\"operator\",null,void 0,void 0)));return ref$jscomp$0(this.lambdas[s])},parseLambdas(){const code=Object.keys(this.lambdas);for(let i=0,n=code.length;i<n;++i){var s=code[i];const e=vegaFunctions.parseExpression(s,this);s=this.lambdas[s];s.params=e.$params;s.update=e.$expr}},property(spec){return spec&&spec.signal?this.signalRef(spec.signal):spec},objectProperty(spec){return spec&&vegaUtil.isObject(spec)?this.signalRef(spec.signal||propertyLambda(spec)):spec},exprRef(code,name){code=\n{expr:vegaFunctions.parseExpression(code,this)};name&&(code.expr.$name=name);return ref$jscomp$0(this.add(Expression(code)))},addBinding(name,bind){this.bindings||vegaUtil.error(\"Nested signals do not support binding: \"+vegaUtil.stringValue(name));this.bindings.push(vegaUtil.extend({signal:name},bind))},addScaleProj(name,transform){vegaUtil.hasOwnProperty(this.scales,name)&&vegaUtil.error(\"Duplicate scale or projection name: \"+vegaUtil.stringValue(name));this.scales[name]=this.add(transform)},addScale(name,\nparams){this.addScaleProj(name,Scale(params))},addProjection(name,params){this.addScaleProj(name,Projection(params))},getScale(name){this.scales[name]||vegaUtil.error(\"Unrecognized scale name: \"+vegaUtil.stringValue(name));return this.scales[name]},scaleRef(name){return ref$jscomp$0(this.getScale(name))},scaleType(name){return this.getScale(name).params.type},projectionRef(name){return this.scaleRef(name)},projectionType(name){return this.scaleType(name)},addData(name,dataScope){vegaUtil.hasOwnProperty(this.data,\nname)&&vegaUtil.error(\"Duplicate data set name: \"+vegaUtil.stringValue(name));return this.data[name]=dataScope},getData(name){this.data[name]||vegaUtil.error(\"Undefined data set name: \"+vegaUtil.stringValue(name));return this.data[name]},addDataPipeline(name,entries){vegaUtil.hasOwnProperty(this.data,name)&&vegaUtil.error(\"Duplicate data set name: \"+vegaUtil.stringValue(name));return this.addData(name,DataScope.fromEntries(this,entries))}};exports.AxisDomainRole=\"axis-domain\";exports.AxisGridRole=\n\"axis-grid\";exports.AxisLabelRole=\"axis-label\";exports.AxisRole=\"axis\";exports.AxisTickRole=\"axis-tick\";exports.AxisTitleRole=\"axis-title\";exports.DataScope=DataScope;exports.FrameRole=\"frame\";exports.LegendEntryRole=\"legend-entry\";exports.LegendLabelRole=\"legend-label\";exports.LegendRole=\"legend\";exports.LegendSymbolRole=\"legend-symbol\";exports.LegendTitleRole=\"legend-title\";exports.MarkRole=\"mark\";exports.Scope=Scope$1;exports.ScopeRole=\"scope\";exports.config=defaults$jscomp$0;exports.parse=function(spec,\nconfig,options){vegaUtil.isObject(spec)||vegaUtil.error(\"Input Vega specification must be an object.\");config=vegaUtil.mergeConfig(defaults$jscomp$0(),config,spec.config);return parseView(spec,new Scope$1(config,options)).toRuntime()};exports.signal=parseSignal;exports.signalUpdates=parseSignalUpdates;exports.stream=parseStream;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_parser$build$vega_parser\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-functions'), require('vega-event-selector'), require('vega-scale'), require('vega-dataflow')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-functions', 'vega-event-selector', 'vega-scale', 'vega-dataflow'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaUtil, vegaFunctions, vegaEventSelector, vegaScale, vegaDataflow) { 'use strict';\n\n  function parseAutosize (spec) {\n    return vegaUtil.isObject(spec) ? spec : {\n      type: spec || 'pad'\n    };\n  }\n\n  const number = _ => +_ || 0;\n\n  const paddingObject = _ => ({\n    top: _,\n    bottom: _,\n    left: _,\n    right: _\n  });\n\n  function parsePadding (spec) {\n    return !vegaUtil.isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\n      top: number(spec.top),\n      bottom: number(spec.bottom),\n      left: number(spec.left),\n      right: number(spec.right)\n    };\n  }\n\n  const encoder = _ => vegaUtil.isObject(_) && !vegaUtil.isArray(_) ? vegaUtil.extend({}, _) : {\n    value: _\n  };\n  function addEncode(object, name, value, set) {\n    if (value != null) {\n      const isEncoder = vegaUtil.isObject(value) && !vegaUtil.isArray(value) || vegaUtil.isArray(value) && value.length && vegaUtil.isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\n\n      if (isEncoder) {\n        object.update[name] = value;\n      } else {\n        object[set || 'enter'][name] = {\n          value: value\n        };\n      }\n\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  function addEncoders(object, enter, update) {\n    for (const name in enter) {\n      addEncode(object, name, enter[name]);\n    }\n\n    for (const name in update) {\n      addEncode(object, name, update[name], 'update');\n    }\n  }\n  function extendEncode(encode, extra, skip) {\n    for (const name in extra) {\n      if (skip && vegaUtil.hasOwnProperty(skip, name)) continue;\n      encode[name] = vegaUtil.extend(encode[name] || {}, extra[name]);\n    }\n\n    return encode;\n  }\n  function has(key, encode) {\n    return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\n  }\n\n  const MarkRole = 'mark';\n  const FrameRole = 'frame';\n  const ScopeRole = 'scope';\n  const AxisRole = 'axis';\n  const AxisDomainRole = 'axis-domain';\n  const AxisGridRole = 'axis-grid';\n  const AxisLabelRole = 'axis-label';\n  const AxisTickRole = 'axis-tick';\n  const AxisTitleRole = 'axis-title';\n  const LegendRole = 'legend';\n  const LegendBandRole = 'legend-band';\n  const LegendEntryRole = 'legend-entry';\n  const LegendGradientRole = 'legend-gradient';\n  const LegendLabelRole = 'legend-label';\n  const LegendSymbolRole = 'legend-symbol';\n  const LegendTitleRole = 'legend-title';\n  const TitleRole = 'title';\n  const TitleTextRole = 'title-text';\n  const TitleSubtitleRole = 'title-subtitle';\n\n  function applyDefaults (encode, type, role, style, config) {\n    const defaults = {},\n          enter = {};\n    let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\n\n    key = 'lineBreak';\n\n    if (type === 'text' && config[key] != null && !has(key, encode)) {\n      applyDefault(defaults, key, config[key]);\n    } // ignore legend and axis roles\n\n\n    if (role == 'legend' || String(role).startsWith('axis')) {\n      role = null;\n    } // resolve mark config\n\n\n    props = role === FrameRole ? config.group : role === MarkRole ? vegaUtil.extend({}, config.mark, config[type]) : null;\n\n    for (key in props) {\n      // do not apply defaults if relevant fields are defined\n      skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\n      if (!skip) applyDefault(defaults, key, props[key]);\n    } // resolve styles, apply with increasing precedence\n\n\n    vegaUtil.array(style).forEach(name => {\n      const props = config.style && config.style[name];\n\n      for (const key in props) {\n        if (!has(key, encode)) {\n          applyDefault(defaults, key, props[key]);\n        }\n      }\n    });\n    encode = vegaUtil.extend({}, encode); // defensive copy\n\n    for (key in defaults) {\n      props = defaults[key];\n\n      if (props.signal) {\n        (update = update || {})[key] = props;\n      } else {\n        enter[key] = props;\n      }\n    }\n\n    encode.enter = vegaUtil.extend(enter, encode.enter);\n    if (update) encode.update = vegaUtil.extend(update, encode.update);\n    return encode;\n  }\n\n  function applyDefault(defaults, key, value) {\n    defaults[key] = value && value.signal ? {\n      signal: value.signal\n    } : {\n      value: value\n    };\n  }\n\n  const scaleRef = scale => vegaUtil.isString(scale) ? vegaUtil.stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\n\n  function entry(enc) {\n    if (enc.gradient != null) {\n      return gradient(enc);\n    }\n\n    let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? vegaUtil.stringValue(enc.value) : undefined;\n\n    if (enc.scale != null) {\n      value = scale(enc, value);\n    }\n\n    if (value === undefined) {\n      value = null;\n    }\n\n    if (enc.exponent != null) {\n      value = `pow(${value},${property(enc.exponent)})`;\n    }\n\n    if (enc.mult != null) {\n      value += `*${property(enc.mult)}`;\n    }\n\n    if (enc.offset != null) {\n      value += `+${property(enc.offset)}`;\n    }\n\n    if (enc.round) {\n      value = `round(${value})`;\n    }\n\n    return value;\n  }\n\n  const _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry).join(',')})+'')`;\n\n  function color(enc) {\n    return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\n  }\n\n  function gradient(enc) {\n    // map undefined to null; expression lang does not allow undefined\n    const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : vegaUtil.stringValue(_)); // trim null inputs from the end\n\n    while (args.length && vegaUtil.peek(args) == null) args.pop();\n\n    args.unshift(scaleRef(enc.gradient));\n    return `gradient(${args.join(',')})`;\n  }\n\n  function property(property) {\n    return vegaUtil.isObject(property) ? '(' + entry(property) + ')' : property;\n  }\n\n  function field(ref) {\n    return resolveField(vegaUtil.isObject(ref) ? ref : {\n      datum: ref\n    });\n  }\n\n  function resolveField(ref) {\n    let object, level, field;\n\n    if (ref.signal) {\n      object = 'datum';\n      field = ref.signal;\n    } else if (ref.group || ref.parent) {\n      level = Math.max(1, ref.level || 1);\n      object = 'item';\n\n      while (level-- > 0) {\n        object += '.mark.group';\n      }\n\n      if (ref.parent) {\n        field = ref.parent;\n        object += '.datum';\n      } else {\n        field = ref.group;\n      }\n    } else if (ref.datum) {\n      object = 'datum';\n      field = ref.datum;\n    } else {\n      vegaUtil.error('Invalid field reference: ' + vegaUtil.stringValue(ref));\n    }\n\n    if (!ref.signal) {\n      field = vegaUtil.isString(field) ? vegaUtil.splitAccessPath(field).map(vegaUtil.stringValue).join('][') : resolveField(field);\n    }\n\n    return object + '[' + field + ']';\n  }\n\n  function scale(enc, value) {\n    const scale = scaleRef(enc.scale);\n\n    if (enc.range != null) {\n      // pull value from scale range\n      value = `lerp(_range(${scale}), ${+enc.range})`;\n    } else {\n      // run value through scale and/or pull scale bandwidth\n      if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n      if (enc.band) {\n        value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n        if (enc.extra) {\n          // include logic to handle extraneous elements\n          value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n        }\n      }\n\n      if (value == null) value = '0';\n    }\n\n    return value;\n  }\n\n  function rule (enc) {\n    let code = '';\n    enc.forEach(rule => {\n      const value = entry(rule);\n      code += rule.test ? `(${rule.test})?${value}:` : value;\n    }); // if no else clause, terminate with null (#1366)\n\n    if (vegaUtil.peek(code) === ':') {\n      code += 'null';\n    }\n\n    return code;\n  }\n\n  function parseEncode (encode, type, role, style, scope, params) {\n    const enc = {};\n    params = params || {};\n    params.encoders = {\n      $encode: enc\n    };\n    encode = applyDefaults(encode, type, role, style, scope.config);\n\n    for (const key in encode) {\n      enc[key] = parseBlock(encode[key], type, params, scope);\n    }\n\n    return params;\n  }\n\n  function parseBlock(block, marktype, params, scope) {\n    const channels = {},\n          fields = {};\n\n    for (const name in block) {\n      if (block[name] != null) {\n        // skip any null entries\n        channels[name] = parse(expr(block[name]), scope, params, fields);\n      }\n    }\n\n    return {\n      $expr: {\n        marktype,\n        channels\n      },\n      $fields: Object.keys(fields),\n      $output: Object.keys(block)\n    };\n  }\n\n  function expr(enc) {\n    return vegaUtil.isArray(enc) ? rule(enc) : entry(enc);\n  }\n\n  function parse(code, scope, params, fields) {\n    const expr = vegaFunctions.parseExpression(code, scope);\n    expr.$fields.forEach(name => fields[name] = 1);\n    vegaUtil.extend(params, expr.$params);\n    return expr.$expr;\n  }\n\n  const OUTER = 'outer',\n        OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\n  function outerError(prefix, name) {\n    vegaUtil.error(prefix + ' for \"outer\" push: ' + vegaUtil.stringValue(name));\n  }\n\n  function parseSignal (signal, scope) {\n    const name = signal.name;\n\n    if (signal.push === OUTER) {\n      // signal must already be defined, raise error if not\n      if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\n\n      OUTER_INVALID.forEach(prop => {\n        if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n      });\n    } else {\n      // define a new signal in the current scope\n      const op = scope.addSignal(name, signal.value);\n      if (signal.react === false) op.react = false;\n      if (signal.bind) scope.addBinding(name, signal.bind);\n    }\n  }\n\n  function Entry(type, value, params, parent) {\n    this.id = -1;\n    this.type = type;\n    this.value = value;\n    this.params = params;\n    if (parent) this.parent = parent;\n  }\n  function entry$1(type, value, params, parent) {\n    return new Entry(type, value, params, parent);\n  }\n  function operator(value, params) {\n    return entry$1('operator', value, params);\n  } // -----\n\n  function ref(op) {\n    const ref = {\n      $ref: op.id\n    }; // if operator not yet registered, cache ref to resolve later\n\n    if (op.id < 0) (op.refs = op.refs || []).push(ref);\n    return ref;\n  }\n  function fieldRef(field, name) {\n    return name ? {\n      $field: field,\n      $name: name\n    } : {\n      $field: field\n    };\n  }\n  const keyFieldRef = fieldRef('key');\n  function compareRef(fields, orders) {\n    return {\n      $compare: fields,\n      $order: orders\n    };\n  }\n  function keyRef(fields, flat) {\n    const ref = {\n      $key: fields\n    };\n    if (flat) ref.$flat = true;\n    return ref;\n  } // -----\n\n  const Ascending = 'ascending';\n  const Descending = 'descending';\n  function sortKey(sort) {\n    return !vegaUtil.isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\n  }\n  function aggrField(op, field) {\n    return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\n  } // -----\n\n  const Scope = 'scope';\n  const View = 'view';\n  function isSignal(_) {\n    return _ && _.signal;\n  }\n  function isExpr(_) {\n    return _ && _.expr;\n  }\n  function hasSignal(_) {\n    if (isSignal(_)) return true;\n    if (vegaUtil.isObject(_)) for (const key in _) {\n      if (hasSignal(_[key])) return true;\n    }\n    return false;\n  }\n  function value(specValue, defaultValue) {\n    return specValue != null ? specValue : defaultValue;\n  }\n  function deref(v) {\n    return v && v.signal || v;\n  }\n\n  const Timer = 'timer';\n  function parseStream(stream, scope) {\n    const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : vegaUtil.error('Invalid stream specification: ' + vegaUtil.stringValue(stream));\n    return method(stream, scope);\n  }\n\n  function eventSource(source) {\n    return source === Scope ? View : source || View;\n  }\n\n  function mergeStream(stream, scope) {\n    const list = stream.merge.map(s => parseStream(s, scope)),\n          entry = streamParameters({\n      merge: list\n    }, stream, scope);\n    return scope.addStream(entry).id;\n  }\n\n  function nestedStream(stream, scope) {\n    const id = parseStream(stream.stream, scope),\n          entry = streamParameters({\n      stream: id\n    }, stream, scope);\n    return scope.addStream(entry).id;\n  }\n\n  function eventStream(stream, scope) {\n    let id;\n\n    if (stream.type === Timer) {\n      id = scope.event(Timer, stream.throttle);\n      stream = {\n        between: stream.between,\n        filter: stream.filter\n      };\n    } else {\n      id = scope.event(eventSource(stream.source), stream.type);\n    }\n\n    const entry = streamParameters({\n      stream: id\n    }, stream, scope);\n    return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\n  }\n\n  function streamParameters(entry, stream, scope) {\n    let param = stream.between;\n\n    if (param) {\n      if (param.length !== 2) {\n        vegaUtil.error('Stream \"between\" parameter must have 2 entries: ' + vegaUtil.stringValue(stream));\n      }\n\n      entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\n    }\n\n    param = stream.filter ? [].concat(stream.filter) : [];\n\n    if (stream.marktype || stream.markname || stream.markrole) {\n      // add filter for mark type, name and/or role\n      param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n    }\n\n    if (stream.source === Scope) {\n      // add filter to limit events from sub-scope only\n      param.push('inScope(event.item)');\n    }\n\n    if (param.length) {\n      entry.filter = vegaFunctions.parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n    }\n\n    if ((param = stream.throttle) != null) {\n      entry.throttle = +param;\n    }\n\n    if ((param = stream.debounce) != null) {\n      entry.debounce = +param;\n    }\n\n    if (stream.consume) {\n      entry.consume = true;\n    }\n\n    return entry;\n  }\n\n  function filterMark(type, name, role) {\n    const item = 'event.item';\n    return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '') + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '') + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n  }\n\n  const OP_VALUE_EXPR = {\n    code: '_.$value',\n    ast: {\n      type: 'Identifier',\n      value: 'value'\n    }\n  };\n  function parseUpdate (spec, scope, target) {\n    const encode = spec.encode,\n          entry = {\n      target: target\n    };\n    let events = spec.events,\n        update = spec.update,\n        sources = [];\n\n    if (!events) {\n      vegaUtil.error('Signal update missing events specification.');\n    } // interpret as an event selector string\n\n\n    if (vegaUtil.isString(events)) {\n      events = vegaEventSelector.selector(events, scope.isSubscope() ? Scope : View);\n    } // separate event streams from signal updates\n\n\n    events = vegaUtil.array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\n\n    if (sources.length > 1) {\n      sources = [mergeSources(sources)];\n    } // merge event streams, include as source\n\n\n    if (events.length) {\n      sources.push(events.length > 1 ? {\n        merge: events\n      } : events[0]);\n    }\n\n    if (encode != null) {\n      if (update) vegaUtil.error('Signal encode and update are mutually exclusive.');\n      update = 'encode(item(),' + vegaUtil.stringValue(encode) + ')';\n    } // resolve update value\n\n\n    entry.update = vegaUtil.isString(update) ? vegaFunctions.parseExpression(update, scope) : update.expr != null ? vegaFunctions.parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\n      $expr: OP_VALUE_EXPR,\n      $params: {\n        $value: scope.signalRef(update.signal)\n      }\n    } : vegaUtil.error('Invalid signal update specification.');\n\n    if (spec.force) {\n      entry.options = {\n        force: true\n      };\n    }\n\n    sources.forEach(source => scope.addUpdate(vegaUtil.extend(streamSource(source, scope), entry)));\n  }\n\n  function streamSource(stream, scope) {\n    return {\n      source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\n    };\n  }\n\n  function mergeSources(sources) {\n    return {\n      signal: '[' + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal) + ']'\n    };\n  }\n\n  function parseSignalUpdates (signal, scope) {\n    const op = scope.getSignal(signal.name);\n    let expr = signal.update;\n\n    if (signal.init) {\n      if (expr) {\n        vegaUtil.error('Signals can not include both init and update expressions.');\n      } else {\n        expr = signal.init;\n        op.initonly = true;\n      }\n    }\n\n    if (expr) {\n      expr = vegaFunctions.parseExpression(expr, scope);\n      op.update = expr.$expr;\n      op.params = expr.$params;\n    }\n\n    if (signal.on) {\n      signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n    }\n  }\n\n  const transform = name => (params, value, parent) => entry$1(name, value, params || undefined, parent);\n\n  const Aggregate = transform('aggregate');\n  const AxisTicks = transform('axisticks');\n  const Bound = transform('bound');\n  const Collect = transform('collect');\n  const Compare = transform('compare');\n  const DataJoin = transform('datajoin');\n  const Encode = transform('encode');\n  const Expression = transform('expression');\n  const Facet = transform('facet');\n  const Field = transform('field');\n  const Key = transform('key');\n  const LegendEntries = transform('legendentries');\n  const Load = transform('load');\n  const Mark = transform('mark');\n  const MultiExtent = transform('multiextent');\n  const MultiValues = transform('multivalues');\n  const Overlap = transform('overlap');\n  const Params = transform('params');\n  const PreFacet = transform('prefacet');\n  const Projection = transform('projection');\n  const Proxy = transform('proxy');\n  const Relay = transform('relay');\n  const Render = transform('render');\n  const Scale = transform('scale');\n  const Sieve = transform('sieve');\n  const SortItems = transform('sortitems');\n  const ViewLayout = transform('viewlayout');\n  const Values = transform('values');\n\n  let FIELD_REF_ID = 0;\n  const MULTIDOMAIN_SORT_OPS = {\n    min: 'min',\n    max: 'max',\n    count: 'sum'\n  };\n  function initScale(spec, scope) {\n    const type = spec.type || 'linear';\n\n    if (!vegaScale.isValidScaleType(type)) {\n      vegaUtil.error('Unrecognized scale type: ' + vegaUtil.stringValue(type));\n    }\n\n    scope.addScale(spec.name, {\n      type,\n      domain: undefined\n    });\n  }\n  function parseScale(spec, scope) {\n    const params = scope.getScale(spec.name).params;\n    let key;\n    params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n    if (spec.range != null) {\n      params.range = parseScaleRange(spec, scope, params);\n    }\n\n    if (spec.interpolate != null) {\n      parseScaleInterpolate(spec.interpolate, params);\n    }\n\n    if (spec.nice != null) {\n      params.nice = parseScaleNice(spec.nice);\n    }\n\n    if (spec.bins != null) {\n      params.bins = parseScaleBins(spec.bins, scope);\n    }\n\n    for (key in spec) {\n      if (vegaUtil.hasOwnProperty(params, key) || key === 'name') continue;\n      params[key] = parseLiteral(spec[key], scope);\n    }\n  }\n\n  function parseLiteral(v, scope) {\n    return !vegaUtil.isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : vegaUtil.error('Unsupported object: ' + vegaUtil.stringValue(v));\n  }\n\n  function parseArray(v, scope) {\n    return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\n  }\n\n  function dataLookupError(name) {\n    vegaUtil.error('Can not find data set: ' + vegaUtil.stringValue(name));\n  } // -- SCALE DOMAIN ----\n\n\n  function parseScaleDomain(domain, spec, scope) {\n    if (!domain) {\n      if (spec.domainMin != null || spec.domainMax != null) {\n        vegaUtil.error('No scale domain defined for domainMin/domainMax to override.');\n      }\n\n      return; // default domain\n    }\n\n    return domain.signal ? scope.signalRef(domain.signal) : (vegaUtil.isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\n  }\n\n  function explicitDomain(domain, spec, scope) {\n    return domain.map(v => parseLiteral(v, scope));\n  }\n\n  function singularDomain(domain, spec, scope) {\n    const data = scope.getData(domain.data);\n    if (!data) dataLookupError(domain.data);\n    return vegaScale.isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : vegaScale.isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\n  }\n\n  function multipleDomain(domain, spec, scope) {\n    const data = domain.data,\n          fields = domain.fields.reduce((dom, d) => {\n      d = vegaUtil.isString(d) ? {\n        data: data,\n        field: d\n      } : vegaUtil.isArray(d) || d.signal ? fieldRef$1(d, scope) : d;\n      dom.push(d);\n      return dom;\n    }, []);\n    return (vegaScale.isDiscrete(spec.type) ? ordinalMultipleDomain : vegaScale.isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\n  }\n\n  function fieldRef$1(data, scope) {\n    const name = '_:vega:_' + FIELD_REF_ID++,\n          coll = Collect({});\n\n    if (vegaUtil.isArray(data)) {\n      coll.value = {\n        $ingest: data\n      };\n    } else if (data.signal) {\n      const code = 'setdata(' + vegaUtil.stringValue(name) + ',' + data.signal + ')';\n      coll.params.input = scope.signalRef(code);\n    }\n\n    scope.addDataPipeline(name, [coll, Sieve({})]);\n    return {\n      data: name,\n      field: 'data'\n    };\n  }\n\n  function ordinalMultipleDomain(domain, scope, fields) {\n    const sort = parseSort(domain.sort, true);\n    let a, v; // get value counts for each domain field\n\n    const counts = fields.map(f => {\n      const data = scope.getData(f.data);\n      if (!data) dataLookupError(f.data);\n      return data.countsRef(scope, f.field, sort);\n    }); // aggregate the results from each domain field\n\n    const p = {\n      groupby: keyFieldRef,\n      pulse: counts\n    };\n\n    if (sort) {\n      a = sort.op || 'count';\n      v = sort.field ? aggrField(a, sort.field) : 'count';\n      p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n      p.fields = [scope.fieldRef(v)];\n      p.as = [v];\n    }\n\n    a = scope.add(Aggregate(p)); // collect aggregate output\n\n    const c = scope.add(Collect({\n      pulse: ref(a)\n    })); // extract values for combined domain\n\n    v = scope.add(Values({\n      field: keyFieldRef,\n      sort: scope.sortRef(sort),\n      pulse: ref(c)\n    }));\n    return ref(v);\n  }\n\n  function parseSort(sort, multidomain) {\n    if (sort) {\n      if (!sort.field && !sort.op) {\n        if (vegaUtil.isObject(sort)) sort.field = 'key';else sort = {\n          field: 'key'\n        };\n      } else if (!sort.field && sort.op !== 'count') {\n        vegaUtil.error('No field provided for sort aggregate op: ' + sort.op);\n      } else if (multidomain && sort.field) {\n        if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n          vegaUtil.error('Multiple domain scales can not be sorted using ' + sort.op);\n        }\n      }\n    }\n\n    return sort;\n  }\n\n  function quantileMultipleDomain(domain, scope, fields) {\n    // get value arrays for each domain field\n    const values = fields.map(f => {\n      const data = scope.getData(f.data);\n      if (!data) dataLookupError(f.data);\n      return data.domainRef(scope, f.field);\n    }); // combine value arrays\n\n    return ref(scope.add(MultiValues({\n      values: values\n    })));\n  }\n\n  function numericMultipleDomain(domain, scope, fields) {\n    // get extents for each domain field\n    const extents = fields.map(f => {\n      const data = scope.getData(f.data);\n      if (!data) dataLookupError(f.data);\n      return data.extentRef(scope, f.field);\n    }); // combine extents\n\n    return ref(scope.add(MultiExtent({\n      extents: extents\n    })));\n  } // -- SCALE BINS -----\n\n\n  function parseScaleBins(v, scope) {\n    return v.signal || vegaUtil.isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\n  } // -- SCALE NICE -----\n\n\n  function parseScaleNice(nice) {\n    return vegaUtil.isObject(nice) ? {\n      interval: parseLiteral(nice.interval),\n      step: parseLiteral(nice.step)\n    } : parseLiteral(nice);\n  } // -- SCALE INTERPOLATION -----\n\n\n  function parseScaleInterpolate(interpolate, params) {\n    params.interpolate = parseLiteral(interpolate.type || interpolate);\n\n    if (interpolate.gamma != null) {\n      params.interpolateGamma = parseLiteral(interpolate.gamma);\n    }\n  } // -- SCALE RANGE -----\n\n\n  function parseScaleRange(spec, scope, params) {\n    const config = scope.config.range;\n    let range = spec.range;\n\n    if (range.signal) {\n      return scope.signalRef(range.signal);\n    } else if (vegaUtil.isString(range)) {\n      if (config && vegaUtil.hasOwnProperty(config, range)) {\n        spec = vegaUtil.extend({}, spec, {\n          range: config[range]\n        });\n        return parseScaleRange(spec, scope, params);\n      } else if (range === 'width') {\n        range = [0, {\n          signal: 'width'\n        }];\n      } else if (range === 'height') {\n        range = vegaScale.isDiscrete(spec.type) ? [0, {\n          signal: 'height'\n        }] : [{\n          signal: 'height'\n        }, 0];\n      } else {\n        vegaUtil.error('Unrecognized scale range value: ' + vegaUtil.stringValue(range));\n      }\n    } else if (range.scheme) {\n      params.scheme = vegaUtil.isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\n      if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n      if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n      return;\n    } else if (range.step) {\n      params.rangeStep = parseLiteral(range.step, scope);\n      return;\n    } else if (vegaScale.isDiscrete(spec.type) && !vegaUtil.isArray(range)) {\n      return parseScaleDomain(range, spec, scope);\n    } else if (!vegaUtil.isArray(range)) {\n      vegaUtil.error('Unsupported range type: ' + vegaUtil.stringValue(range));\n    }\n\n    return range.map(v => (vegaUtil.isArray(v) ? parseArray : parseLiteral)(v, scope));\n  }\n\n  function parseProjection (proj, scope) {\n    const config = scope.config.projection || {},\n          params = {};\n\n    for (const name in proj) {\n      if (name === 'name') continue;\n      params[name] = parseParameter(proj[name], name, scope);\n    } // apply projection defaults from config\n\n\n    for (const name in config) {\n      if (params[name] == null) {\n        params[name] = parseParameter(config[name], name, scope);\n      }\n    }\n\n    scope.addProjection(proj.name, params);\n  }\n\n  function parseParameter(_, name, scope) {\n    return vegaUtil.isArray(_) ? _.map(_ => parseParameter(_, name, scope)) : !vegaUtil.isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : vegaUtil.error('Unsupported parameter object: ' + vegaUtil.stringValue(_));\n  }\n\n  const Top = 'top';\n  const Left = 'left';\n  const Right = 'right';\n  const Bottom = 'bottom';\n  const Center = 'center';\n  const Vertical = 'vertical';\n  const Start = 'start';\n  const Middle = 'middle';\n  const End = 'end';\n  const Index = 'index';\n  const Label = 'label';\n  const Offset = 'offset';\n  const Perc = 'perc';\n  const Perc2 = 'perc2';\n  const Value = 'value';\n  const GuideLabelStyle = 'guide-label';\n  const GuideTitleStyle = 'guide-title';\n  const GroupTitleStyle = 'group-title';\n  const GroupSubtitleStyle = 'group-subtitle';\n  const Symbols = 'symbol';\n  const Gradient = 'gradient';\n  const Discrete = 'discrete';\n  const Size = 'size';\n  const Shape = 'shape';\n  const Fill = 'fill';\n  const Stroke = 'stroke';\n  const StrokeWidth = 'strokeWidth';\n  const StrokeDash = 'strokeDash';\n  const Opacity = 'opacity'; // Encoding channels supported by legends\n  // In priority order of 'canonical' scale\n\n  const LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\n  const Skip = {\n    name: 1,\n    style: 1,\n    interactive: 1\n  };\n  const zero = {\n    value: 0\n  };\n  const one = {\n    value: 1\n  };\n\n  const GroupMark = 'group';\n  const RectMark = 'rect';\n  const RuleMark = 'rule';\n  const SymbolMark = 'symbol';\n  const TextMark = 'text';\n\n  function guideGroup (mark) {\n    mark.type = GroupMark;\n    mark.interactive = mark.interactive || false;\n    return mark;\n  }\n\n  function lookup(spec, config) {\n    const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n    _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\n\n    _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\n\n    _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\n\n    _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\n\n    return _;\n  }\n  function getEncoding(name, encode) {\n    const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\n    return v && v.signal ? v : v ? v.value : null;\n  }\n  function getStyle(name, scope, style) {\n    const s = scope.config.style[style];\n    return s && s[name];\n  }\n  function anchorExpr(s, e, m) {\n    return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n  }\n  const alignExpr = anchorExpr(vegaUtil.stringValue(Left), vegaUtil.stringValue(Right), vegaUtil.stringValue(Center));\n  function tickBand(_) {\n    const v = _('tickBand');\n\n    let offset = _('tickOffset'),\n        band,\n        extra;\n\n    if (!v) {\n      // if no tick band entry, fall back on other properties\n      band = _('bandPosition');\n      extra = _('tickExtra');\n    } else if (v.signal) {\n      // if signal, augment code to interpret values\n      band = {\n        signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\n      };\n      extra = {\n        signal: `(${v.signal}) === 'extent'`\n      };\n\n      if (!vegaUtil.isObject(offset)) {\n        offset = {\n          signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\n        };\n      }\n    } else if (v === 'extent') {\n      // if constant, simply set values\n      band = 1;\n      extra = true;\n      offset = 0;\n    } else {\n      band = 0.5;\n      extra = false;\n    }\n\n    return {\n      extra,\n      band,\n      offset\n    };\n  }\n  function extendOffset(value, offset) {\n    return !offset ? value : !value ? offset : !vegaUtil.isObject(value) ? {\n      value,\n      offset\n    } : Object.assign({}, value, {\n      offset: extendOffset(value.offset, offset)\n    });\n  }\n\n  function guideMark (mark, extras) {\n    if (extras) {\n      mark.name = extras.name;\n      mark.style = extras.style || mark.style;\n      mark.interactive = !!extras.interactive;\n      mark.encode = extendEncode(mark.encode, extras, Skip);\n    } else {\n      mark.interactive = false;\n    }\n\n    return mark;\n  }\n\n  function legendGradient (spec, scale, config, userEncode) {\n    const _ = lookup(spec, config),\n          vertical = _.isVertical(),\n          thickness = _.gradientThickness(),\n          length = _.gradientLength();\n\n    let enter, start, stop, width, height;\n\n    if (vertical) {\n      start = [0, 1];\n      stop = [0, 0];\n      width = thickness;\n      height = length;\n    } else {\n      start = [0, 0];\n      stop = [1, 0];\n      width = length;\n      height = thickness;\n    }\n\n    const encode = {\n      enter: enter = {\n        opacity: zero,\n        x: zero,\n        y: zero,\n        width: encoder(width),\n        height: encoder(height)\n      },\n      update: vegaUtil.extend({}, enter, {\n        opacity: one,\n        fill: {\n          gradient: scale,\n          start: start,\n          stop: stop\n        }\n      }),\n      exit: {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      stroke: _('gradientStrokeColor'),\n      strokeWidth: _('gradientStrokeWidth')\n    }, {\n      // update\n      opacity: _('gradientOpacity')\n    });\n    return guideMark({\n      type: RectMark,\n      role: LegendGradientRole,\n      encode\n    }, userEncode);\n  }\n\n  function legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {\n    const _ = lookup(spec, config),\n          vertical = _.isVertical(),\n          thickness = _.gradientThickness(),\n          length = _.gradientLength();\n\n    let u,\n        v,\n        uu,\n        vv,\n        adjust = '';\n    vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n    const enter = {\n      opacity: zero,\n      fill: {\n        scale: scale,\n        field: Value\n      }\n    };\n    enter[u] = {\n      signal: adjust + 'datum.' + Perc,\n      mult: length\n    };\n    enter[v] = zero;\n    enter[uu] = {\n      signal: adjust + 'datum.' + Perc2,\n      mult: length\n    };\n    enter[vv] = encoder(thickness);\n    const encode = {\n      enter: enter,\n      update: vegaUtil.extend({}, enter, {\n        opacity: one\n      }),\n      exit: {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      stroke: _('gradientStrokeColor'),\n      strokeWidth: _('gradientStrokeWidth')\n    }, {\n      // update\n      opacity: _('gradientOpacity')\n    });\n    return guideMark({\n      type: RectMark,\n      role: LegendBandRole,\n      key: Value,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  const alignExpr$1 = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n        baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\n  function legendGradientLabels (spec, config, userEncode, dataRef) {\n    const _ = lookup(spec, config),\n          vertical = _.isVertical(),\n          thickness = encoder(_.gradientThickness()),\n          length = _.gradientLength();\n\n    let overlap = _('labelOverlap'),\n        enter,\n        update,\n        u,\n        v,\n        adjust = '';\n\n    const encode = {\n      enter: enter = {\n        opacity: zero\n      },\n      update: update = {\n        opacity: one,\n        text: {\n          field: Label\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      fill: _('labelColor'),\n      fillOpacity: _('labelOpacity'),\n      font: _('labelFont'),\n      fontSize: _('labelFontSize'),\n      fontStyle: _('labelFontStyle'),\n      fontWeight: _('labelFontWeight'),\n      limit: value(spec.labelLimit, config.gradientLabelLimit)\n    });\n\n    if (vertical) {\n      enter.align = {\n        value: 'left'\n      };\n      enter.baseline = update.baseline = {\n        signal: baselineExpr\n      };\n      u = 'y';\n      v = 'x';\n      adjust = '1-';\n    } else {\n      enter.align = update.align = {\n        signal: alignExpr$1\n      };\n      enter.baseline = {\n        value: 'top'\n      };\n      u = 'x';\n      v = 'y';\n    }\n\n    enter[u] = update[u] = {\n      signal: adjust + 'datum.' + Perc,\n      mult: length\n    };\n    enter[v] = update[v] = thickness;\n    thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n    overlap = overlap ? {\n      separation: _('labelSeparation'),\n      method: overlap,\n      order: 'datum.' + Index\n    } : undefined; // type, role, style, key, dataRef, encode, extras\n\n    return guideMark({\n      type: TextMark,\n      role: LegendLabelRole,\n      style: GuideLabelStyle,\n      key: Value,\n      from: dataRef,\n      encode,\n      overlap\n    }, userEncode);\n  }\n\n  function legendSymbolGroups (spec, config, userEncode, dataRef, columns) {\n    const _ = lookup(spec, config),\n          entries = userEncode.entries,\n          interactive = !!(entries && entries.interactive),\n          name = entries ? entries.name : undefined,\n          height = _('clipHeight'),\n          symbolOffset = _('symbolOffset'),\n          valueRef = {\n      data: 'value'\n    },\n          xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n          yEncode = height ? encoder(height) : {\n      field: Size\n    },\n          index = `datum.${Index}`,\n          ncols = `max(1, ${columns})`;\n\n    let encode, enter, update, nrows, sort;\n    yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\n\n    encode = {\n      enter: enter = {\n        opacity: zero,\n        x: {\n          signal: xSignal,\n          mult: 0.5,\n          offset: symbolOffset\n        },\n        y: yEncode\n      },\n      update: update = {\n        opacity: one,\n        x: enter.x,\n        y: enter.y\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n    let baseFill = null,\n        baseStroke = null;\n\n    if (!spec.fill) {\n      baseFill = config.symbolBaseFillColor;\n      baseStroke = config.symbolBaseStrokeColor;\n    }\n\n    addEncoders(encode, {\n      fill: _('symbolFillColor', baseFill),\n      shape: _('symbolType'),\n      size: _('symbolSize'),\n      stroke: _('symbolStrokeColor', baseStroke),\n      strokeDash: _('symbolDash'),\n      strokeDashOffset: _('symbolDashOffset'),\n      strokeWidth: _('symbolStrokeWidth')\n    }, {\n      // update\n      opacity: _('symbolOpacity')\n    });\n    LegendScales.forEach(scale => {\n      if (spec[scale]) {\n        update[scale] = enter[scale] = {\n          scale: spec[scale],\n          field: Value\n        };\n      }\n    });\n    const symbols = guideMark({\n      type: SymbolMark,\n      role: LegendSymbolRole,\n      key: Value,\n      from: valueRef,\n      clip: height ? true : undefined,\n      encode\n    }, userEncode.symbols); // -- LEGEND LABELS --\n\n    const labelOffset = encoder(symbolOffset);\n    labelOffset.offset = _('labelOffset');\n    encode = {\n      enter: enter = {\n        opacity: zero,\n        x: {\n          signal: xSignal,\n          offset: labelOffset\n        },\n        y: yEncode\n      },\n      update: update = {\n        opacity: one,\n        text: {\n          field: Label\n        },\n        x: enter.x,\n        y: enter.y\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      align: _('labelAlign'),\n      baseline: _('labelBaseline'),\n      fill: _('labelColor'),\n      fillOpacity: _('labelOpacity'),\n      font: _('labelFont'),\n      fontSize: _('labelFontSize'),\n      fontStyle: _('labelFontStyle'),\n      fontWeight: _('labelFontWeight'),\n      limit: _('labelLimit')\n    });\n    const labels = guideMark({\n      type: TextMark,\n      role: LegendLabelRole,\n      style: GuideLabelStyle,\n      key: Value,\n      from: valueRef,\n      encode\n    }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\n\n    encode = {\n      enter: {\n        noBound: {\n          value: !height\n        },\n        // ignore width/height in bounds calc\n        width: zero,\n        height: height ? encoder(height) : zero,\n        opacity: zero\n      },\n      exit: {\n        opacity: zero\n      },\n      update: update = {\n        opacity: one,\n        row: {\n          signal: null\n        },\n        column: {\n          signal: null\n        }\n      }\n    }; // annotate and sort groups to ensure correct ordering\n\n    if (_.isVertical(true)) {\n      nrows = `ceil(item.mark.items.length / ${ncols})`;\n      update.row.signal = `${index}%${nrows}`;\n      update.column.signal = `floor(${index} / ${nrows})`;\n      sort = {\n        field: ['row', index]\n      };\n    } else {\n      update.row.signal = `floor(${index} / ${ncols})`;\n      update.column.signal = `${index} % ${ncols}`;\n      sort = {\n        field: index\n      };\n    } // handle zero column case (implies infinite columns)\n\n\n    update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups\n\n    dataRef = {\n      facet: {\n        data: dataRef,\n        name: 'value',\n        groupby: Index\n      }\n    };\n    return guideGroup({\n      role: ScopeRole,\n      from: dataRef,\n      encode: extendEncode(encode, entries, Skip),\n      marks: [symbols, labels],\n      name,\n      interactive,\n      sort\n    });\n  }\n  function legendSymbolLayout(spec, config) {\n    const _ = lookup(spec, config); // layout parameters for legend entries\n\n\n    return {\n      align: _('gridAlign'),\n      columns: _.entryColumns(),\n      center: {\n        row: true,\n        column: false\n      },\n      padding: {\n        row: _('rowPadding'),\n        column: _('columnPadding')\n      }\n    };\n  }\n\n  const isL = 'item.orient === \"left\"',\n        isR = 'item.orient === \"right\"',\n        isLR = `(${isL} || ${isR})`,\n        isVG = `datum.vgrad && ${isLR}`,\n        baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n        alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n        exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr}`,\n        exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n        exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n        exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\n  function legendTitle (spec, config, userEncode, dataRef) {\n    const _ = lookup(spec, config);\n\n    const encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: one,\n        x: {\n          field: {\n            group: 'padding'\n          }\n        },\n        y: {\n          field: {\n            group: 'padding'\n          }\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      orient: _('titleOrient'),\n      _anchor: _('titleAnchor'),\n      anchor: {\n        signal: exprAnchor\n      },\n      angle: {\n        signal: exprAngle\n      },\n      align: {\n        signal: exprAlign\n      },\n      baseline: {\n        signal: exprBaseline\n      },\n      text: spec.title,\n      fill: _('titleColor'),\n      fillOpacity: _('titleOpacity'),\n      font: _('titleFont'),\n      fontSize: _('titleFontSize'),\n      fontStyle: _('titleFontStyle'),\n      fontWeight: _('titleFontWeight'),\n      limit: _('titleLimit'),\n      lineHeight: _('titleLineHeight')\n    }, {\n      // require update\n      align: _('titleAlign'),\n      baseline: _('titleBaseline')\n    });\n    return guideMark({\n      type: TextMark,\n      role: LegendTitleRole,\n      style: GuideTitleStyle,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function clip (clip, scope) {\n    let expr;\n\n    if (vegaUtil.isObject(clip)) {\n      if (clip.signal) {\n        expr = clip.signal;\n      } else if (clip.path) {\n        expr = 'pathShape(' + param(clip.path) + ')';\n      } else if (clip.sphere) {\n        expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n      }\n    }\n\n    return expr ? scope.signalRef(expr) : !!clip;\n  }\n\n  function param(value) {\n    return vegaUtil.isObject(value) && value.signal ? value.signal : vegaUtil.stringValue(value);\n  }\n\n  function getRole (spec) {\n    const role = spec.role || '';\n    return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\n  }\n\n  function definition (spec) {\n    return {\n      marktype: spec.type,\n      name: spec.name || undefined,\n      role: spec.role || getRole(spec),\n      zindex: +spec.zindex || undefined,\n      aria: spec.aria,\n      description: spec.description\n    };\n  }\n\n  function interactive (spec, scope) {\n    return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\n  }\n\n  /**\n   * Parse a data transform specification.\n   */\n\n  function parseTransform (spec, scope) {\n    const def = vegaDataflow.definition(spec.type);\n    if (!def) vegaUtil.error('Unrecognized transform type: ' + vegaUtil.stringValue(spec.type));\n    const t = entry$1(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n    if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n    t.metadata = def.metadata || {};\n    return t;\n  }\n  /**\n   * Parse all parameters of a data transform.\n   */\n\n  function parseParameters(def, spec, scope) {\n    const params = {},\n          n = def.params.length;\n\n    for (let i = 0; i < n; ++i) {\n      const pdef = def.params[i];\n      params[pdef.name] = parseParameter$1(pdef, spec, scope);\n    }\n\n    return params;\n  }\n  /**\n   * Parse a data transform parameter.\n   */\n\n\n  function parseParameter$1(def, spec, scope) {\n    const type = def.type,\n          value = spec[def.name];\n\n    if (type === 'index') {\n      return parseIndexParameter(def, spec, scope);\n    } else if (value === undefined) {\n      if (def.required) {\n        vegaUtil.error('Missing required ' + vegaUtil.stringValue(spec.type) + ' parameter: ' + vegaUtil.stringValue(def.name));\n      }\n\n      return;\n    } else if (type === 'param') {\n      return parseSubParameters(def, spec, scope);\n    } else if (type === 'projection') {\n      return scope.projectionRef(spec[def.name]);\n    }\n\n    return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\n  }\n  /**\n   * Parse a single parameter value.\n   */\n\n\n  function parameterValue(def, value, scope) {\n    const type = def.type;\n\n    if (isSignal(value)) {\n      return isExpr$1(type) ? vegaUtil.error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\n    } else {\n      const expr = def.expr || isField(type);\n      return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef(value.field, value.as) : isExpr$1(type) ? vegaFunctions.parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef(value) : isCompare(type) ? scope.compareRef(value) : value;\n    }\n  }\n  /**\n   * Parse parameter for accessing an index of another data set.\n   */\n\n\n  function parseIndexParameter(def, spec, scope) {\n    if (!vegaUtil.isString(spec.from)) {\n      vegaUtil.error('Lookup \"from\" parameter must be a string literal.');\n    }\n\n    return scope.getData(spec.from).lookupRef(scope, spec.key);\n  }\n  /**\n   * Parse a parameter that contains one or more sub-parameter objects.\n   */\n\n\n  function parseSubParameters(def, spec, scope) {\n    const value = spec[def.name];\n\n    if (def.array) {\n      if (!vegaUtil.isArray(value)) {\n        // signals not allowed!\n        vegaUtil.error('Expected an array of sub-parameters. Instead: ' + vegaUtil.stringValue(value));\n      }\n\n      return value.map(v => parseSubParameter(def, v, scope));\n    } else {\n      return parseSubParameter(def, value, scope);\n    }\n  }\n  /**\n   * Parse a sub-parameter object.\n   */\n\n\n  function parseSubParameter(def, value, scope) {\n    const n = def.params.length;\n    let pdef; // loop over defs to find matching key\n\n    for (let i = 0; i < n; ++i) {\n      pdef = def.params[i];\n\n      for (const k in pdef.key) {\n        if (pdef.key[k] !== value[k]) {\n          pdef = null;\n          break;\n        }\n      }\n\n      if (pdef) break;\n    } // raise error if matching key not found\n\n\n    if (!pdef) vegaUtil.error('Unsupported parameter: ' + vegaUtil.stringValue(value)); // parse params, create Params transform, return ref\n\n    const params = vegaUtil.extend(parseParameters(pdef, value, scope), pdef.key);\n    return ref(scope.add(Params(params)));\n  } // -- Utilities -----\n\n\n  const outerExpr = _ => _ && _.expr;\n  const outerField = _ => _ && _.field;\n  const isData = _ => _ === 'data';\n  const isExpr$1 = _ => _ === 'expr';\n  const isField = _ => _ === 'field';\n  const isCompare = _ => _ === 'compare';\n\n  function parseData (from, group, scope) {\n    let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\n\n    if (!from) {\n      dataRef = ref(scope.add(Collect(null, [{}])));\n    } // if faceted, process facet specification\n    else if (facet = from.facet) {\n        if (!group) vegaUtil.error('Only group marks can be faceted.'); // use pre-faceted source data, if available\n\n        if (facet.field != null) {\n          dataRef = parent = getDataRef(facet, scope);\n        } else {\n          // generate facet aggregates if no direct data specification\n          if (!from.data) {\n            op = parseTransform(vegaUtil.extend({\n              type: 'aggregate',\n              groupby: vegaUtil.array(facet.groupby)\n            }, facet.aggregate), scope);\n            op.params.key = scope.keyRef(facet.groupby);\n            op.params.pulse = getDataRef(facet, scope);\n            dataRef = parent = ref(scope.add(op));\n          } else {\n            parent = ref(scope.getData(from.data).aggregate);\n          }\n\n          key = scope.keyRef(facet.groupby, true);\n        }\n      } // if not yet defined, get source data reference\n\n\n    if (!dataRef) {\n      dataRef = getDataRef(from, scope);\n    }\n\n    return {\n      key: key,\n      pulse: dataRef,\n      parent: parent\n    };\n  }\n  function getDataRef(from, scope) {\n    return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\n  }\n\n  function DataScope(scope, input, output, values, aggr) {\n    this.scope = scope; // parent scope object\n\n    this.input = input; // first operator in pipeline (tuple input)\n\n    this.output = output; // last operator in pipeline (tuple output)\n\n    this.values = values; // operator for accessing tuples (but not tuple flow)\n    // last aggregate in transform pipeline\n\n    this.aggregate = aggr; // lookup table of field indices\n\n    this.index = {};\n  }\n\n  DataScope.fromEntries = function (scope, entries) {\n    const n = entries.length,\n          values = entries[n - 1],\n          output = entries[n - 2];\n    let input = entries[0],\n        aggr = null,\n        i = 1;\n\n    if (input && input.type === 'load') {\n      input = entries[1];\n    } // add operator entries to this scope, wire up pulse chain\n\n\n    scope.add(entries[0]);\n\n    for (; i < n; ++i) {\n      entries[i].params.pulse = ref(entries[i - 1]);\n      scope.add(entries[i]);\n      if (entries[i].type === 'aggregate') aggr = entries[i];\n    }\n\n    return new DataScope(scope, input, output, values, aggr);\n  };\n\n  function fieldKey(field) {\n    return vegaUtil.isString(field) ? field : null;\n  }\n\n  function addSortField(scope, p, sort) {\n    const as = aggrField(sort.op, sort.field);\n    let s;\n\n    if (p.ops) {\n      for (let i = 0, n = p.as.length; i < n; ++i) {\n        if (p.as[i] === as) return;\n      }\n    } else {\n      p.ops = ['count'];\n      p.fields = [null];\n      p.as = ['count'];\n    }\n\n    if (sort.op) {\n      p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\n      p.fields.push(scope.fieldRef(sort.field));\n      p.as.push(as);\n    }\n  }\n\n  function cache(scope, ds, name, optype, field, counts, index) {\n    const cache = ds[name] || (ds[name] = {}),\n          sort = sortKey(counts);\n    let k = fieldKey(field),\n        v,\n        op;\n\n    if (k != null) {\n      scope = ds.scope;\n      k = k + (sort ? '|' + sort : '');\n      v = cache[k];\n    }\n\n    if (!v) {\n      const params = counts ? {\n        field: keyFieldRef,\n        pulse: ds.countsRef(scope, field, counts)\n      } : {\n        field: scope.fieldRef(field),\n        pulse: ref(ds.output)\n      };\n      if (sort) params.sort = scope.sortRef(counts);\n      op = scope.add(entry$1(optype, undefined, params));\n      if (index) ds.index[field] = op;\n      v = ref(op);\n      if (k != null) cache[k] = v;\n    }\n\n    return v;\n  }\n\n  DataScope.prototype = {\n    countsRef(scope, field, sort) {\n      const ds = this,\n            cache = ds.counts || (ds.counts = {}),\n            k = fieldKey(field);\n      let v, a, p;\n\n      if (k != null) {\n        scope = ds.scope;\n        v = cache[k];\n      }\n\n      if (!v) {\n        p = {\n          groupby: scope.fieldRef(field, 'key'),\n          pulse: ref(ds.output)\n        };\n        if (sort && sort.field) addSortField(scope, p, sort);\n        a = scope.add(Aggregate(p));\n        v = scope.add(Collect({\n          pulse: ref(a)\n        }));\n        v = {\n          agg: a,\n          ref: ref(v)\n        };\n        if (k != null) cache[k] = v;\n      } else if (sort && sort.field) {\n        addSortField(scope, v.agg.params, sort);\n      }\n\n      return v.ref;\n    },\n\n    tuplesRef() {\n      return ref(this.values);\n    },\n\n    extentRef(scope, field) {\n      return cache(scope, this, 'extent', 'extent', field, false);\n    },\n\n    domainRef(scope, field) {\n      return cache(scope, this, 'domain', 'values', field, false);\n    },\n\n    valuesRef(scope, field, sort) {\n      return cache(scope, this, 'vals', 'values', field, sort || true);\n    },\n\n    lookupRef(scope, field) {\n      return cache(scope, this, 'lookup', 'tupleindex', field, false);\n    },\n\n    indataRef(scope, field) {\n      return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n    }\n\n  };\n\n  function parseFacet (spec, scope, group) {\n    const facet = spec.from.facet,\n          name = facet.name,\n          data = getDataRef(facet, scope);\n    let op;\n\n    if (!facet.name) {\n      vegaUtil.error('Facet must have a name: ' + vegaUtil.stringValue(facet));\n    }\n\n    if (!facet.data) {\n      vegaUtil.error('Facet must reference a data set: ' + vegaUtil.stringValue(facet));\n    }\n\n    if (facet.field) {\n      op = scope.add(PreFacet({\n        field: scope.fieldRef(facet.field),\n        pulse: data\n      }));\n    } else if (facet.groupby) {\n      op = scope.add(Facet({\n        key: scope.keyRef(facet.groupby),\n        group: ref(scope.proxy(group.parent)),\n        pulse: data\n      }));\n    } else {\n      vegaUtil.error('Facet must specify groupby or field: ' + vegaUtil.stringValue(facet));\n    } // initialize facet subscope\n\n\n    const subscope = scope.fork(),\n          source = subscope.add(Collect()),\n          values = subscope.add(Sieve({\n      pulse: ref(source)\n    }));\n    subscope.addData(name, new DataScope(subscope, source, source, values));\n    subscope.addSignal('parent', null); // parse faceted subflow\n\n    op.params.subflow = {\n      $subflow: subscope.parse(spec).toRuntime()\n    };\n  }\n\n  function parseSubflow (spec, scope, input) {\n    const op = scope.add(PreFacet({\n      pulse: input.pulse\n    })),\n          subscope = scope.fork();\n    subscope.add(Sieve());\n    subscope.addSignal('parent', null); // parse group mark subflow\n\n    op.params.subflow = {\n      $subflow: subscope.parse(spec).toRuntime()\n    };\n  }\n\n  function parseTrigger (spec, scope, name) {\n    const remove = spec.remove,\n          insert = spec.insert,\n          toggle = spec.toggle,\n          modify = spec.modify,\n          values = spec.values,\n          op = scope.add(operator());\n    const update = 'if(' + spec.trigger + ',modify(\"' + name + '\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\n    const expr = vegaFunctions.parseExpression(update, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  function parseMark (spec, scope) {\n    const role = getRole(spec),\n          group = spec.type === GroupMark,\n          facet = spec.from && spec.from.facet,\n          overlap = spec.overlap;\n    let layout = spec.layout || role === ScopeRole || role === FrameRole,\n        ops,\n        op,\n        store,\n        enc,\n        name,\n        layoutRef,\n        boundRef;\n    const nested = role === MarkRole || layout || facet; // resolve input data\n\n    const input = parseData(spec.from, group, scope); // data join to map tuples to visual items\n\n    op = scope.add(DataJoin({\n      key: input.key || (spec.key ? fieldRef(spec.key) : undefined),\n      pulse: input.pulse,\n      clean: !group\n    }));\n    const joinRef = ref(op); // collect visual items\n\n    op = store = scope.add(Collect({\n      pulse: joinRef\n    })); // connect visual items to scenegraph\n\n    op = scope.add(Mark({\n      markdef: definition(spec),\n      interactive: interactive(spec.interactive, scope),\n      clip: clip(spec.clip, scope),\n      context: {\n        $context: true\n      },\n      groups: scope.lookup(),\n      parent: scope.signals.parent ? scope.signalRef('parent') : null,\n      index: scope.markpath(),\n      pulse: ref(op)\n    }));\n    const markRef = ref(op); // add visual encoders\n\n    op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\n      mod: false,\n      pulse: markRef\n    }))); // monitor parent marks to propagate changes\n\n    op.params.parent = scope.encode(); // add post-encoding transforms, if defined\n\n    if (spec.transform) {\n      spec.transform.forEach(_ => {\n        const tx = parseTransform(_, scope),\n              md = tx.metadata;\n\n        if (md.generates || md.changes) {\n          vegaUtil.error('Mark transforms should not generate new data.');\n        }\n\n        if (!md.nomod) enc.params.mod = true; // update encode mod handling\n\n        tx.params.pulse = ref(op);\n        scope.add(op = tx);\n      });\n    } // if item sort specified, perform post-encoding\n\n\n    if (spec.sort) {\n      op = scope.add(SortItems({\n        sort: scope.compareRef(spec.sort),\n        pulse: ref(op)\n      }));\n    }\n\n    const encodeRef = ref(op); // add view layout operator if needed\n\n    if (facet || layout) {\n      layout = scope.add(ViewLayout({\n        layout: scope.objectProperty(spec.layout),\n        legends: scope.legends,\n        mark: markRef,\n        pulse: encodeRef\n      }));\n      layoutRef = ref(layout);\n    } // compute bounding boxes\n\n\n    const bound = scope.add(Bound({\n      mark: markRef,\n      pulse: layoutRef || encodeRef\n    }));\n    boundRef = ref(bound); // if group mark, recurse to parse nested content\n\n    if (group) {\n      // juggle layout & bounds to ensure they run *after* any faceting transforms\n      if (nested) {\n        ops = scope.operators;\n        ops.pop();\n        if (layout) ops.pop();\n      }\n\n      scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n      facet ? parseFacet(spec, scope, input) // explicit facet\n      : nested ? parseSubflow(spec, scope, input) // standard mark group\n      : scope.parse(spec); // guide group, we can avoid nested scopes\n\n      scope.popState();\n\n      if (nested) {\n        if (layout) ops.push(layout);\n        ops.push(bound);\n      }\n    } // if requested, add overlap removal transform\n\n\n    if (overlap) {\n      boundRef = parseOverlap(overlap, boundRef, scope);\n    } // render / sieve items\n\n\n    const render = scope.add(Render({\n      pulse: boundRef\n    })),\n          sieve = scope.add(Sieve({\n      pulse: ref(render)\n    }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\n    // add trigger updates if defined\n\n    if (spec.name != null) {\n      name = spec.name;\n      scope.addData(name, new DataScope(scope, store, render, sieve));\n      if (spec.on) spec.on.forEach(on => {\n        if (on.insert || on.remove || on.toggle) {\n          vegaUtil.error('Marks only support modify triggers.');\n        }\n\n        parseTrigger(on, scope, name);\n      });\n    }\n  }\n\n  function parseOverlap(overlap, source, scope) {\n    const method = overlap.method,\n          bound = overlap.bound,\n          sep = overlap.separation;\n    const params = {\n      separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n      method: isSignal(method) ? scope.signalRef(method.signal) : method,\n      pulse: source\n    };\n\n    if (overlap.order) {\n      params.sort = scope.compareRef({\n        field: overlap.order\n      });\n    }\n\n    if (bound) {\n      const tol = bound.tolerance;\n      params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n      params.boundScale = scope.scaleRef(bound.scale);\n      params.boundOrient = bound.orient;\n    }\n\n    return ref(scope.add(Overlap(params)));\n  }\n\n  function parseLegend (spec, scope) {\n    const config = scope.config.legend,\n          encode = spec.encode || {},\n          _ = lookup(spec, config),\n          legendEncode = encode.legend || {},\n          name = legendEncode.name || undefined,\n          interactive = legendEncode.interactive,\n          style = legendEncode.style,\n          scales = {};\n\n    let scale = 0,\n        entryLayout,\n        params,\n        children; // resolve scales and 'canonical' scale name\n\n    LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\n    if (!scale) vegaUtil.error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\n\n    const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\n\n    const datum = {\n      title: spec.title != null,\n      scales: scales,\n      type: type,\n      vgrad: type !== 'symbol' && _.isVertical()\n    };\n    const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\n\n    const entryEncode = {\n      enter: {\n        x: {\n          value: 0\n        },\n        y: {\n          value: 0\n        }\n      }\n    }; // data source for legend values\n\n    const entryRef = ref(scope.add(LegendEntries(params = {\n      type: type,\n      scale: scope.scaleRef(scale),\n      count: scope.objectProperty(_('tickCount')),\n      limit: scope.property(_('symbolLimit')),\n      values: scope.objectProperty(spec.values),\n      minstep: scope.property(spec.tickMinStep),\n      formatType: scope.property(spec.formatType),\n      formatSpecifier: scope.property(spec.format)\n    }))); // continuous gradient legend\n\n    if (type === Gradient) {\n      children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\n\n      params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\n    } // discrete gradient legend\n    else if (type === Discrete) {\n        children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\n      } // symbol legend\n      else {\n          // determine legend symbol group layout\n          entryLayout = legendSymbolLayout(spec, config);\n          children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\n\n          params.size = sizeExpression(spec, scope, children[0].marks);\n        } // generate legend marks\n\n\n    children = [guideGroup({\n      role: LegendEntryRole,\n      from: dataRef,\n      encode: entryEncode,\n      marks: children,\n      layout: entryLayout,\n      interactive\n    })]; // include legend title if defined\n\n    if (datum.title) {\n      children.push(legendTitle(spec, config, encode.title, dataRef));\n    } // parse legend specification\n\n\n    return parseMark(guideGroup({\n      role: LegendRole,\n      from: dataRef,\n      encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n      marks: children,\n      aria: _('aria'),\n      description: _('description'),\n      zindex: _('zindex'),\n      name,\n      interactive,\n      style\n    }), scope);\n  }\n\n  function legendType(spec, scaleType) {\n    let type = spec.type || Symbols;\n\n    if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n      type = vegaScale.isContinuous(scaleType) ? Gradient : vegaScale.isDiscretizing(scaleType) ? Discrete : Symbols;\n    }\n\n    return type !== Gradient ? type : vegaScale.isDiscretizing(scaleType) ? Discrete : Gradient;\n  }\n\n  function scaleCount(spec) {\n    return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n  }\n\n  function buildLegendEncode(_, spec, config) {\n    const encode = {\n      enter: {},\n      update: {}\n    };\n    addEncoders(encode, {\n      orient: _('orient'),\n      offset: _('offset'),\n      padding: _('padding'),\n      titlePadding: _('titlePadding'),\n      cornerRadius: _('cornerRadius'),\n      fill: _('fillColor'),\n      stroke: _('strokeColor'),\n      strokeWidth: config.strokeWidth,\n      strokeDash: config.strokeDash,\n      x: _('legendX'),\n      y: _('legendY'),\n      // accessibility support\n      format: spec.format,\n      formatType: spec.formatType\n    });\n    return encode;\n  }\n\n  function sizeExpression(spec, scope, marks) {\n    const size = deref(getChannel('size', spec, marks)),\n          strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n          fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n    return vegaFunctions.parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\n  }\n\n  function getChannel(name, spec, marks) {\n    return spec[name] ? `scale(\"${spec[name]}\",datum)` : getEncoding(name, marks[0].encode);\n  }\n\n  function getFontSize(encode, scope, style) {\n    return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n  }\n\n  const angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\n  function parseTitle (spec, scope) {\n    spec = vegaUtil.isString(spec) ? {\n      text: spec\n    } : spec;\n\n    const _ = lookup(spec, scope.config.title),\n          encode = spec.encode || {},\n          userEncode = encode.group || {},\n          name = userEncode.name || undefined,\n          interactive = userEncode.interactive,\n          style = userEncode.style,\n          children = []; // single-element data source for group title\n\n\n    const datum = {},\n          dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\n\n    children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\n\n    if (spec.subtitle) {\n      children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n    } // parse title specification\n\n\n    return parseMark(guideGroup({\n      role: TitleRole,\n      from: dataRef,\n      encode: groupEncode(_, userEncode),\n      marks: children,\n      aria: _('aria'),\n      description: _('description'),\n      zindex: _('zindex'),\n      name,\n      interactive,\n      style\n    }), scope);\n  } // provide backwards-compatibility for title custom encode;\n  // the top-level encode block has been *deprecated*.\n\n  function titleEncode(spec) {\n    const encode = spec.encode;\n    return encode && encode.title || vegaUtil.extend({\n      name: spec.name,\n      interactive: spec.interactive,\n      style: spec.style\n    }, encode);\n  }\n\n  function groupEncode(_, userEncode) {\n    const encode = {\n      enter: {},\n      update: {}\n    };\n    addEncoders(encode, {\n      orient: _('orient'),\n      anchor: _('anchor'),\n      align: {\n        signal: alignExpr\n      },\n      angle: {\n        signal: angleExpr\n      },\n      limit: _('limit'),\n      frame: _('frame'),\n      offset: _('offset') || 0,\n      padding: _('subtitlePadding')\n    });\n    return extendEncode(encode, userEncode, Skip);\n  }\n\n  function buildTitle(spec, _, userEncode, dataRef) {\n    const zero = {\n      value: 0\n    },\n          text = spec.text,\n          encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: {\n          value: 1\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      text: text,\n      align: {\n        signal: 'item.mark.group.align'\n      },\n      angle: {\n        signal: 'item.mark.group.angle'\n      },\n      limit: {\n        signal: 'item.mark.group.limit'\n      },\n      baseline: 'top',\n      dx: _('dx'),\n      dy: _('dy'),\n      fill: _('color'),\n      font: _('font'),\n      fontSize: _('fontSize'),\n      fontStyle: _('fontStyle'),\n      fontWeight: _('fontWeight'),\n      lineHeight: _('lineHeight')\n    }, {\n      // update\n      align: _('align'),\n      angle: _('angle'),\n      baseline: _('baseline')\n    });\n    return guideMark({\n      type: TextMark,\n      role: TitleTextRole,\n      style: GroupTitleStyle,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function buildSubTitle(spec, _, userEncode, dataRef) {\n    const zero = {\n      value: 0\n    },\n          text = spec.subtitle,\n          encode = {\n      enter: {\n        opacity: zero\n      },\n      update: {\n        opacity: {\n          value: 1\n        }\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      text: text,\n      align: {\n        signal: 'item.mark.group.align'\n      },\n      angle: {\n        signal: 'item.mark.group.angle'\n      },\n      limit: {\n        signal: 'item.mark.group.limit'\n      },\n      baseline: 'top',\n      dx: _('dx'),\n      dy: _('dy'),\n      fill: _('subtitleColor'),\n      font: _('subtitleFont'),\n      fontSize: _('subtitleFontSize'),\n      fontStyle: _('subtitleFontStyle'),\n      fontWeight: _('subtitleFontWeight'),\n      lineHeight: _('subtitleLineHeight')\n    }, {\n      // update\n      align: _('align'),\n      angle: _('angle'),\n      baseline: _('baseline')\n    });\n    return guideMark({\n      type: TextMark,\n      role: TitleSubtitleRole,\n      style: GroupSubtitleStyle,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function parseData$1(data, scope) {\n    const transforms = [];\n\n    if (data.transform) {\n      data.transform.forEach(tx => {\n        transforms.push(parseTransform(tx, scope));\n      });\n    }\n\n    if (data.on) {\n      data.on.forEach(on => {\n        parseTrigger(on, scope, data.name);\n      });\n    }\n\n    scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n  }\n  /**\n   * Analyze a data pipeline, add needed operators.\n   */\n\n  function analyze(data, scope, ops) {\n    const output = [];\n    let source = null,\n        modify = false,\n        generate = false,\n        upstream,\n        i,\n        n,\n        t,\n        m;\n\n    if (data.values) {\n      // hard-wired input data set\n      if (isSignal(data.values) || hasSignal(data.format)) {\n        // if either values is signal or format has signal, use dynamic loader\n        output.push(load(scope, data));\n        output.push(source = collect());\n      } else {\n        // otherwise, ingest upon dataflow init\n        output.push(source = collect({\n          $ingest: data.values,\n          $format: data.format\n        }));\n      }\n    } else if (data.url) {\n      // load data from external source\n      if (hasSignal(data.url) || hasSignal(data.format)) {\n        // if either url or format has signal, use dynamic loader\n        output.push(load(scope, data));\n        output.push(source = collect());\n      } else {\n        // otherwise, request load upon dataflow init\n        output.push(source = collect({\n          $request: data.url,\n          $format: data.format\n        }));\n      }\n    } else if (data.source) {\n      // derives from one or more other data sets\n      source = upstream = vegaUtil.array(data.source).map(d => ref(scope.getData(d).output));\n      output.push(null); // populate later\n    } // scan data transforms, add collectors as needed\n\n\n    for (i = 0, n = ops.length; i < n; ++i) {\n      t = ops[i];\n      m = t.metadata;\n\n      if (!source && !m.source) {\n        output.push(source = collect());\n      }\n\n      output.push(t);\n      if (m.generates) generate = true;\n      if (m.modifies && !generate) modify = true;\n      if (m.source) source = t;else if (m.changes) source = null;\n    }\n\n    if (upstream) {\n      n = upstream.length - 1;\n      output[0] = Relay({\n        derive: modify,\n        pulse: n ? upstream : upstream[0]\n      });\n\n      if (modify || n) {\n        // collect derived and multi-pulse tuples\n        output.splice(1, 0, collect());\n      }\n    }\n\n    if (!source) output.push(collect());\n    output.push(Sieve({}));\n    return output;\n  }\n\n  function collect(values) {\n    const s = Collect({}, values);\n    s.metadata = {\n      source: true\n    };\n    return s;\n  }\n\n  function load(scope, data) {\n    return Load({\n      url: data.url ? scope.property(data.url) : undefined,\n      async: data.async ? scope.property(data.async) : undefined,\n      values: data.values ? scope.property(data.values) : undefined,\n      format: scope.objectProperty(data.format)\n    });\n  }\n\n  const isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\n\n\n  const getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\n\n  const ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\n\n  const ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\n  const ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\n    value: a\n  } : {\n    value: b\n  };\n  const ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\n    value: a\n  } : {\n    value: b\n  };\n\n  const ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\n\n  const ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\n\n  const ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\n\n  const ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\n\n  const ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\n\n  const ifEnc = (test, a, b) => {\n    // ensure inputs are encoder objects (or null)\n    a = a != null ? encoder(a) : a;\n    b = b != null ? encoder(b) : b;\n\n    if (isSimple(a) && isSimple(b)) {\n      // if possible generate simple signal expression\n      a = a ? a.signal || vegaUtil.stringValue(a.value) : null;\n      b = b ? b.signal || vegaUtil.stringValue(b.value) : null;\n      return {\n        signal: `${test} ? (${a}) : (${b})`\n      };\n    } else {\n      // otherwise generate rule set\n      return [vegaUtil.extend({\n        test\n      }, a)].concat(b || []);\n    }\n  };\n\n  const isSimple = enc => enc == null || Object.keys(enc).length === 1;\n\n  const ifExpr = (test, a, b) => ({\n    signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n  });\n\n  const ifOrient = ($orient, t, b, l, r) => ({\n    signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\n  });\n\n  const toExpr = v => isSignal(v) ? v.signal : v == null ? null : vegaUtil.stringValue(v);\n\n  const mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\n    signal: `(${sign.signal}) * ${value}`\n  } : {\n    value: sign * value\n  };\n  const patch = (value, base) => {\n    const s = value.signal;\n    return s && s.endsWith('(null)') ? {\n      signal: s.slice(0, -6) + base.signal\n    } : value;\n  };\n\n  function fallback(prop, config, axisConfig, style) {\n    let styleProp;\n\n    if (config && vegaUtil.hasOwnProperty(config, prop)) {\n      return config[prop];\n    } else if (vegaUtil.hasOwnProperty(axisConfig, prop)) {\n      return axisConfig[prop];\n    } else if (prop.startsWith('title')) {\n      switch (prop) {\n        case 'titleColor':\n          styleProp = 'fill';\n          break;\n\n        case 'titleFont':\n        case 'titleFontSize':\n        case 'titleFontWeight':\n          styleProp = prop[5].toLowerCase() + prop.slice(6);\n      }\n\n      return style[GuideTitleStyle][styleProp];\n    } else if (prop.startsWith('label')) {\n      switch (prop) {\n        case 'labelColor':\n          styleProp = 'fill';\n          break;\n\n        case 'labelFont':\n        case 'labelFontSize':\n          styleProp = prop[5].toLowerCase() + prop.slice(6);\n      }\n\n      return style[GuideLabelStyle][styleProp];\n    }\n\n    return null;\n  }\n\n  function keys(objects) {\n    const map = {};\n\n    for (const obj of objects) {\n      if (!obj) continue;\n\n      for (const key in obj) map[key] = 1;\n    }\n\n    return Object.keys(map);\n  }\n\n  function axisConfig (spec, scope) {\n    var config = scope.config,\n        style = config.style,\n        axis = config.axis,\n        band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n        orient = spec.orient,\n        xy,\n        or,\n        key;\n\n    if (isSignal(orient)) {\n      const xyKeys = keys([config.axisX, config.axisY]),\n            orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\n      xy = {};\n\n      for (key of xyKeys) {\n        xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\n      }\n\n      or = {};\n\n      for (key of orientKeys) {\n        or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\n      }\n    } else {\n      xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\n      or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n    }\n\n    const result = xy || or || band ? vegaUtil.extend({}, axis, xy, or, band) : axis;\n    return result;\n  }\n\n  function axisDomain (spec, config, userEncode, dataRef) {\n    const _ = lookup(spec, config),\n          orient = spec.orient;\n\n    let enter, update;\n    const encode = {\n      enter: enter = {\n        opacity: zero\n      },\n      update: update = {\n        opacity: one\n      },\n      exit: {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      stroke: _('domainColor'),\n      strokeCap: _('domainCap'),\n      strokeDash: _('domainDash'),\n      strokeDashOffset: _('domainDashOffset'),\n      strokeWidth: _('domainWidth'),\n      strokeOpacity: _('domainOpacity')\n    });\n    const pos0 = position(spec, 0);\n    const pos1 = position(spec, 1);\n    enter.x = update.x = ifX(orient, pos0, zero);\n    enter.x2 = update.x2 = ifX(orient, pos1);\n    enter.y = update.y = ifY(orient, pos0, zero);\n    enter.y2 = update.y2 = ifY(orient, pos1);\n    return guideMark({\n      type: RuleMark,\n      role: AxisDomainRole,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function position(spec, pos) {\n    return {\n      scale: spec.scale,\n      range: pos\n    };\n  }\n\n  function axisGrid (spec, config, userEncode, dataRef, band) {\n    const _ = lookup(spec, config),\n          orient = spec.orient,\n          vscale = spec.gridScale,\n          sign = getSign(orient, 1, -1),\n          offset = offsetValue(spec.offset, sign);\n\n    let enter, exit, update;\n    const encode = {\n      enter: enter = {\n        opacity: zero\n      },\n      update: update = {\n        opacity: one\n      },\n      exit: exit = {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      stroke: _('gridColor'),\n      strokeCap: _('gridCap'),\n      strokeDash: _('gridDash'),\n      strokeDashOffset: _('gridDashOffset'),\n      strokeOpacity: _('gridOpacity'),\n      strokeWidth: _('gridWidth')\n    });\n    const tickPos = {\n      scale: spec.scale,\n      field: Value,\n      band: band.band,\n      extra: band.extra,\n      offset: band.offset,\n      round: _('tickRound')\n    };\n    const sz = ifX(orient, {\n      signal: 'height'\n    }, {\n      signal: 'width'\n    });\n    const gridStart = vscale ? {\n      scale: vscale,\n      range: 0,\n      mult: sign,\n      offset: offset\n    } : {\n      value: 0,\n      offset: offset\n    };\n    const gridEnd = vscale ? {\n      scale: vscale,\n      range: 1,\n      mult: sign,\n      offset: offset\n    } : vegaUtil.extend(sz, {\n      mult: sign,\n      offset: offset\n    });\n    enter.x = update.x = ifX(orient, tickPos, gridStart);\n    enter.y = update.y = ifY(orient, tickPos, gridStart);\n    enter.x2 = update.x2 = ifY(orient, gridEnd);\n    enter.y2 = update.y2 = ifX(orient, gridEnd);\n    exit.x = ifX(orient, tickPos);\n    exit.y = ifY(orient, tickPos);\n    return guideMark({\n      type: RuleMark,\n      role: AxisGridRole,\n      key: Value,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function offsetValue(offset, sign) {\n    if (sign === 1) ; else if (!vegaUtil.isObject(offset)) {\n      offset = isSignal(sign) ? {\n        signal: `(${sign.signal}) * (${offset || 0})`\n      } : sign * (offset || 0);\n    } else {\n      let entry = offset = vegaUtil.extend({}, offset);\n\n      while (entry.mult != null) {\n        if (!vegaUtil.isObject(entry.mult)) {\n          entry.mult = isSignal(sign) // no offset if sign === 1\n          ? {\n            signal: `(${entry.mult}) * (${sign.signal})`\n          } : entry.mult * sign;\n          return offset;\n        } else {\n          entry = entry.mult = vegaUtil.extend({}, entry.mult);\n        }\n      }\n\n      entry.mult = sign;\n    }\n\n    return offset;\n  }\n\n  function axisTicks (spec, config, userEncode, dataRef, size, band) {\n    const _ = lookup(spec, config),\n          orient = spec.orient,\n          sign = getSign(orient, -1, 1);\n\n    let enter, exit, update;\n    const encode = {\n      enter: enter = {\n        opacity: zero\n      },\n      update: update = {\n        opacity: one\n      },\n      exit: exit = {\n        opacity: zero\n      }\n    };\n    addEncoders(encode, {\n      stroke: _('tickColor'),\n      strokeCap: _('tickCap'),\n      strokeDash: _('tickDash'),\n      strokeDashOffset: _('tickDashOffset'),\n      strokeOpacity: _('tickOpacity'),\n      strokeWidth: _('tickWidth')\n    });\n    const tickSize = encoder(size);\n    tickSize.mult = sign;\n    const tickPos = {\n      scale: spec.scale,\n      field: Value,\n      band: band.band,\n      extra: band.extra,\n      offset: band.offset,\n      round: _('tickRound')\n    };\n    update.y = enter.y = ifX(orient, zero, tickPos);\n    update.y2 = enter.y2 = ifX(orient, tickSize);\n    exit.x = ifX(orient, tickPos);\n    update.x = enter.x = ifY(orient, zero, tickPos);\n    update.x2 = enter.x2 = ifY(orient, tickSize);\n    exit.y = ifY(orient, tickPos);\n    return guideMark({\n      type: RuleMark,\n      role: AxisTickRole,\n      key: Value,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function flushExpr(scale, threshold, a, b, c) {\n    return {\n      signal: 'flush(range(\"' + scale + '\"), ' + 'scale(\"' + scale + '\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\n    };\n  }\n\n  function axisLabels (spec, config, userEncode, dataRef, size, band) {\n    const _ = lookup(spec, config),\n          orient = spec.orient,\n          scale = spec.scale,\n          sign = getSign(orient, -1, 1),\n          flush = deref(_('labelFlush')),\n          flushOffset = deref(_('labelFlushOffset')),\n          labelAlign = _('labelAlign'),\n          labelBaseline = _('labelBaseline');\n\n    let flushOn = flush === 0 || !!flush,\n        update;\n    const tickSize = encoder(size);\n    tickSize.mult = sign;\n    tickSize.offset = encoder(_('labelPadding') || 0);\n    tickSize.offset.mult = sign;\n    const tickPos = {\n      scale: scale,\n      field: Value,\n      band: 0.5,\n      offset: extendOffset(band.offset, _('labelOffset'))\n    };\n    const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"') : {\n      value: 'center'\n    }, ifRight(orient, 'left', 'right'));\n    const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"') : {\n      value: 'middle'\n    });\n    const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n    flushOn = flushOn && flushOffset;\n    const enter = {\n      opacity: zero,\n      x: ifX(orient, tickPos, tickSize),\n      y: ifY(orient, tickPos, tickSize)\n    };\n    const encode = {\n      enter: enter,\n      update: update = {\n        opacity: one,\n        text: {\n          field: Label\n        },\n        x: enter.x,\n        y: enter.y,\n        align,\n        baseline\n      },\n      exit: {\n        opacity: zero,\n        x: enter.x,\n        y: enter.y\n      }\n    };\n    addEncoders(encode, {\n      dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n      dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n    });\n    addEncoders(encode, {\n      angle: _('labelAngle'),\n      fill: _('labelColor'),\n      fillOpacity: _('labelOpacity'),\n      font: _('labelFont'),\n      fontSize: _('labelFontSize'),\n      fontWeight: _('labelFontWeight'),\n      fontStyle: _('labelFontStyle'),\n      limit: _('labelLimit'),\n      lineHeight: _('labelLineHeight')\n    }, {\n      align: labelAlign,\n      baseline: labelBaseline\n    });\n\n    const bound = _('labelBound');\n\n    let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\n\n\n    overlap = overlap || bound ? {\n      separation: _('labelSeparation'),\n      method: overlap,\n      order: 'datum.index',\n      bound: bound ? {\n        scale,\n        orient,\n        tolerance: bound\n      } : null\n    } : undefined;\n\n    if (update.align !== align) {\n      update.align = patch(update.align, align);\n    }\n\n    if (update.baseline !== baseline) {\n      update.baseline = patch(update.baseline, baseline);\n    }\n\n    return guideMark({\n      type: TextMark,\n      role: AxisLabelRole,\n      style: GuideLabelStyle,\n      key: Value,\n      from: dataRef,\n      encode,\n      overlap\n    }, userEncode);\n  }\n\n  function axisTitle (spec, config, userEncode, dataRef) {\n    const _ = lookup(spec, config),\n          orient = spec.orient,\n          sign = getSign(orient, -1, 1);\n\n    let enter, update;\n    const encode = {\n      enter: enter = {\n        opacity: zero,\n        anchor: encoder(_('titleAnchor', null)),\n        align: {\n          signal: alignExpr\n        }\n      },\n      update: update = vegaUtil.extend({}, enter, {\n        opacity: one,\n        text: encoder(spec.title)\n      }),\n      exit: {\n        opacity: zero\n      }\n    };\n    const titlePos = {\n      signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n    };\n    update.x = ifX(orient, titlePos);\n    update.y = ifY(orient, titlePos);\n    enter.angle = ifX(orient, zero, mult(sign, 90));\n    enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\n      value: Bottom\n    });\n    update.angle = enter.angle;\n    update.baseline = enter.baseline;\n    addEncoders(encode, {\n      fill: _('titleColor'),\n      fillOpacity: _('titleOpacity'),\n      font: _('titleFont'),\n      fontSize: _('titleFontSize'),\n      fontStyle: _('titleFontStyle'),\n      fontWeight: _('titleFontWeight'),\n      limit: _('titleLimit'),\n      lineHeight: _('titleLineHeight')\n    }, {\n      // require update\n      align: _('titleAlign'),\n      angle: _('titleAngle'),\n      baseline: _('titleBaseline')\n    });\n    autoLayout(_, orient, encode, userEncode);\n    encode.update.align = patch(encode.update.align, enter.align);\n    encode.update.angle = patch(encode.update.angle, enter.angle);\n    encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n    return guideMark({\n      type: TextMark,\n      role: AxisTitleRole,\n      style: GuideTitleStyle,\n      from: dataRef,\n      encode\n    }, userEncode);\n  }\n\n  function autoLayout(_, orient, encode, userEncode) {\n    const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\n\n    const autoY = auto(_('titleX'), 'x'),\n          autoX = auto(_('titleY'), 'y');\n    encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\n  }\n\n  function parseAxis (spec, scope) {\n    const config = axisConfig(spec, scope),\n          encode = spec.encode || {},\n          axisEncode = encode.axis || {},\n          name = axisEncode.name || undefined,\n          interactive = axisEncode.interactive,\n          style = axisEncode.style,\n          _ = lookup(spec, config),\n          band = tickBand(_); // single-element data source for axis group\n\n\n    const datum = {\n      scale: spec.scale,\n      ticks: !!_('ticks'),\n      labels: !!_('labels'),\n      grid: !!_('grid'),\n      domain: !!_('domain'),\n      title: spec.title != null\n    };\n    const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\n\n    const ticksRef = ref(scope.add(AxisTicks({\n      scale: scope.scaleRef(spec.scale),\n      extra: scope.property(band.extra),\n      count: scope.objectProperty(spec.tickCount),\n      values: scope.objectProperty(spec.values),\n      minstep: scope.property(spec.tickMinStep),\n      formatType: scope.property(spec.formatType),\n      formatSpecifier: scope.property(spec.format)\n    }))); // generate axis marks\n\n    const children = [];\n    let size; // include axis gridlines if requested\n\n    if (datum.grid) {\n      children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n    } // include axis ticks if requested\n\n\n    if (datum.ticks) {\n      size = _('tickSize');\n      children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n    } // include axis labels if requested\n\n\n    if (datum.labels) {\n      size = datum.ticks ? size : 0;\n      children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n    } // include axis domain path if requested\n\n\n    if (datum.domain) {\n      children.push(axisDomain(spec, config, encode.domain, dataRef));\n    } // include axis title if defined\n\n\n    if (datum.title) {\n      children.push(axisTitle(spec, config, encode.title, dataRef));\n    } // parse axis specification\n\n\n    return parseMark(guideGroup({\n      role: AxisRole,\n      from: dataRef,\n      encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n      marks: children,\n      aria: _('aria'),\n      description: _('description'),\n      zindex: _('zindex'),\n      name,\n      interactive,\n      style\n    }), scope);\n  }\n\n  function buildAxisEncode(_, spec) {\n    const encode = {\n      enter: {},\n      update: {}\n    };\n    addEncoders(encode, {\n      orient: _('orient'),\n      offset: _('offset') || 0,\n      position: value(spec.position, 0),\n      titlePadding: _('titlePadding'),\n      minExtent: _('minExtent'),\n      maxExtent: _('maxExtent'),\n      range: {\n        signal: `abs(span(range(\"${spec.scale}\")))`\n      },\n      translate: _('translate'),\n      // accessibility support\n      format: spec.format,\n      formatType: spec.formatType\n    });\n    return encode;\n  }\n\n  function parseScope (spec, scope, preprocessed) {\n    const signals = vegaUtil.array(spec.signals),\n          scales = vegaUtil.array(spec.scales); // parse signal definitions, if not already preprocessed\n\n    if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\n\n    vegaUtil.array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\n\n    scales.forEach(_ => initScale(_, scope)); // parse data sources\n\n    vegaUtil.array(spec.data).forEach(_ => parseData$1(_, scope)); // parse scale definitions\n\n    scales.forEach(_ => parseScale(_, scope)); // parse signal updates\n\n    (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\n\n    vegaUtil.array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\n\n    vegaUtil.array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\n\n    vegaUtil.array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\n\n    if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\n\n    scope.parseLambdas();\n    return scope;\n  }\n\n  const rootEncode = spec => extendEncode({\n    enter: {\n      x: {\n        value: 0\n      },\n      y: {\n        value: 0\n      }\n    },\n    update: {\n      width: {\n        signal: 'width'\n      },\n      height: {\n        signal: 'height'\n      }\n    }\n  }, spec);\n\n  function parseView(spec, scope) {\n    const config = scope.config; // add scenegraph root\n\n    const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\n\n    const signals = collectSignals(spec, config);\n    signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\n\n    scope.description = spec.description || config.description;\n    scope.eventConfig = config.events;\n    scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n    scope.locale = config.locale; // store root group item\n\n    const input = scope.add(Collect()); // encode root group item\n\n    const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\n      pulse: ref(input)\n    }))); // perform view layout\n\n    const parent = scope.add(ViewLayout({\n      layout: scope.objectProperty(spec.layout),\n      legends: scope.legends,\n      autosize: scope.signalRef('autosize'),\n      mark: root,\n      pulse: ref(encode)\n    }));\n    scope.operators.pop(); // parse remainder of specification\n\n    scope.pushState(ref(encode), ref(parent), null);\n    parseScope(spec, scope, signals);\n    scope.operators.push(parent); // bound / render / sieve root item\n\n    let op = scope.add(Bound({\n      mark: root,\n      pulse: ref(parent)\n    }));\n    op = scope.add(Render({\n      pulse: ref(op)\n    }));\n    op = scope.add(Sieve({\n      pulse: ref(op)\n    })); // track metadata for root item\n\n    scope.addData('root', new DataScope(scope, input, input, op));\n    return scope;\n  }\n\n  function signalObject(name, value) {\n    return value && value.signal ? {\n      name,\n      update: value.signal\n    } : {\n      name,\n      value\n    };\n  }\n  /**\n   * Collect top-level signals, merging values as needed. Signals\n   * defined in the config signals arrays are added only if that\n   * signal is not explicitly defined in the specification.\n   * Built-in signals (autosize, background, padding, width, height)\n   * receive special treatment. They are initialized using the\n   * top-level spec property, or, if undefined in the spec, using\n   * the corresponding top-level config property. If this property\n   * is a signal reference object, the signal expression maps to the\n   * signal 'update' property. If the spec's top-level signal array\n   * contains an entry that matches a built-in signal, that entry\n   * will be merged with the built-in specification, potentially\n   * overwriting existing 'value' or 'update' properties.\n   */\n\n\n  function collectSignals(spec, config) {\n    const _ = name => value(spec[name], config[name]),\n          signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\n          pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n          map = {}; // add spec signal array\n\n\n    vegaUtil.array(spec.signals).forEach(s => {\n      if (vegaUtil.hasOwnProperty(pre, s.name)) {\n        // merge if built-in signal\n        s = vegaUtil.extend(pre[s.name], s);\n      } else {\n        // otherwise add to signal list\n        signals.push(s);\n      }\n\n      map[s.name] = s;\n    }); // add config signal array\n\n    vegaUtil.array(config.signals).forEach(s => {\n      if (!vegaUtil.hasOwnProperty(map, s.name) && !vegaUtil.hasOwnProperty(pre, s.name)) {\n        // add to signal list if not already defined\n        signals.push(s);\n      }\n    });\n    return signals;\n  }\n\n  function Scope$1(config, options) {\n    this.config = config || {};\n    this.options = options || {};\n    this.bindings = [];\n    this.field = {};\n    this.signals = {};\n    this.lambdas = {};\n    this.scales = {};\n    this.events = {};\n    this.data = {};\n    this.streams = [];\n    this.updates = [];\n    this.operators = [];\n    this.eventConfig = null;\n    this.locale = null;\n    this._id = 0;\n    this._subid = 0;\n    this._nextsub = [0];\n    this._parent = [];\n    this._encode = [];\n    this._lookup = [];\n    this._markpath = [];\n  }\n\n  function Subscope(scope) {\n    this.config = scope.config;\n    this.options = scope.options;\n    this.legends = scope.legends;\n    this.field = Object.create(scope.field);\n    this.signals = Object.create(scope.signals);\n    this.lambdas = Object.create(scope.lambdas);\n    this.scales = Object.create(scope.scales);\n    this.events = Object.create(scope.events);\n    this.data = Object.create(scope.data);\n    this.streams = [];\n    this.updates = [];\n    this.operators = [];\n    this._id = 0;\n    this._subid = ++scope._nextsub[0];\n    this._nextsub = scope._nextsub;\n    this._parent = scope._parent.slice();\n    this._encode = scope._encode.slice();\n    this._lookup = scope._lookup.slice();\n    this._markpath = scope._markpath;\n  }\n\n  Scope$1.prototype = Subscope.prototype = {\n    parse(spec) {\n      return parseScope(spec, this);\n    },\n\n    fork() {\n      return new Subscope(this);\n    },\n\n    isSubscope() {\n      return this._subid > 0;\n    },\n\n    toRuntime() {\n      this.finish();\n      return {\n        description: this.description,\n        operators: this.operators,\n        streams: this.streams,\n        updates: this.updates,\n        bindings: this.bindings,\n        eventConfig: this.eventConfig,\n        locale: this.locale\n      };\n    },\n\n    id() {\n      return (this._subid ? this._subid + ':' : 0) + this._id++;\n    },\n\n    add(op) {\n      this.operators.push(op);\n      op.id = this.id(); // if pre-registration references exist, resolve them now\n\n      if (op.refs) {\n        op.refs.forEach(ref => {\n          ref.$ref = op.id;\n        });\n        op.refs = null;\n      }\n\n      return op;\n    },\n\n    proxy(op) {\n      const vref = op instanceof Entry ? ref(op) : op;\n      return this.add(Proxy({\n        value: vref\n      }));\n    },\n\n    addStream(stream) {\n      this.streams.push(stream);\n      stream.id = this.id();\n      return stream;\n    },\n\n    addUpdate(update) {\n      this.updates.push(update);\n      return update;\n    },\n\n    // Apply metadata\n    finish() {\n      let name, ds; // annotate root\n\n      if (this.root) this.root.root = true; // annotate signals\n\n      for (name in this.signals) {\n        this.signals[name].signal = name;\n      } // annotate scales\n\n\n      for (name in this.scales) {\n        this.scales[name].scale = name;\n      } // annotate data sets\n\n\n      function annotate(op, name, type) {\n        let data, list;\n\n        if (op) {\n          data = op.data || (op.data = {});\n          list = data[name] || (data[name] = []);\n          list.push(type);\n        }\n      }\n\n      for (name in this.data) {\n        ds = this.data[name];\n        annotate(ds.input, name, 'input');\n        annotate(ds.output, name, 'output');\n        annotate(ds.values, name, 'values');\n\n        for (const field in ds.index) {\n          annotate(ds.index[field], name, 'index:' + field);\n        }\n      }\n\n      return this;\n    },\n\n    // ----\n    pushState(encode, parent, lookup) {\n      this._encode.push(ref(this.add(Sieve({\n        pulse: encode\n      }))));\n\n      this._parent.push(parent);\n\n      this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n\n      this._markpath.push(-1);\n    },\n\n    popState() {\n      this._encode.pop();\n\n      this._parent.pop();\n\n      this._lookup.pop();\n\n      this._markpath.pop();\n    },\n\n    parent() {\n      return vegaUtil.peek(this._parent);\n    },\n\n    encode() {\n      return vegaUtil.peek(this._encode);\n    },\n\n    lookup() {\n      return vegaUtil.peek(this._lookup);\n    },\n\n    markpath() {\n      const p = this._markpath;\n      return ++p[p.length - 1];\n    },\n\n    // ----\n    fieldRef(field, name) {\n      if (vegaUtil.isString(field)) return fieldRef(field, name);\n\n      if (!field.signal) {\n        vegaUtil.error('Unsupported field reference: ' + vegaUtil.stringValue(field));\n      }\n\n      const s = field.signal;\n      let f = this.field[s];\n\n      if (!f) {\n        const params = {\n          name: this.signalRef(s)\n        };\n        if (name) params.as = name;\n        this.field[s] = f = ref(this.add(Field(params)));\n      }\n\n      return f;\n    },\n\n    compareRef(cmp) {\n      let signal = false;\n\n      const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr(_) ? (signal = true, this.exprRef(_.expr)) : _;\n\n      const fields = vegaUtil.array(cmp.field).map(check),\n            orders = vegaUtil.array(cmp.order).map(check);\n      return signal ? ref(this.add(Compare({\n        fields: fields,\n        orders: orders\n      }))) : compareRef(fields, orders);\n    },\n\n    keyRef(fields, flat) {\n      let signal = false;\n\n      const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\n\n      const sig = this.signals;\n      fields = vegaUtil.array(fields).map(check);\n      return signal ? ref(this.add(Key({\n        fields: fields,\n        flat: flat\n      }))) : keyRef(fields, flat);\n    },\n\n    sortRef(sort) {\n      if (!sort) return sort; // including id ensures stable sorting\n\n      const a = aggrField(sort.op, sort.field),\n            o = sort.order || Ascending;\n      return o.signal ? ref(this.add(Compare({\n        fields: a,\n        orders: this.signalRef(o.signal)\n      }))) : compareRef(a, o);\n    },\n\n    // ----\n    event(source, type) {\n      const key = source + ':' + type;\n\n      if (!this.events[key]) {\n        const id = this.id();\n        this.streams.push({\n          id: id,\n          source: source,\n          type: type\n        });\n        this.events[key] = id;\n      }\n\n      return this.events[key];\n    },\n\n    // ----\n    hasOwnSignal(name) {\n      return vegaUtil.hasOwnProperty(this.signals, name);\n    },\n\n    addSignal(name, value) {\n      if (this.hasOwnSignal(name)) {\n        vegaUtil.error('Duplicate signal name: ' + vegaUtil.stringValue(name));\n      }\n\n      const op = value instanceof Entry ? value : this.add(operator(value));\n      return this.signals[name] = op;\n    },\n\n    getSignal(name) {\n      if (!this.signals[name]) {\n        vegaUtil.error('Unrecognized signal name: ' + vegaUtil.stringValue(name));\n      }\n\n      return this.signals[name];\n    },\n\n    signalRef(s) {\n      if (this.signals[s]) {\n        return ref(this.signals[s]);\n      } else if (!vegaUtil.hasOwnProperty(this.lambdas, s)) {\n        this.lambdas[s] = this.add(operator(null));\n      }\n\n      return ref(this.lambdas[s]);\n    },\n\n    parseLambdas() {\n      const code = Object.keys(this.lambdas);\n\n      for (let i = 0, n = code.length; i < n; ++i) {\n        const s = code[i],\n              e = vegaFunctions.parseExpression(s, this),\n              op = this.lambdas[s];\n        op.params = e.$params;\n        op.update = e.$expr;\n      }\n    },\n\n    property(spec) {\n      return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n    },\n\n    objectProperty(spec) {\n      return !spec || !vegaUtil.isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\n    },\n\n    exprRef(code, name) {\n      const params = {\n        expr: vegaFunctions.parseExpression(code, this)\n      };\n      if (name) params.expr.$name = name;\n      return ref(this.add(Expression(params)));\n    },\n\n    addBinding(name, bind) {\n      if (!this.bindings) {\n        vegaUtil.error('Nested signals do not support binding: ' + vegaUtil.stringValue(name));\n      }\n\n      this.bindings.push(vegaUtil.extend({\n        signal: name\n      }, bind));\n    },\n\n    // ----\n    addScaleProj(name, transform) {\n      if (vegaUtil.hasOwnProperty(this.scales, name)) {\n        vegaUtil.error('Duplicate scale or projection name: ' + vegaUtil.stringValue(name));\n      }\n\n      this.scales[name] = this.add(transform);\n    },\n\n    addScale(name, params) {\n      this.addScaleProj(name, Scale(params));\n    },\n\n    addProjection(name, params) {\n      this.addScaleProj(name, Projection(params));\n    },\n\n    getScale(name) {\n      if (!this.scales[name]) {\n        vegaUtil.error('Unrecognized scale name: ' + vegaUtil.stringValue(name));\n      }\n\n      return this.scales[name];\n    },\n\n    scaleRef(name) {\n      return ref(this.getScale(name));\n    },\n\n    scaleType(name) {\n      return this.getScale(name).params.type;\n    },\n\n    projectionRef(name) {\n      return this.scaleRef(name);\n    },\n\n    projectionType(name) {\n      return this.scaleType(name);\n    },\n\n    // ----\n    addData(name, dataScope) {\n      if (vegaUtil.hasOwnProperty(this.data, name)) {\n        vegaUtil.error('Duplicate data set name: ' + vegaUtil.stringValue(name));\n      }\n\n      return this.data[name] = dataScope;\n    },\n\n    getData(name) {\n      if (!this.data[name]) {\n        vegaUtil.error('Undefined data set name: ' + vegaUtil.stringValue(name));\n      }\n\n      return this.data[name];\n    },\n\n    addDataPipeline(name, entries) {\n      if (vegaUtil.hasOwnProperty(this.data, name)) {\n        vegaUtil.error('Duplicate data set name: ' + vegaUtil.stringValue(name));\n      }\n\n      return this.addData(name, DataScope.fromEntries(this, entries));\n    }\n\n  };\n\n  function propertyLambda(spec) {\n    return (vegaUtil.isArray(spec) ? arrayLambda : objectLambda)(spec);\n  }\n\n  function arrayLambda(array) {\n    const n = array.length;\n    let code = '[';\n\n    for (let i = 0; i < n; ++i) {\n      const value = array[i];\n      code += (i > 0 ? ',' : '') + (vegaUtil.isObject(value) ? value.signal || propertyLambda(value) : vegaUtil.stringValue(value));\n    }\n\n    return code + ']';\n  }\n\n  function objectLambda(obj) {\n    let code = '{',\n        i = 0,\n        key,\n        value;\n\n    for (key in obj) {\n      value = obj[key];\n      code += (++i > 1 ? ',' : '') + vegaUtil.stringValue(key) + ':' + (vegaUtil.isObject(value) ? value.signal || propertyLambda(value) : vegaUtil.stringValue(value));\n    }\n\n    return code + '}';\n  }\n\n  /**\n   * Standard configuration defaults for Vega specification parsing.\n   * Users can provide their own (sub-)set of these default values\n   * by passing in a config object to the top-level parse method.\n   */\n  function defaults () {\n    const defaultFont = 'sans-serif',\n          defaultSymbolSize = 30,\n          defaultStrokeWidth = 2,\n          defaultColor = '#4c78a8',\n          black = '#000',\n          gray = '#888',\n          lightGray = '#ddd';\n    return {\n      // default visualization description\n      description: 'Vega visualization',\n      // default padding around visualization\n      padding: 0,\n      // default for automatic sizing; options: 'none', 'pad', 'fit'\n      // or provide an object (e.g., {'type': 'pad', 'resize': true})\n      autosize: 'pad',\n      // default view background color\n      // covers the entire view component\n      background: null,\n      // default event handling configuration\n      // preventDefault for view-sourced event types except 'wheel'\n      events: {\n        defaults: {\n          allow: ['wheel']\n        }\n      },\n      // defaults for top-level group marks\n      // accepts mark properties (fill, stroke, etc)\n      // covers the data rectangle within group width/height\n      group: null,\n      // defaults for basic mark types\n      // each subset accepts mark properties (fill, stroke, etc)\n      mark: null,\n      arc: {\n        fill: defaultColor\n      },\n      area: {\n        fill: defaultColor\n      },\n      image: null,\n      line: {\n        stroke: defaultColor,\n        strokeWidth: defaultStrokeWidth\n      },\n      path: {\n        stroke: defaultColor\n      },\n      rect: {\n        fill: defaultColor\n      },\n      rule: {\n        stroke: black\n      },\n      shape: {\n        stroke: defaultColor\n      },\n      symbol: {\n        fill: defaultColor,\n        size: 64\n      },\n      text: {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11\n      },\n      trail: {\n        fill: defaultColor,\n        size: defaultStrokeWidth\n      },\n      // style definitions\n      style: {\n        // axis & legend labels\n        'guide-label': {\n          fill: black,\n          font: defaultFont,\n          fontSize: 10\n        },\n        // axis & legend titles\n        'guide-title': {\n          fill: black,\n          font: defaultFont,\n          fontSize: 11,\n          fontWeight: 'bold'\n        },\n        // headers, including chart title\n        'group-title': {\n          fill: black,\n          font: defaultFont,\n          fontSize: 13,\n          fontWeight: 'bold'\n        },\n        // chart subtitle\n        'group-subtitle': {\n          fill: black,\n          font: defaultFont,\n          fontSize: 12\n        },\n        // defaults for styled point marks in Vega-Lite\n        point: {\n          size: defaultSymbolSize,\n          strokeWidth: defaultStrokeWidth,\n          shape: 'circle'\n        },\n        circle: {\n          size: defaultSymbolSize,\n          strokeWidth: defaultStrokeWidth\n        },\n        square: {\n          size: defaultSymbolSize,\n          strokeWidth: defaultStrokeWidth,\n          shape: 'square'\n        },\n        // defaults for styled group marks in Vega-Lite\n        cell: {\n          fill: 'transparent',\n          stroke: lightGray\n        }\n      },\n      // defaults for title\n      title: {\n        orient: 'top',\n        anchor: 'middle',\n        offset: 4,\n        subtitlePadding: 3\n      },\n      // defaults for axes\n      axis: {\n        minExtent: 0,\n        maxExtent: 200,\n        bandPosition: 0.5,\n        domain: true,\n        domainWidth: 1,\n        domainColor: gray,\n        grid: false,\n        gridWidth: 1,\n        gridColor: lightGray,\n        labels: true,\n        labelAngle: 0,\n        labelLimit: 180,\n        labelOffset: 0,\n        labelPadding: 2,\n        ticks: true,\n        tickColor: gray,\n        tickOffset: 0,\n        tickRound: true,\n        tickSize: 5,\n        tickWidth: 1,\n        titlePadding: 4\n      },\n      // correction for centering bias\n      axisBand: {\n        tickOffset: -0.5\n      },\n      // defaults for cartographic projection\n      projection: {\n        type: 'mercator'\n      },\n      // defaults for legends\n      legend: {\n        orient: 'right',\n        padding: 0,\n        gridAlign: 'each',\n        columnPadding: 10,\n        rowPadding: 2,\n        symbolDirection: 'vertical',\n        gradientDirection: 'vertical',\n        gradientLength: 200,\n        gradientThickness: 16,\n        gradientStrokeColor: lightGray,\n        gradientStrokeWidth: 0,\n        gradientLabelOffset: 2,\n        labelAlign: 'left',\n        labelBaseline: 'middle',\n        labelLimit: 160,\n        labelOffset: 4,\n        labelOverlap: true,\n        symbolLimit: 30,\n        symbolType: 'circle',\n        symbolSize: 100,\n        symbolOffset: 0,\n        symbolStrokeWidth: 1.5,\n        symbolBaseFillColor: 'transparent',\n        symbolBaseStrokeColor: gray,\n        titleLimit: 180,\n        titleOrient: 'top',\n        titlePadding: 5,\n        layout: {\n          offset: 18,\n          direction: 'horizontal',\n          left: {\n            direction: 'vertical'\n          },\n          right: {\n            direction: 'vertical'\n          }\n        }\n      },\n      // defaults for scale ranges\n      range: {\n        category: {\n          scheme: 'tableau10'\n        },\n        ordinal: {\n          scheme: 'blues'\n        },\n        heatmap: {\n          scheme: 'yellowgreenblue'\n        },\n        ramp: {\n          scheme: 'blues'\n        },\n        diverging: {\n          scheme: 'blueorange',\n          extent: [1, 0]\n        },\n        symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\n      }\n    };\n  }\n\n  function parse$1 (spec, config, options) {\n    if (!vegaUtil.isObject(spec)) {\n      vegaUtil.error('Input Vega specification must be an object.');\n    }\n\n    config = vegaUtil.mergeConfig(defaults(), config, spec.config);\n    return parseView(spec, new Scope$1(config, options)).toRuntime();\n  }\n\n  exports.AxisDomainRole = AxisDomainRole;\n  exports.AxisGridRole = AxisGridRole;\n  exports.AxisLabelRole = AxisLabelRole;\n  exports.AxisRole = AxisRole;\n  exports.AxisTickRole = AxisTickRole;\n  exports.AxisTitleRole = AxisTitleRole;\n  exports.DataScope = DataScope;\n  exports.FrameRole = FrameRole;\n  exports.LegendEntryRole = LegendEntryRole;\n  exports.LegendLabelRole = LegendLabelRole;\n  exports.LegendRole = LegendRole;\n  exports.LegendSymbolRole = LegendSymbolRole;\n  exports.LegendTitleRole = LegendTitleRole;\n  exports.MarkRole = MarkRole;\n  exports.Scope = Scope$1;\n  exports.ScopeRole = ScopeRole;\n  exports.config = defaults;\n  exports.parse = parse$1;\n  exports.signal = parseSignal;\n  exports.signalUpdates = parseSignalUpdates;\n  exports.stream = parseStream;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$module$node_modules$vega_event_selector$build$vega_event_selector","~$module$node_modules$vega_scale$build$vega_scale","~$shadow.js","~$module$node_modules$vega_util$build$vega_util","~$module$node_modules$vega_functions$build$vega_functions"]],"~:properties",["^5",["tickColor","trail","stop","interactive","role","schemeExtent","range","consume","symbolOffset","separation","stream","$field","values","$value","min","bindings","boundScale","lambdas","width","rule","domainWidth","rangeStep","url","debounce","right","expr","$compare","align","columnPadding","top","output","symbolStrokeWidth","interpolate","legends","gradient","index","config","subflow","ordinal","aria","offset","translate","strokeDashOffset","$output","$params","$ingest","params","labelOverlap","columns","minstep","strokeCap","prototype","height","labelBaseline","LegendSymbolRole","initonly","vgrad","shape","scale","grid","area","_parent","_anchor","_lookup","group","titlePadding","clip","_nextsub","image","symbolBaseStrokeColor","autosize","MarkRole","updates","signalUpdates","fontStyle","AxisTickRole","fontWeight","$name","ops","method","cornerRadius","lineHeight","key","parent","gridWidth","tickOffset","gradientStrokeWidth","x","overlap","AxisDomainRole","__esModule","dx","force","labelOffset","flat","max","path","gridColor","LegendRole","padding","$fields","strokeDash","axis","cell","orient","groupby","id","datum","$expr","legend","gradientLabelOffset","root","vega","band","count","update","counts","derive","gradientStrokeColor","mult","marks","markdef","sort","async","agg","anchor","operators","allow","signal","angle","heatmap","position","pulse","name","$order","locale","limit","scales","stroke","style","$ref","_markpath","labels","signals","value","interval","center","eventConfig","aggregate","auto","AxisLabelRole","symbolSize","encoders","context","direction","AxisGridRole","field","start","axisBand","labelAlign","text","$context","fill","$format","fontSize","strokeWidth","layout","scope","minExtent","formatSpecifier","ScopeRole","tolerance","boundOrient","domain","strokeOpacity","baseline","symbolLimit","gradientDirection","filter","symbol","interpolateGamma","bandPosition","metadata","diverging","font","tickSize","gradientLength","arc","events","input","line","titleLimit","LegendLabelRole","ticks","order","column","mod","title","$flat","square","labelLimit","source","symbolDirection","type","row","projection","extents","y","schemeCount","between","LegendEntryRole","AxisRole","$key","x2","ref","fields","_id","from","marktype","target","AxisTitleRole","dy","isVertical","_encode","bound","parse","exit","y2","gradientThickness","extra","$subflow","entryColumns","fillOpacity","noBound","bottom","bins","rect","symbolType","clean","category","facet","size","subtitlePadding","titleOrient","formatType","frame","tickWidth","DataScope","maxExtent","mark","options","fromEntries","$request","circle","round","LegendTitleRole","react","tickRound","ast","rowPadding","data","background","merge","throttle","boundTolerance","labelAngle","extent","encode","enter","scheme","$encode","as","code","opacity","groups","Scope","defaults","gridAlign","FrameRole","point","_subid","zindex","left","description","streams","orders","labelPadding","ramp","symbolBaseFillColor","test","nice","format","domainColor","channels","step","refs"]],"~:compiled-at",1621210442510,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_parser$build$vega_parser.js\",\n\"lineCount\":149,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-parser/build/vega-parser.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_parser$build$vega_parser\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-functions'), require('vega-event-selector'), require('vega-scale'), require('vega-dataflow')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-functions', 'vega-event-selector', 'vega-scale', 'vega-dataflow'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega, global.vega, global.vega, global.vega));\\n}(this, (function (exports, vegaUtil, vegaFunctions, vegaEventSelector, vegaScale, vegaDataflow) { 'use strict';\\n\\n  function parseAutosize (spec) {\\n    return vegaUtil.isObject(spec) ? spec : {\\n      type: spec || 'pad'\\n    };\\n  }\\n\\n  const number = _ => +_ || 0;\\n\\n  const paddingObject = _ => ({\\n    top: _,\\n    bottom: _,\\n    left: _,\\n    right: _\\n  });\\n\\n  function parsePadding (spec) {\\n    return !vegaUtil.isObject(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {\\n      top: number(spec.top),\\n      bottom: number(spec.bottom),\\n      left: number(spec.left),\\n      right: number(spec.right)\\n    };\\n  }\\n\\n  const encoder = _ => vegaUtil.isObject(_) && !vegaUtil.isArray(_) ? vegaUtil.extend({}, _) : {\\n    value: _\\n  };\\n  function addEncode(object, name, value, set) {\\n    if (value != null) {\\n      const isEncoder = vegaUtil.isObject(value) && !vegaUtil.isArray(value) || vegaUtil.isArray(value) && value.length && vegaUtil.isObject(value[0]); // Always assign signal to update, even if the signal is from the enter block\\n\\n      if (isEncoder) {\\n        object.update[name] = value;\\n      } else {\\n        object[set || 'enter'][name] = {\\n          value: value\\n        };\\n      }\\n\\n      return 1;\\n    } else {\\n      return 0;\\n    }\\n  }\\n  function addEncoders(object, enter, update) {\\n    for (const name in enter) {\\n      addEncode(object, name, enter[name]);\\n    }\\n\\n    for (const name in update) {\\n      addEncode(object, name, update[name], 'update');\\n    }\\n  }\\n  function extendEncode(encode, extra, skip) {\\n    for (const name in extra) {\\n      if (skip && vegaUtil.hasOwnProperty(skip, name)) continue;\\n      encode[name] = vegaUtil.extend(encode[name] || {}, extra[name]);\\n    }\\n\\n    return encode;\\n  }\\n  function has(key, encode) {\\n    return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);\\n  }\\n\\n  const MarkRole = 'mark';\\n  const FrameRole = 'frame';\\n  const ScopeRole = 'scope';\\n  const AxisRole = 'axis';\\n  const AxisDomainRole = 'axis-domain';\\n  const AxisGridRole = 'axis-grid';\\n  const AxisLabelRole = 'axis-label';\\n  const AxisTickRole = 'axis-tick';\\n  const AxisTitleRole = 'axis-title';\\n  const LegendRole = 'legend';\\n  const LegendBandRole = 'legend-band';\\n  const LegendEntryRole = 'legend-entry';\\n  const LegendGradientRole = 'legend-gradient';\\n  const LegendLabelRole = 'legend-label';\\n  const LegendSymbolRole = 'legend-symbol';\\n  const LegendTitleRole = 'legend-title';\\n  const TitleRole = 'title';\\n  const TitleTextRole = 'title-text';\\n  const TitleSubtitleRole = 'title-subtitle';\\n\\n  function applyDefaults (encode, type, role, style, config) {\\n    const defaults = {},\\n          enter = {};\\n    let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)\\n\\n    key = 'lineBreak';\\n\\n    if (type === 'text' && config[key] != null && !has(key, encode)) {\\n      applyDefault(defaults, key, config[key]);\\n    } // ignore legend and axis roles\\n\\n\\n    if (role == 'legend' || String(role).startsWith('axis')) {\\n      role = null;\\n    } // resolve mark config\\n\\n\\n    props = role === FrameRole ? config.group : role === MarkRole ? vegaUtil.extend({}, config.mark, config[type]) : null;\\n\\n    for (key in props) {\\n      // do not apply defaults if relevant fields are defined\\n      skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));\\n      if (!skip) applyDefault(defaults, key, props[key]);\\n    } // resolve styles, apply with increasing precedence\\n\\n\\n    vegaUtil.array(style).forEach(name => {\\n      const props = config.style && config.style[name];\\n\\n      for (const key in props) {\\n        if (!has(key, encode)) {\\n          applyDefault(defaults, key, props[key]);\\n        }\\n      }\\n    });\\n    encode = vegaUtil.extend({}, encode); // defensive copy\\n\\n    for (key in defaults) {\\n      props = defaults[key];\\n\\n      if (props.signal) {\\n        (update = update || {})[key] = props;\\n      } else {\\n        enter[key] = props;\\n      }\\n    }\\n\\n    encode.enter = vegaUtil.extend(enter, encode.enter);\\n    if (update) encode.update = vegaUtil.extend(update, encode.update);\\n    return encode;\\n  }\\n\\n  function applyDefault(defaults, key, value) {\\n    defaults[key] = value && value.signal ? {\\n      signal: value.signal\\n    } : {\\n      value: value\\n    };\\n  }\\n\\n  const scaleRef = scale => vegaUtil.isString(scale) ? vegaUtil.stringValue(scale) : scale.signal ? `(${scale.signal})` : field(scale);\\n\\n  function entry(enc) {\\n    if (enc.gradient != null) {\\n      return gradient(enc);\\n    }\\n\\n    let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? vegaUtil.stringValue(enc.value) : undefined;\\n\\n    if (enc.scale != null) {\\n      value = scale(enc, value);\\n    }\\n\\n    if (value === undefined) {\\n      value = null;\\n    }\\n\\n    if (enc.exponent != null) {\\n      value = `pow(${value},${property(enc.exponent)})`;\\n    }\\n\\n    if (enc.mult != null) {\\n      value += `*${property(enc.mult)}`;\\n    }\\n\\n    if (enc.offset != null) {\\n      value += `+${property(enc.offset)}`;\\n    }\\n\\n    if (enc.round) {\\n      value = `round(${value})`;\\n    }\\n\\n    return value;\\n  }\\n\\n  const _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry).join(',')})+'')`;\\n\\n  function color(enc) {\\n    return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;\\n  }\\n\\n  function gradient(enc) {\\n    // map undefined to null; expression lang does not allow undefined\\n    const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : vegaUtil.stringValue(_)); // trim null inputs from the end\\n\\n    while (args.length && vegaUtil.peek(args) == null) args.pop();\\n\\n    args.unshift(scaleRef(enc.gradient));\\n    return `gradient(${args.join(',')})`;\\n  }\\n\\n  function property(property) {\\n    return vegaUtil.isObject(property) ? '(' + entry(property) + ')' : property;\\n  }\\n\\n  function field(ref) {\\n    return resolveField(vegaUtil.isObject(ref) ? ref : {\\n      datum: ref\\n    });\\n  }\\n\\n  function resolveField(ref) {\\n    let object, level, field;\\n\\n    if (ref.signal) {\\n      object = 'datum';\\n      field = ref.signal;\\n    } else if (ref.group || ref.parent) {\\n      level = Math.max(1, ref.level || 1);\\n      object = 'item';\\n\\n      while (level-- > 0) {\\n        object += '.mark.group';\\n      }\\n\\n      if (ref.parent) {\\n        field = ref.parent;\\n        object += '.datum';\\n      } else {\\n        field = ref.group;\\n      }\\n    } else if (ref.datum) {\\n      object = 'datum';\\n      field = ref.datum;\\n    } else {\\n      vegaUtil.error('Invalid field reference: ' + vegaUtil.stringValue(ref));\\n    }\\n\\n    if (!ref.signal) {\\n      field = vegaUtil.isString(field) ? vegaUtil.splitAccessPath(field).map(vegaUtil.stringValue).join('][') : resolveField(field);\\n    }\\n\\n    return object + '[' + field + ']';\\n  }\\n\\n  function scale(enc, value) {\\n    const scale = scaleRef(enc.scale);\\n\\n    if (enc.range != null) {\\n      // pull value from scale range\\n      value = `lerp(_range(${scale}), ${+enc.range})`;\\n    } else {\\n      // run value through scale and/or pull scale bandwidth\\n      if (value !== undefined) value = `_scale(${scale}, ${value})`;\\n\\n      if (enc.band) {\\n        value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));\\n\\n        if (enc.extra) {\\n          // include logic to handle extraneous elements\\n          value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\\n        }\\n      }\\n\\n      if (value == null) value = '0';\\n    }\\n\\n    return value;\\n  }\\n\\n  function rule (enc) {\\n    let code = '';\\n    enc.forEach(rule => {\\n      const value = entry(rule);\\n      code += rule.test ? `(${rule.test})?${value}:` : value;\\n    }); // if no else clause, terminate with null (#1366)\\n\\n    if (vegaUtil.peek(code) === ':') {\\n      code += 'null';\\n    }\\n\\n    return code;\\n  }\\n\\n  function parseEncode (encode, type, role, style, scope, params) {\\n    const enc = {};\\n    params = params || {};\\n    params.encoders = {\\n      $encode: enc\\n    };\\n    encode = applyDefaults(encode, type, role, style, scope.config);\\n\\n    for (const key in encode) {\\n      enc[key] = parseBlock(encode[key], type, params, scope);\\n    }\\n\\n    return params;\\n  }\\n\\n  function parseBlock(block, marktype, params, scope) {\\n    const channels = {},\\n          fields = {};\\n\\n    for (const name in block) {\\n      if (block[name] != null) {\\n        // skip any null entries\\n        channels[name] = parse(expr(block[name]), scope, params, fields);\\n      }\\n    }\\n\\n    return {\\n      $expr: {\\n        marktype,\\n        channels\\n      },\\n      $fields: Object.keys(fields),\\n      $output: Object.keys(block)\\n    };\\n  }\\n\\n  function expr(enc) {\\n    return vegaUtil.isArray(enc) ? rule(enc) : entry(enc);\\n  }\\n\\n  function parse(code, scope, params, fields) {\\n    const expr = vegaFunctions.parseExpression(code, scope);\\n    expr.$fields.forEach(name => fields[name] = 1);\\n    vegaUtil.extend(params, expr.$params);\\n    return expr.$expr;\\n  }\\n\\n  const OUTER = 'outer',\\n        OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\\n\\n  function outerError(prefix, name) {\\n    vegaUtil.error(prefix + ' for \\\"outer\\\" push: ' + vegaUtil.stringValue(name));\\n  }\\n\\n  function parseSignal (signal, scope) {\\n    const name = signal.name;\\n\\n    if (signal.push === OUTER) {\\n      // signal must already be defined, raise error if not\\n      if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition\\n\\n      OUTER_INVALID.forEach(prop => {\\n        if (signal[prop] !== undefined) outerError('Invalid property ', prop);\\n      });\\n    } else {\\n      // define a new signal in the current scope\\n      const op = scope.addSignal(name, signal.value);\\n      if (signal.react === false) op.react = false;\\n      if (signal.bind) scope.addBinding(name, signal.bind);\\n    }\\n  }\\n\\n  function Entry(type, value, params, parent) {\\n    this.id = -1;\\n    this.type = type;\\n    this.value = value;\\n    this.params = params;\\n    if (parent) this.parent = parent;\\n  }\\n  function entry$1(type, value, params, parent) {\\n    return new Entry(type, value, params, parent);\\n  }\\n  function operator(value, params) {\\n    return entry$1('operator', value, params);\\n  } // -----\\n\\n  function ref(op) {\\n    const ref = {\\n      $ref: op.id\\n    }; // if operator not yet registered, cache ref to resolve later\\n\\n    if (op.id < 0) (op.refs = op.refs || []).push(ref);\\n    return ref;\\n  }\\n  function fieldRef(field, name) {\\n    return name ? {\\n      $field: field,\\n      $name: name\\n    } : {\\n      $field: field\\n    };\\n  }\\n  const keyFieldRef = fieldRef('key');\\n  function compareRef(fields, orders) {\\n    return {\\n      $compare: fields,\\n      $order: orders\\n    };\\n  }\\n  function keyRef(fields, flat) {\\n    const ref = {\\n      $key: fields\\n    };\\n    if (flat) ref.$flat = true;\\n    return ref;\\n  } // -----\\n\\n  const Ascending = 'ascending';\\n  const Descending = 'descending';\\n  function sortKey(sort) {\\n    return !vegaUtil.isObject(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);\\n  }\\n  function aggrField(op, field) {\\n    return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');\\n  } // -----\\n\\n  const Scope = 'scope';\\n  const View = 'view';\\n  function isSignal(_) {\\n    return _ && _.signal;\\n  }\\n  function isExpr(_) {\\n    return _ && _.expr;\\n  }\\n  function hasSignal(_) {\\n    if (isSignal(_)) return true;\\n    if (vegaUtil.isObject(_)) for (const key in _) {\\n      if (hasSignal(_[key])) return true;\\n    }\\n    return false;\\n  }\\n  function value(specValue, defaultValue) {\\n    return specValue != null ? specValue : defaultValue;\\n  }\\n  function deref(v) {\\n    return v && v.signal || v;\\n  }\\n\\n  const Timer = 'timer';\\n  function parseStream(stream, scope) {\\n    const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : vegaUtil.error('Invalid stream specification: ' + vegaUtil.stringValue(stream));\\n    return method(stream, scope);\\n  }\\n\\n  function eventSource(source) {\\n    return source === Scope ? View : source || View;\\n  }\\n\\n  function mergeStream(stream, scope) {\\n    const list = stream.merge.map(s => parseStream(s, scope)),\\n          entry = streamParameters({\\n      merge: list\\n    }, stream, scope);\\n    return scope.addStream(entry).id;\\n  }\\n\\n  function nestedStream(stream, scope) {\\n    const id = parseStream(stream.stream, scope),\\n          entry = streamParameters({\\n      stream: id\\n    }, stream, scope);\\n    return scope.addStream(entry).id;\\n  }\\n\\n  function eventStream(stream, scope) {\\n    let id;\\n\\n    if (stream.type === Timer) {\\n      id = scope.event(Timer, stream.throttle);\\n      stream = {\\n        between: stream.between,\\n        filter: stream.filter\\n      };\\n    } else {\\n      id = scope.event(eventSource(stream.source), stream.type);\\n    }\\n\\n    const entry = streamParameters({\\n      stream: id\\n    }, stream, scope);\\n    return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;\\n  }\\n\\n  function streamParameters(entry, stream, scope) {\\n    let param = stream.between;\\n\\n    if (param) {\\n      if (param.length !== 2) {\\n        vegaUtil.error('Stream \\\"between\\\" parameter must have 2 entries: ' + vegaUtil.stringValue(stream));\\n      }\\n\\n      entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];\\n    }\\n\\n    param = stream.filter ? [].concat(stream.filter) : [];\\n\\n    if (stream.marktype || stream.markname || stream.markrole) {\\n      // add filter for mark type, name and/or role\\n      param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\\n    }\\n\\n    if (stream.source === Scope) {\\n      // add filter to limit events from sub-scope only\\n      param.push('inScope(event.item)');\\n    }\\n\\n    if (param.length) {\\n      entry.filter = vegaFunctions.parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\\n    }\\n\\n    if ((param = stream.throttle) != null) {\\n      entry.throttle = +param;\\n    }\\n\\n    if ((param = stream.debounce) != null) {\\n      entry.debounce = +param;\\n    }\\n\\n    if (stream.consume) {\\n      entry.consume = true;\\n    }\\n\\n    return entry;\\n  }\\n\\n  function filterMark(type, name, role) {\\n    const item = 'event.item';\\n    return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\\\'' + type + '\\\\'' : '') + (role ? '&&' + item + '.mark.role===\\\\'' + role + '\\\\'' : '') + (name ? '&&' + item + '.mark.name===\\\\'' + name + '\\\\'' : '');\\n  }\\n\\n  const OP_VALUE_EXPR = {\\n    code: '_.$value',\\n    ast: {\\n      type: 'Identifier',\\n      value: 'value'\\n    }\\n  };\\n  function parseUpdate (spec, scope, target) {\\n    const encode = spec.encode,\\n          entry = {\\n      target: target\\n    };\\n    let events = spec.events,\\n        update = spec.update,\\n        sources = [];\\n\\n    if (!events) {\\n      vegaUtil.error('Signal update missing events specification.');\\n    } // interpret as an event selector string\\n\\n\\n    if (vegaUtil.isString(events)) {\\n      events = vegaEventSelector.selector(events, scope.isSubscope() ? Scope : View);\\n    } // separate event streams from signal updates\\n\\n\\n    events = vegaUtil.array(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners\\n\\n    if (sources.length > 1) {\\n      sources = [mergeSources(sources)];\\n    } // merge event streams, include as source\\n\\n\\n    if (events.length) {\\n      sources.push(events.length > 1 ? {\\n        merge: events\\n      } : events[0]);\\n    }\\n\\n    if (encode != null) {\\n      if (update) vegaUtil.error('Signal encode and update are mutually exclusive.');\\n      update = 'encode(item(),' + vegaUtil.stringValue(encode) + ')';\\n    } // resolve update value\\n\\n\\n    entry.update = vegaUtil.isString(update) ? vegaFunctions.parseExpression(update, scope) : update.expr != null ? vegaFunctions.parseExpression(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {\\n      $expr: OP_VALUE_EXPR,\\n      $params: {\\n        $value: scope.signalRef(update.signal)\\n      }\\n    } : vegaUtil.error('Invalid signal update specification.');\\n\\n    if (spec.force) {\\n      entry.options = {\\n        force: true\\n      };\\n    }\\n\\n    sources.forEach(source => scope.addUpdate(vegaUtil.extend(streamSource(source, scope), entry)));\\n  }\\n\\n  function streamSource(stream, scope) {\\n    return {\\n      source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)\\n    };\\n  }\\n\\n  function mergeSources(sources) {\\n    return {\\n      signal: '[' + sources.map(s => s.scale ? 'scale(\\\"' + s.scale + '\\\")' : s.signal) + ']'\\n    };\\n  }\\n\\n  function parseSignalUpdates (signal, scope) {\\n    const op = scope.getSignal(signal.name);\\n    let expr = signal.update;\\n\\n    if (signal.init) {\\n      if (expr) {\\n        vegaUtil.error('Signals can not include both init and update expressions.');\\n      } else {\\n        expr = signal.init;\\n        op.initonly = true;\\n      }\\n    }\\n\\n    if (expr) {\\n      expr = vegaFunctions.parseExpression(expr, scope);\\n      op.update = expr.$expr;\\n      op.params = expr.$params;\\n    }\\n\\n    if (signal.on) {\\n      signal.on.forEach(_ => parseUpdate(_, scope, op.id));\\n    }\\n  }\\n\\n  const transform = name => (params, value, parent) => entry$1(name, value, params || undefined, parent);\\n\\n  const Aggregate = transform('aggregate');\\n  const AxisTicks = transform('axisticks');\\n  const Bound = transform('bound');\\n  const Collect = transform('collect');\\n  const Compare = transform('compare');\\n  const DataJoin = transform('datajoin');\\n  const Encode = transform('encode');\\n  const Expression = transform('expression');\\n  const Facet = transform('facet');\\n  const Field = transform('field');\\n  const Key = transform('key');\\n  const LegendEntries = transform('legendentries');\\n  const Load = transform('load');\\n  const Mark = transform('mark');\\n  const MultiExtent = transform('multiextent');\\n  const MultiValues = transform('multivalues');\\n  const Overlap = transform('overlap');\\n  const Params = transform('params');\\n  const PreFacet = transform('prefacet');\\n  const Projection = transform('projection');\\n  const Proxy = transform('proxy');\\n  const Relay = transform('relay');\\n  const Render = transform('render');\\n  const Scale = transform('scale');\\n  const Sieve = transform('sieve');\\n  const SortItems = transform('sortitems');\\n  const ViewLayout = transform('viewlayout');\\n  const Values = transform('values');\\n\\n  let FIELD_REF_ID = 0;\\n  const MULTIDOMAIN_SORT_OPS = {\\n    min: 'min',\\n    max: 'max',\\n    count: 'sum'\\n  };\\n  function initScale(spec, scope) {\\n    const type = spec.type || 'linear';\\n\\n    if (!vegaScale.isValidScaleType(type)) {\\n      vegaUtil.error('Unrecognized scale type: ' + vegaUtil.stringValue(type));\\n    }\\n\\n    scope.addScale(spec.name, {\\n      type,\\n      domain: undefined\\n    });\\n  }\\n  function parseScale(spec, scope) {\\n    const params = scope.getScale(spec.name).params;\\n    let key;\\n    params.domain = parseScaleDomain(spec.domain, spec, scope);\\n\\n    if (spec.range != null) {\\n      params.range = parseScaleRange(spec, scope, params);\\n    }\\n\\n    if (spec.interpolate != null) {\\n      parseScaleInterpolate(spec.interpolate, params);\\n    }\\n\\n    if (spec.nice != null) {\\n      params.nice = parseScaleNice(spec.nice);\\n    }\\n\\n    if (spec.bins != null) {\\n      params.bins = parseScaleBins(spec.bins, scope);\\n    }\\n\\n    for (key in spec) {\\n      if (vegaUtil.hasOwnProperty(params, key) || key === 'name') continue;\\n      params[key] = parseLiteral(spec[key], scope);\\n    }\\n  }\\n\\n  function parseLiteral(v, scope) {\\n    return !vegaUtil.isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : vegaUtil.error('Unsupported object: ' + vegaUtil.stringValue(v));\\n  }\\n\\n  function parseArray(v, scope) {\\n    return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));\\n  }\\n\\n  function dataLookupError(name) {\\n    vegaUtil.error('Can not find data set: ' + vegaUtil.stringValue(name));\\n  } // -- SCALE DOMAIN ----\\n\\n\\n  function parseScaleDomain(domain, spec, scope) {\\n    if (!domain) {\\n      if (spec.domainMin != null || spec.domainMax != null) {\\n        vegaUtil.error('No scale domain defined for domainMin/domainMax to override.');\\n      }\\n\\n      return; // default domain\\n    }\\n\\n    return domain.signal ? scope.signalRef(domain.signal) : (vegaUtil.isArray(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);\\n  }\\n\\n  function explicitDomain(domain, spec, scope) {\\n    return domain.map(v => parseLiteral(v, scope));\\n  }\\n\\n  function singularDomain(domain, spec, scope) {\\n    const data = scope.getData(domain.data);\\n    if (!data) dataLookupError(domain.data);\\n    return vegaScale.isDiscrete(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : vegaScale.isQuantile(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);\\n  }\\n\\n  function multipleDomain(domain, spec, scope) {\\n    const data = domain.data,\\n          fields = domain.fields.reduce((dom, d) => {\\n      d = vegaUtil.isString(d) ? {\\n        data: data,\\n        field: d\\n      } : vegaUtil.isArray(d) || d.signal ? fieldRef$1(d, scope) : d;\\n      dom.push(d);\\n      return dom;\\n    }, []);\\n    return (vegaScale.isDiscrete(spec.type) ? ordinalMultipleDomain : vegaScale.isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);\\n  }\\n\\n  function fieldRef$1(data, scope) {\\n    const name = '_:vega:_' + FIELD_REF_ID++,\\n          coll = Collect({});\\n\\n    if (vegaUtil.isArray(data)) {\\n      coll.value = {\\n        $ingest: data\\n      };\\n    } else if (data.signal) {\\n      const code = 'setdata(' + vegaUtil.stringValue(name) + ',' + data.signal + ')';\\n      coll.params.input = scope.signalRef(code);\\n    }\\n\\n    scope.addDataPipeline(name, [coll, Sieve({})]);\\n    return {\\n      data: name,\\n      field: 'data'\\n    };\\n  }\\n\\n  function ordinalMultipleDomain(domain, scope, fields) {\\n    const sort = parseSort(domain.sort, true);\\n    let a, v; // get value counts for each domain field\\n\\n    const counts = fields.map(f => {\\n      const data = scope.getData(f.data);\\n      if (!data) dataLookupError(f.data);\\n      return data.countsRef(scope, f.field, sort);\\n    }); // aggregate the results from each domain field\\n\\n    const p = {\\n      groupby: keyFieldRef,\\n      pulse: counts\\n    };\\n\\n    if (sort) {\\n      a = sort.op || 'count';\\n      v = sort.field ? aggrField(a, sort.field) : 'count';\\n      p.ops = [MULTIDOMAIN_SORT_OPS[a]];\\n      p.fields = [scope.fieldRef(v)];\\n      p.as = [v];\\n    }\\n\\n    a = scope.add(Aggregate(p)); // collect aggregate output\\n\\n    const c = scope.add(Collect({\\n      pulse: ref(a)\\n    })); // extract values for combined domain\\n\\n    v = scope.add(Values({\\n      field: keyFieldRef,\\n      sort: scope.sortRef(sort),\\n      pulse: ref(c)\\n    }));\\n    return ref(v);\\n  }\\n\\n  function parseSort(sort, multidomain) {\\n    if (sort) {\\n      if (!sort.field && !sort.op) {\\n        if (vegaUtil.isObject(sort)) sort.field = 'key';else sort = {\\n          field: 'key'\\n        };\\n      } else if (!sort.field && sort.op !== 'count') {\\n        vegaUtil.error('No field provided for sort aggregate op: ' + sort.op);\\n      } else if (multidomain && sort.field) {\\n        if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\\n          vegaUtil.error('Multiple domain scales can not be sorted using ' + sort.op);\\n        }\\n      }\\n    }\\n\\n    return sort;\\n  }\\n\\n  function quantileMultipleDomain(domain, scope, fields) {\\n    // get value arrays for each domain field\\n    const values = fields.map(f => {\\n      const data = scope.getData(f.data);\\n      if (!data) dataLookupError(f.data);\\n      return data.domainRef(scope, f.field);\\n    }); // combine value arrays\\n\\n    return ref(scope.add(MultiValues({\\n      values: values\\n    })));\\n  }\\n\\n  function numericMultipleDomain(domain, scope, fields) {\\n    // get extents for each domain field\\n    const extents = fields.map(f => {\\n      const data = scope.getData(f.data);\\n      if (!data) dataLookupError(f.data);\\n      return data.extentRef(scope, f.field);\\n    }); // combine extents\\n\\n    return ref(scope.add(MultiExtent({\\n      extents: extents\\n    })));\\n  } // -- SCALE BINS -----\\n\\n\\n  function parseScaleBins(v, scope) {\\n    return v.signal || vegaUtil.isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);\\n  } // -- SCALE NICE -----\\n\\n\\n  function parseScaleNice(nice) {\\n    return vegaUtil.isObject(nice) ? {\\n      interval: parseLiteral(nice.interval),\\n      step: parseLiteral(nice.step)\\n    } : parseLiteral(nice);\\n  } // -- SCALE INTERPOLATION -----\\n\\n\\n  function parseScaleInterpolate(interpolate, params) {\\n    params.interpolate = parseLiteral(interpolate.type || interpolate);\\n\\n    if (interpolate.gamma != null) {\\n      params.interpolateGamma = parseLiteral(interpolate.gamma);\\n    }\\n  } // -- SCALE RANGE -----\\n\\n\\n  function parseScaleRange(spec, scope, params) {\\n    const config = scope.config.range;\\n    let range = spec.range;\\n\\n    if (range.signal) {\\n      return scope.signalRef(range.signal);\\n    } else if (vegaUtil.isString(range)) {\\n      if (config && vegaUtil.hasOwnProperty(config, range)) {\\n        spec = vegaUtil.extend({}, spec, {\\n          range: config[range]\\n        });\\n        return parseScaleRange(spec, scope, params);\\n      } else if (range === 'width') {\\n        range = [0, {\\n          signal: 'width'\\n        }];\\n      } else if (range === 'height') {\\n        range = vegaScale.isDiscrete(spec.type) ? [0, {\\n          signal: 'height'\\n        }] : [{\\n          signal: 'height'\\n        }, 0];\\n      } else {\\n        vegaUtil.error('Unrecognized scale range value: ' + vegaUtil.stringValue(range));\\n      }\\n    } else if (range.scheme) {\\n      params.scheme = vegaUtil.isArray(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);\\n      if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\\n      if (range.count) params.schemeCount = parseLiteral(range.count, scope);\\n      return;\\n    } else if (range.step) {\\n      params.rangeStep = parseLiteral(range.step, scope);\\n      return;\\n    } else if (vegaScale.isDiscrete(spec.type) && !vegaUtil.isArray(range)) {\\n      return parseScaleDomain(range, spec, scope);\\n    } else if (!vegaUtil.isArray(range)) {\\n      vegaUtil.error('Unsupported range type: ' + vegaUtil.stringValue(range));\\n    }\\n\\n    return range.map(v => (vegaUtil.isArray(v) ? parseArray : parseLiteral)(v, scope));\\n  }\\n\\n  function parseProjection (proj, scope) {\\n    const config = scope.config.projection || {},\\n          params = {};\\n\\n    for (const name in proj) {\\n      if (name === 'name') continue;\\n      params[name] = parseParameter(proj[name], name, scope);\\n    } // apply projection defaults from config\\n\\n\\n    for (const name in config) {\\n      if (params[name] == null) {\\n        params[name] = parseParameter(config[name], name, scope);\\n      }\\n    }\\n\\n    scope.addProjection(proj.name, params);\\n  }\\n\\n  function parseParameter(_, name, scope) {\\n    return vegaUtil.isArray(_) ? _.map(_ => parseParameter(_, name, scope)) : !vegaUtil.isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : vegaUtil.error('Unsupported parameter object: ' + vegaUtil.stringValue(_));\\n  }\\n\\n  const Top = 'top';\\n  const Left = 'left';\\n  const Right = 'right';\\n  const Bottom = 'bottom';\\n  const Center = 'center';\\n  const Vertical = 'vertical';\\n  const Start = 'start';\\n  const Middle = 'middle';\\n  const End = 'end';\\n  const Index = 'index';\\n  const Label = 'label';\\n  const Offset = 'offset';\\n  const Perc = 'perc';\\n  const Perc2 = 'perc2';\\n  const Value = 'value';\\n  const GuideLabelStyle = 'guide-label';\\n  const GuideTitleStyle = 'guide-title';\\n  const GroupTitleStyle = 'group-title';\\n  const GroupSubtitleStyle = 'group-subtitle';\\n  const Symbols = 'symbol';\\n  const Gradient = 'gradient';\\n  const Discrete = 'discrete';\\n  const Size = 'size';\\n  const Shape = 'shape';\\n  const Fill = 'fill';\\n  const Stroke = 'stroke';\\n  const StrokeWidth = 'strokeWidth';\\n  const StrokeDash = 'strokeDash';\\n  const Opacity = 'opacity'; // Encoding channels supported by legends\\n  // In priority order of 'canonical' scale\\n\\n  const LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];\\n  const Skip = {\\n    name: 1,\\n    style: 1,\\n    interactive: 1\\n  };\\n  const zero = {\\n    value: 0\\n  };\\n  const one = {\\n    value: 1\\n  };\\n\\n  const GroupMark = 'group';\\n  const RectMark = 'rect';\\n  const RuleMark = 'rule';\\n  const SymbolMark = 'symbol';\\n  const TextMark = 'text';\\n\\n  function guideGroup (mark) {\\n    mark.type = GroupMark;\\n    mark.interactive = mark.interactive || false;\\n    return mark;\\n  }\\n\\n  function lookup(spec, config) {\\n    const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\\n\\n    _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));\\n\\n    _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);\\n\\n    _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);\\n\\n    _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));\\n\\n    return _;\\n  }\\n  function getEncoding(name, encode) {\\n    const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);\\n    return v && v.signal ? v : v ? v.value : null;\\n  }\\n  function getStyle(name, scope, style) {\\n    const s = scope.config.style[style];\\n    return s && s[name];\\n  }\\n  function anchorExpr(s, e, m) {\\n    return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\\n  }\\n  const alignExpr = anchorExpr(vegaUtil.stringValue(Left), vegaUtil.stringValue(Right), vegaUtil.stringValue(Center));\\n  function tickBand(_) {\\n    const v = _('tickBand');\\n\\n    let offset = _('tickOffset'),\\n        band,\\n        extra;\\n\\n    if (!v) {\\n      // if no tick band entry, fall back on other properties\\n      band = _('bandPosition');\\n      extra = _('tickExtra');\\n    } else if (v.signal) {\\n      // if signal, augment code to interpret values\\n      band = {\\n        signal: `(${v.signal}) === 'extent' ? 1 : 0.5`\\n      };\\n      extra = {\\n        signal: `(${v.signal}) === 'extent'`\\n      };\\n\\n      if (!vegaUtil.isObject(offset)) {\\n        offset = {\\n          signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`\\n        };\\n      }\\n    } else if (v === 'extent') {\\n      // if constant, simply set values\\n      band = 1;\\n      extra = true;\\n      offset = 0;\\n    } else {\\n      band = 0.5;\\n      extra = false;\\n    }\\n\\n    return {\\n      extra,\\n      band,\\n      offset\\n    };\\n  }\\n  function extendOffset(value, offset) {\\n    return !offset ? value : !value ? offset : !vegaUtil.isObject(value) ? {\\n      value,\\n      offset\\n    } : Object.assign({}, value, {\\n      offset: extendOffset(value.offset, offset)\\n    });\\n  }\\n\\n  function guideMark (mark, extras) {\\n    if (extras) {\\n      mark.name = extras.name;\\n      mark.style = extras.style || mark.style;\\n      mark.interactive = !!extras.interactive;\\n      mark.encode = extendEncode(mark.encode, extras, Skip);\\n    } else {\\n      mark.interactive = false;\\n    }\\n\\n    return mark;\\n  }\\n\\n  function legendGradient (spec, scale, config, userEncode) {\\n    const _ = lookup(spec, config),\\n          vertical = _.isVertical(),\\n          thickness = _.gradientThickness(),\\n          length = _.gradientLength();\\n\\n    let enter, start, stop, width, height;\\n\\n    if (vertical) {\\n      start = [0, 1];\\n      stop = [0, 0];\\n      width = thickness;\\n      height = length;\\n    } else {\\n      start = [0, 0];\\n      stop = [1, 0];\\n      width = length;\\n      height = thickness;\\n    }\\n\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero,\\n        x: zero,\\n        y: zero,\\n        width: encoder(width),\\n        height: encoder(height)\\n      },\\n      update: vegaUtil.extend({}, enter, {\\n        opacity: one,\\n        fill: {\\n          gradient: scale,\\n          start: start,\\n          stop: stop\\n        }\\n      }),\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      stroke: _('gradientStrokeColor'),\\n      strokeWidth: _('gradientStrokeWidth')\\n    }, {\\n      // update\\n      opacity: _('gradientOpacity')\\n    });\\n    return guideMark({\\n      type: RectMark,\\n      role: LegendGradientRole,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config),\\n          vertical = _.isVertical(),\\n          thickness = _.gradientThickness(),\\n          length = _.gradientLength();\\n\\n    let u,\\n        v,\\n        uu,\\n        vv,\\n        adjust = '';\\n    vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\\n    const enter = {\\n      opacity: zero,\\n      fill: {\\n        scale: scale,\\n        field: Value\\n      }\\n    };\\n    enter[u] = {\\n      signal: adjust + 'datum.' + Perc,\\n      mult: length\\n    };\\n    enter[v] = zero;\\n    enter[uu] = {\\n      signal: adjust + 'datum.' + Perc2,\\n      mult: length\\n    };\\n    enter[vv] = encoder(thickness);\\n    const encode = {\\n      enter: enter,\\n      update: vegaUtil.extend({}, enter, {\\n        opacity: one\\n      }),\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      stroke: _('gradientStrokeColor'),\\n      strokeWidth: _('gradientStrokeWidth')\\n    }, {\\n      // update\\n      opacity: _('gradientOpacity')\\n    });\\n    return guideMark({\\n      type: RectMark,\\n      role: LegendBandRole,\\n      key: Value,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  const alignExpr$1 = `datum.${Perc}<=0?\\\"${Left}\\\":datum.${Perc}>=1?\\\"${Right}\\\":\\\"${Center}\\\"`,\\n        baselineExpr = `datum.${Perc}<=0?\\\"${Bottom}\\\":datum.${Perc}>=1?\\\"${Top}\\\":\\\"${Middle}\\\"`;\\n  function legendGradientLabels (spec, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config),\\n          vertical = _.isVertical(),\\n          thickness = encoder(_.gradientThickness()),\\n          length = _.gradientLength();\\n\\n    let overlap = _('labelOverlap'),\\n        enter,\\n        update,\\n        u,\\n        v,\\n        adjust = '';\\n\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero\\n      },\\n      update: update = {\\n        opacity: one,\\n        text: {\\n          field: Label\\n        }\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      fill: _('labelColor'),\\n      fillOpacity: _('labelOpacity'),\\n      font: _('labelFont'),\\n      fontSize: _('labelFontSize'),\\n      fontStyle: _('labelFontStyle'),\\n      fontWeight: _('labelFontWeight'),\\n      limit: value(spec.labelLimit, config.gradientLabelLimit)\\n    });\\n\\n    if (vertical) {\\n      enter.align = {\\n        value: 'left'\\n      };\\n      enter.baseline = update.baseline = {\\n        signal: baselineExpr\\n      };\\n      u = 'y';\\n      v = 'x';\\n      adjust = '1-';\\n    } else {\\n      enter.align = update.align = {\\n        signal: alignExpr$1\\n      };\\n      enter.baseline = {\\n        value: 'top'\\n      };\\n      u = 'x';\\n      v = 'y';\\n    }\\n\\n    enter[u] = update[u] = {\\n      signal: adjust + 'datum.' + Perc,\\n      mult: length\\n    };\\n    enter[v] = update[v] = thickness;\\n    thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\\n    overlap = overlap ? {\\n      separation: _('labelSeparation'),\\n      method: overlap,\\n      order: 'datum.' + Index\\n    } : undefined; // type, role, style, key, dataRef, encode, extras\\n\\n    return guideMark({\\n      type: TextMark,\\n      role: LegendLabelRole,\\n      style: GuideLabelStyle,\\n      key: Value,\\n      from: dataRef,\\n      encode,\\n      overlap\\n    }, userEncode);\\n  }\\n\\n  function legendSymbolGroups (spec, config, userEncode, dataRef, columns) {\\n    const _ = lookup(spec, config),\\n          entries = userEncode.entries,\\n          interactive = !!(entries && entries.interactive),\\n          name = entries ? entries.name : undefined,\\n          height = _('clipHeight'),\\n          symbolOffset = _('symbolOffset'),\\n          valueRef = {\\n      data: 'value'\\n    },\\n          xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\\n          yEncode = height ? encoder(height) : {\\n      field: Size\\n    },\\n          index = `datum.${Index}`,\\n          ncols = `max(1, ${columns})`;\\n\\n    let encode, enter, update, nrows, sort;\\n    yEncode.mult = 0.5; // -- LEGEND SYMBOLS --\\n\\n    encode = {\\n      enter: enter = {\\n        opacity: zero,\\n        x: {\\n          signal: xSignal,\\n          mult: 0.5,\\n          offset: symbolOffset\\n        },\\n        y: yEncode\\n      },\\n      update: update = {\\n        opacity: one,\\n        x: enter.x,\\n        y: enter.y\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    let baseFill = null,\\n        baseStroke = null;\\n\\n    if (!spec.fill) {\\n      baseFill = config.symbolBaseFillColor;\\n      baseStroke = config.symbolBaseStrokeColor;\\n    }\\n\\n    addEncoders(encode, {\\n      fill: _('symbolFillColor', baseFill),\\n      shape: _('symbolType'),\\n      size: _('symbolSize'),\\n      stroke: _('symbolStrokeColor', baseStroke),\\n      strokeDash: _('symbolDash'),\\n      strokeDashOffset: _('symbolDashOffset'),\\n      strokeWidth: _('symbolStrokeWidth')\\n    }, {\\n      // update\\n      opacity: _('symbolOpacity')\\n    });\\n    LegendScales.forEach(scale => {\\n      if (spec[scale]) {\\n        update[scale] = enter[scale] = {\\n          scale: spec[scale],\\n          field: Value\\n        };\\n      }\\n    });\\n    const symbols = guideMark({\\n      type: SymbolMark,\\n      role: LegendSymbolRole,\\n      key: Value,\\n      from: valueRef,\\n      clip: height ? true : undefined,\\n      encode\\n    }, userEncode.symbols); // -- LEGEND LABELS --\\n\\n    const labelOffset = encoder(symbolOffset);\\n    labelOffset.offset = _('labelOffset');\\n    encode = {\\n      enter: enter = {\\n        opacity: zero,\\n        x: {\\n          signal: xSignal,\\n          offset: labelOffset\\n        },\\n        y: yEncode\\n      },\\n      update: update = {\\n        opacity: one,\\n        text: {\\n          field: Label\\n        },\\n        x: enter.x,\\n        y: enter.y\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      align: _('labelAlign'),\\n      baseline: _('labelBaseline'),\\n      fill: _('labelColor'),\\n      fillOpacity: _('labelOpacity'),\\n      font: _('labelFont'),\\n      fontSize: _('labelFontSize'),\\n      fontStyle: _('labelFontStyle'),\\n      fontWeight: _('labelFontWeight'),\\n      limit: _('labelLimit')\\n    });\\n    const labels = guideMark({\\n      type: TextMark,\\n      role: LegendLabelRole,\\n      style: GuideLabelStyle,\\n      key: Value,\\n      from: valueRef,\\n      encode\\n    }, userEncode.labels); // -- LEGEND ENTRY GROUPS --\\n\\n    encode = {\\n      enter: {\\n        noBound: {\\n          value: !height\\n        },\\n        // ignore width/height in bounds calc\\n        width: zero,\\n        height: height ? encoder(height) : zero,\\n        opacity: zero\\n      },\\n      exit: {\\n        opacity: zero\\n      },\\n      update: update = {\\n        opacity: one,\\n        row: {\\n          signal: null\\n        },\\n        column: {\\n          signal: null\\n        }\\n      }\\n    }; // annotate and sort groups to ensure correct ordering\\n\\n    if (_.isVertical(true)) {\\n      nrows = `ceil(item.mark.items.length / ${ncols})`;\\n      update.row.signal = `${index}%${nrows}`;\\n      update.column.signal = `floor(${index} / ${nrows})`;\\n      sort = {\\n        field: ['row', index]\\n      };\\n    } else {\\n      update.row.signal = `floor(${index} / ${ncols})`;\\n      update.column.signal = `${index} % ${ncols}`;\\n      sort = {\\n        field: index\\n      };\\n    } // handle zero column case (implies infinite columns)\\n\\n\\n    update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups\\n\\n    dataRef = {\\n      facet: {\\n        data: dataRef,\\n        name: 'value',\\n        groupby: Index\\n      }\\n    };\\n    return guideGroup({\\n      role: ScopeRole,\\n      from: dataRef,\\n      encode: extendEncode(encode, entries, Skip),\\n      marks: [symbols, labels],\\n      name,\\n      interactive,\\n      sort\\n    });\\n  }\\n  function legendSymbolLayout(spec, config) {\\n    const _ = lookup(spec, config); // layout parameters for legend entries\\n\\n\\n    return {\\n      align: _('gridAlign'),\\n      columns: _.entryColumns(),\\n      center: {\\n        row: true,\\n        column: false\\n      },\\n      padding: {\\n        row: _('rowPadding'),\\n        column: _('columnPadding')\\n      }\\n    };\\n  }\\n\\n  const isL = 'item.orient === \\\"left\\\"',\\n        isR = 'item.orient === \\\"right\\\"',\\n        isLR = `(${isL} || ${isR})`,\\n        isVG = `datum.vgrad && ${isLR}`,\\n        baseline = anchorExpr('\\\"top\\\"', '\\\"bottom\\\"', '\\\"middle\\\"'),\\n        alignFlip = anchorExpr('\\\"right\\\"', '\\\"left\\\"', '\\\"center\\\"'),\\n        exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \\\"left\\\" : ${alignExpr}`,\\n        exprAnchor = `item._anchor || (${isLR} ? \\\"middle\\\" : \\\"start\\\")`,\\n        exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\\n        exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \\\"bottom\\\" : \\\"top\\\") : ${baseline}) : \\\"top\\\"`;\\n  function legendTitle (spec, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config);\\n\\n    const encode = {\\n      enter: {\\n        opacity: zero\\n      },\\n      update: {\\n        opacity: one,\\n        x: {\\n          field: {\\n            group: 'padding'\\n          }\\n        },\\n        y: {\\n          field: {\\n            group: 'padding'\\n          }\\n        }\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      orient: _('titleOrient'),\\n      _anchor: _('titleAnchor'),\\n      anchor: {\\n        signal: exprAnchor\\n      },\\n      angle: {\\n        signal: exprAngle\\n      },\\n      align: {\\n        signal: exprAlign\\n      },\\n      baseline: {\\n        signal: exprBaseline\\n      },\\n      text: spec.title,\\n      fill: _('titleColor'),\\n      fillOpacity: _('titleOpacity'),\\n      font: _('titleFont'),\\n      fontSize: _('titleFontSize'),\\n      fontStyle: _('titleFontStyle'),\\n      fontWeight: _('titleFontWeight'),\\n      limit: _('titleLimit'),\\n      lineHeight: _('titleLineHeight')\\n    }, {\\n      // require update\\n      align: _('titleAlign'),\\n      baseline: _('titleBaseline')\\n    });\\n    return guideMark({\\n      type: TextMark,\\n      role: LegendTitleRole,\\n      style: GuideTitleStyle,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function clip (clip, scope) {\\n    let expr;\\n\\n    if (vegaUtil.isObject(clip)) {\\n      if (clip.signal) {\\n        expr = clip.signal;\\n      } else if (clip.path) {\\n        expr = 'pathShape(' + param(clip.path) + ')';\\n      } else if (clip.sphere) {\\n        expr = 'geoShape(' + param(clip.sphere) + ', {type: \\\"Sphere\\\"})';\\n      }\\n    }\\n\\n    return expr ? scope.signalRef(expr) : !!clip;\\n  }\\n\\n  function param(value) {\\n    return vegaUtil.isObject(value) && value.signal ? value.signal : vegaUtil.stringValue(value);\\n  }\\n\\n  function getRole (spec) {\\n    const role = spec.role || '';\\n    return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;\\n  }\\n\\n  function definition (spec) {\\n    return {\\n      marktype: spec.type,\\n      name: spec.name || undefined,\\n      role: spec.role || getRole(spec),\\n      zindex: +spec.zindex || undefined,\\n      aria: spec.aria,\\n      description: spec.description\\n    };\\n  }\\n\\n  function interactive (spec, scope) {\\n    return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;\\n  }\\n\\n  /**\\n   * Parse a data transform specification.\\n   */\\n\\n  function parseTransform (spec, scope) {\\n    const def = vegaDataflow.definition(spec.type);\\n    if (!def) vegaUtil.error('Unrecognized transform type: ' + vegaUtil.stringValue(spec.type));\\n    const t = entry$1(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\\n    if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\\n    t.metadata = def.metadata || {};\\n    return t;\\n  }\\n  /**\\n   * Parse all parameters of a data transform.\\n   */\\n\\n  function parseParameters(def, spec, scope) {\\n    const params = {},\\n          n = def.params.length;\\n\\n    for (let i = 0; i < n; ++i) {\\n      const pdef = def.params[i];\\n      params[pdef.name] = parseParameter$1(pdef, spec, scope);\\n    }\\n\\n    return params;\\n  }\\n  /**\\n   * Parse a data transform parameter.\\n   */\\n\\n\\n  function parseParameter$1(def, spec, scope) {\\n    const type = def.type,\\n          value = spec[def.name];\\n\\n    if (type === 'index') {\\n      return parseIndexParameter(def, spec, scope);\\n    } else if (value === undefined) {\\n      if (def.required) {\\n        vegaUtil.error('Missing required ' + vegaUtil.stringValue(spec.type) + ' parameter: ' + vegaUtil.stringValue(def.name));\\n      }\\n\\n      return;\\n    } else if (type === 'param') {\\n      return parseSubParameters(def, spec, scope);\\n    } else if (type === 'projection') {\\n      return scope.projectionRef(spec[def.name]);\\n    }\\n\\n    return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);\\n  }\\n  /**\\n   * Parse a single parameter value.\\n   */\\n\\n\\n  function parameterValue(def, value, scope) {\\n    const type = def.type;\\n\\n    if (isSignal(value)) {\\n      return isExpr$1(type) ? vegaUtil.error('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);\\n    } else {\\n      const expr = def.expr || isField(type);\\n      return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef(value.field, value.as) : isExpr$1(type) ? vegaFunctions.parseExpression(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef(value) : isCompare(type) ? scope.compareRef(value) : value;\\n    }\\n  }\\n  /**\\n   * Parse parameter for accessing an index of another data set.\\n   */\\n\\n\\n  function parseIndexParameter(def, spec, scope) {\\n    if (!vegaUtil.isString(spec.from)) {\\n      vegaUtil.error('Lookup \\\"from\\\" parameter must be a string literal.');\\n    }\\n\\n    return scope.getData(spec.from).lookupRef(scope, spec.key);\\n  }\\n  /**\\n   * Parse a parameter that contains one or more sub-parameter objects.\\n   */\\n\\n\\n  function parseSubParameters(def, spec, scope) {\\n    const value = spec[def.name];\\n\\n    if (def.array) {\\n      if (!vegaUtil.isArray(value)) {\\n        // signals not allowed!\\n        vegaUtil.error('Expected an array of sub-parameters. Instead: ' + vegaUtil.stringValue(value));\\n      }\\n\\n      return value.map(v => parseSubParameter(def, v, scope));\\n    } else {\\n      return parseSubParameter(def, value, scope);\\n    }\\n  }\\n  /**\\n   * Parse a sub-parameter object.\\n   */\\n\\n\\n  function parseSubParameter(def, value, scope) {\\n    const n = def.params.length;\\n    let pdef; // loop over defs to find matching key\\n\\n    for (let i = 0; i < n; ++i) {\\n      pdef = def.params[i];\\n\\n      for (const k in pdef.key) {\\n        if (pdef.key[k] !== value[k]) {\\n          pdef = null;\\n          break;\\n        }\\n      }\\n\\n      if (pdef) break;\\n    } // raise error if matching key not found\\n\\n\\n    if (!pdef) vegaUtil.error('Unsupported parameter: ' + vegaUtil.stringValue(value)); // parse params, create Params transform, return ref\\n\\n    const params = vegaUtil.extend(parseParameters(pdef, value, scope), pdef.key);\\n    return ref(scope.add(Params(params)));\\n  } // -- Utilities -----\\n\\n\\n  const outerExpr = _ => _ && _.expr;\\n  const outerField = _ => _ && _.field;\\n  const isData = _ => _ === 'data';\\n  const isExpr$1 = _ => _ === 'expr';\\n  const isField = _ => _ === 'field';\\n  const isCompare = _ => _ === 'compare';\\n\\n  function parseData (from, group, scope) {\\n    let facet, key, op, dataRef, parent; // if no source data, generate singleton datum\\n\\n    if (!from) {\\n      dataRef = ref(scope.add(Collect(null, [{}])));\\n    } // if faceted, process facet specification\\n    else if (facet = from.facet) {\\n        if (!group) vegaUtil.error('Only group marks can be faceted.'); // use pre-faceted source data, if available\\n\\n        if (facet.field != null) {\\n          dataRef = parent = getDataRef(facet, scope);\\n        } else {\\n          // generate facet aggregates if no direct data specification\\n          if (!from.data) {\\n            op = parseTransform(vegaUtil.extend({\\n              type: 'aggregate',\\n              groupby: vegaUtil.array(facet.groupby)\\n            }, facet.aggregate), scope);\\n            op.params.key = scope.keyRef(facet.groupby);\\n            op.params.pulse = getDataRef(facet, scope);\\n            dataRef = parent = ref(scope.add(op));\\n          } else {\\n            parent = ref(scope.getData(from.data).aggregate);\\n          }\\n\\n          key = scope.keyRef(facet.groupby, true);\\n        }\\n      } // if not yet defined, get source data reference\\n\\n\\n    if (!dataRef) {\\n      dataRef = getDataRef(from, scope);\\n    }\\n\\n    return {\\n      key: key,\\n      pulse: dataRef,\\n      parent: parent\\n    };\\n  }\\n  function getDataRef(from, scope) {\\n    return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);\\n  }\\n\\n  function DataScope(scope, input, output, values, aggr) {\\n    this.scope = scope; // parent scope object\\n\\n    this.input = input; // first operator in pipeline (tuple input)\\n\\n    this.output = output; // last operator in pipeline (tuple output)\\n\\n    this.values = values; // operator for accessing tuples (but not tuple flow)\\n    // last aggregate in transform pipeline\\n\\n    this.aggregate = aggr; // lookup table of field indices\\n\\n    this.index = {};\\n  }\\n\\n  DataScope.fromEntries = function (scope, entries) {\\n    const n = entries.length,\\n          values = entries[n - 1],\\n          output = entries[n - 2];\\n    let input = entries[0],\\n        aggr = null,\\n        i = 1;\\n\\n    if (input && input.type === 'load') {\\n      input = entries[1];\\n    } // add operator entries to this scope, wire up pulse chain\\n\\n\\n    scope.add(entries[0]);\\n\\n    for (; i < n; ++i) {\\n      entries[i].params.pulse = ref(entries[i - 1]);\\n      scope.add(entries[i]);\\n      if (entries[i].type === 'aggregate') aggr = entries[i];\\n    }\\n\\n    return new DataScope(scope, input, output, values, aggr);\\n  };\\n\\n  function fieldKey(field) {\\n    return vegaUtil.isString(field) ? field : null;\\n  }\\n\\n  function addSortField(scope, p, sort) {\\n    const as = aggrField(sort.op, sort.field);\\n    let s;\\n\\n    if (p.ops) {\\n      for (let i = 0, n = p.as.length; i < n; ++i) {\\n        if (p.as[i] === as) return;\\n      }\\n    } else {\\n      p.ops = ['count'];\\n      p.fields = [null];\\n      p.as = ['count'];\\n    }\\n\\n    if (sort.op) {\\n      p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);\\n      p.fields.push(scope.fieldRef(sort.field));\\n      p.as.push(as);\\n    }\\n  }\\n\\n  function cache(scope, ds, name, optype, field, counts, index) {\\n    const cache = ds[name] || (ds[name] = {}),\\n          sort = sortKey(counts);\\n    let k = fieldKey(field),\\n        v,\\n        op;\\n\\n    if (k != null) {\\n      scope = ds.scope;\\n      k = k + (sort ? '|' + sort : '');\\n      v = cache[k];\\n    }\\n\\n    if (!v) {\\n      const params = counts ? {\\n        field: keyFieldRef,\\n        pulse: ds.countsRef(scope, field, counts)\\n      } : {\\n        field: scope.fieldRef(field),\\n        pulse: ref(ds.output)\\n      };\\n      if (sort) params.sort = scope.sortRef(counts);\\n      op = scope.add(entry$1(optype, undefined, params));\\n      if (index) ds.index[field] = op;\\n      v = ref(op);\\n      if (k != null) cache[k] = v;\\n    }\\n\\n    return v;\\n  }\\n\\n  DataScope.prototype = {\\n    countsRef(scope, field, sort) {\\n      const ds = this,\\n            cache = ds.counts || (ds.counts = {}),\\n            k = fieldKey(field);\\n      let v, a, p;\\n\\n      if (k != null) {\\n        scope = ds.scope;\\n        v = cache[k];\\n      }\\n\\n      if (!v) {\\n        p = {\\n          groupby: scope.fieldRef(field, 'key'),\\n          pulse: ref(ds.output)\\n        };\\n        if (sort && sort.field) addSortField(scope, p, sort);\\n        a = scope.add(Aggregate(p));\\n        v = scope.add(Collect({\\n          pulse: ref(a)\\n        }));\\n        v = {\\n          agg: a,\\n          ref: ref(v)\\n        };\\n        if (k != null) cache[k] = v;\\n      } else if (sort && sort.field) {\\n        addSortField(scope, v.agg.params, sort);\\n      }\\n\\n      return v.ref;\\n    },\\n\\n    tuplesRef() {\\n      return ref(this.values);\\n    },\\n\\n    extentRef(scope, field) {\\n      return cache(scope, this, 'extent', 'extent', field, false);\\n    },\\n\\n    domainRef(scope, field) {\\n      return cache(scope, this, 'domain', 'values', field, false);\\n    },\\n\\n    valuesRef(scope, field, sort) {\\n      return cache(scope, this, 'vals', 'values', field, sort || true);\\n    },\\n\\n    lookupRef(scope, field) {\\n      return cache(scope, this, 'lookup', 'tupleindex', field, false);\\n    },\\n\\n    indataRef(scope, field) {\\n      return cache(scope, this, 'indata', 'tupleindex', field, true, true);\\n    }\\n\\n  };\\n\\n  function parseFacet (spec, scope, group) {\\n    const facet = spec.from.facet,\\n          name = facet.name,\\n          data = getDataRef(facet, scope);\\n    let op;\\n\\n    if (!facet.name) {\\n      vegaUtil.error('Facet must have a name: ' + vegaUtil.stringValue(facet));\\n    }\\n\\n    if (!facet.data) {\\n      vegaUtil.error('Facet must reference a data set: ' + vegaUtil.stringValue(facet));\\n    }\\n\\n    if (facet.field) {\\n      op = scope.add(PreFacet({\\n        field: scope.fieldRef(facet.field),\\n        pulse: data\\n      }));\\n    } else if (facet.groupby) {\\n      op = scope.add(Facet({\\n        key: scope.keyRef(facet.groupby),\\n        group: ref(scope.proxy(group.parent)),\\n        pulse: data\\n      }));\\n    } else {\\n      vegaUtil.error('Facet must specify groupby or field: ' + vegaUtil.stringValue(facet));\\n    } // initialize facet subscope\\n\\n\\n    const subscope = scope.fork(),\\n          source = subscope.add(Collect()),\\n          values = subscope.add(Sieve({\\n      pulse: ref(source)\\n    }));\\n    subscope.addData(name, new DataScope(subscope, source, source, values));\\n    subscope.addSignal('parent', null); // parse faceted subflow\\n\\n    op.params.subflow = {\\n      $subflow: subscope.parse(spec).toRuntime()\\n    };\\n  }\\n\\n  function parseSubflow (spec, scope, input) {\\n    const op = scope.add(PreFacet({\\n      pulse: input.pulse\\n    })),\\n          subscope = scope.fork();\\n    subscope.add(Sieve());\\n    subscope.addSignal('parent', null); // parse group mark subflow\\n\\n    op.params.subflow = {\\n      $subflow: subscope.parse(spec).toRuntime()\\n    };\\n  }\\n\\n  function parseTrigger (spec, scope, name) {\\n    const remove = spec.remove,\\n          insert = spec.insert,\\n          toggle = spec.toggle,\\n          modify = spec.modify,\\n          values = spec.values,\\n          op = scope.add(operator());\\n    const update = 'if(' + spec.trigger + ',modify(\\\"' + name + '\\\",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';\\n    const expr = vegaFunctions.parseExpression(update, scope);\\n    op.update = expr.$expr;\\n    op.params = expr.$params;\\n  }\\n\\n  function parseMark (spec, scope) {\\n    const role = getRole(spec),\\n          group = spec.type === GroupMark,\\n          facet = spec.from && spec.from.facet,\\n          overlap = spec.overlap;\\n    let layout = spec.layout || role === ScopeRole || role === FrameRole,\\n        ops,\\n        op,\\n        store,\\n        enc,\\n        name,\\n        layoutRef,\\n        boundRef;\\n    const nested = role === MarkRole || layout || facet; // resolve input data\\n\\n    const input = parseData(spec.from, group, scope); // data join to map tuples to visual items\\n\\n    op = scope.add(DataJoin({\\n      key: input.key || (spec.key ? fieldRef(spec.key) : undefined),\\n      pulse: input.pulse,\\n      clean: !group\\n    }));\\n    const joinRef = ref(op); // collect visual items\\n\\n    op = store = scope.add(Collect({\\n      pulse: joinRef\\n    })); // connect visual items to scenegraph\\n\\n    op = scope.add(Mark({\\n      markdef: definition(spec),\\n      interactive: interactive(spec.interactive, scope),\\n      clip: clip(spec.clip, scope),\\n      context: {\\n        $context: true\\n      },\\n      groups: scope.lookup(),\\n      parent: scope.signals.parent ? scope.signalRef('parent') : null,\\n      index: scope.markpath(),\\n      pulse: ref(op)\\n    }));\\n    const markRef = ref(op); // add visual encoders\\n\\n    op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {\\n      mod: false,\\n      pulse: markRef\\n    }))); // monitor parent marks to propagate changes\\n\\n    op.params.parent = scope.encode(); // add post-encoding transforms, if defined\\n\\n    if (spec.transform) {\\n      spec.transform.forEach(_ => {\\n        const tx = parseTransform(_, scope),\\n              md = tx.metadata;\\n\\n        if (md.generates || md.changes) {\\n          vegaUtil.error('Mark transforms should not generate new data.');\\n        }\\n\\n        if (!md.nomod) enc.params.mod = true; // update encode mod handling\\n\\n        tx.params.pulse = ref(op);\\n        scope.add(op = tx);\\n      });\\n    } // if item sort specified, perform post-encoding\\n\\n\\n    if (spec.sort) {\\n      op = scope.add(SortItems({\\n        sort: scope.compareRef(spec.sort),\\n        pulse: ref(op)\\n      }));\\n    }\\n\\n    const encodeRef = ref(op); // add view layout operator if needed\\n\\n    if (facet || layout) {\\n      layout = scope.add(ViewLayout({\\n        layout: scope.objectProperty(spec.layout),\\n        legends: scope.legends,\\n        mark: markRef,\\n        pulse: encodeRef\\n      }));\\n      layoutRef = ref(layout);\\n    } // compute bounding boxes\\n\\n\\n    const bound = scope.add(Bound({\\n      mark: markRef,\\n      pulse: layoutRef || encodeRef\\n    }));\\n    boundRef = ref(bound); // if group mark, recurse to parse nested content\\n\\n    if (group) {\\n      // juggle layout & bounds to ensure they run *after* any faceting transforms\\n      if (nested) {\\n        ops = scope.operators;\\n        ops.pop();\\n        if (layout) ops.pop();\\n      }\\n\\n      scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\\n      facet ? parseFacet(spec, scope, input) // explicit facet\\n      : nested ? parseSubflow(spec, scope, input) // standard mark group\\n      : scope.parse(spec); // guide group, we can avoid nested scopes\\n\\n      scope.popState();\\n\\n      if (nested) {\\n        if (layout) ops.push(layout);\\n        ops.push(bound);\\n      }\\n    } // if requested, add overlap removal transform\\n\\n\\n    if (overlap) {\\n      boundRef = parseOverlap(overlap, boundRef, scope);\\n    } // render / sieve items\\n\\n\\n    const render = scope.add(Render({\\n      pulse: boundRef\\n    })),\\n          sieve = scope.add(Sieve({\\n      pulse: ref(render)\\n    }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry\\n    // add trigger updates if defined\\n\\n    if (spec.name != null) {\\n      name = spec.name;\\n      scope.addData(name, new DataScope(scope, store, render, sieve));\\n      if (spec.on) spec.on.forEach(on => {\\n        if (on.insert || on.remove || on.toggle) {\\n          vegaUtil.error('Marks only support modify triggers.');\\n        }\\n\\n        parseTrigger(on, scope, name);\\n      });\\n    }\\n  }\\n\\n  function parseOverlap(overlap, source, scope) {\\n    const method = overlap.method,\\n          bound = overlap.bound,\\n          sep = overlap.separation;\\n    const params = {\\n      separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\\n      method: isSignal(method) ? scope.signalRef(method.signal) : method,\\n      pulse: source\\n    };\\n\\n    if (overlap.order) {\\n      params.sort = scope.compareRef({\\n        field: overlap.order\\n      });\\n    }\\n\\n    if (bound) {\\n      const tol = bound.tolerance;\\n      params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\\n      params.boundScale = scope.scaleRef(bound.scale);\\n      params.boundOrient = bound.orient;\\n    }\\n\\n    return ref(scope.add(Overlap(params)));\\n  }\\n\\n  function parseLegend (spec, scope) {\\n    const config = scope.config.legend,\\n          encode = spec.encode || {},\\n          _ = lookup(spec, config),\\n          legendEncode = encode.legend || {},\\n          name = legendEncode.name || undefined,\\n          interactive = legendEncode.interactive,\\n          style = legendEncode.style,\\n          scales = {};\\n\\n    let scale = 0,\\n        entryLayout,\\n        params,\\n        children; // resolve scales and 'canonical' scale name\\n\\n    LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);\\n    if (!scale) vegaUtil.error('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)\\n\\n    const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group\\n\\n    const datum = {\\n      title: spec.title != null,\\n      scales: scales,\\n      type: type,\\n      vgrad: type !== 'symbol' && _.isVertical()\\n    };\\n    const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group\\n\\n    const entryEncode = {\\n      enter: {\\n        x: {\\n          value: 0\\n        },\\n        y: {\\n          value: 0\\n        }\\n      }\\n    }; // data source for legend values\\n\\n    const entryRef = ref(scope.add(LegendEntries(params = {\\n      type: type,\\n      scale: scope.scaleRef(scale),\\n      count: scope.objectProperty(_('tickCount')),\\n      limit: scope.property(_('symbolLimit')),\\n      values: scope.objectProperty(spec.values),\\n      minstep: scope.property(spec.tickMinStep),\\n      formatType: scope.property(spec.formatType),\\n      formatSpecifier: scope.property(spec.format)\\n    }))); // continuous gradient legend\\n\\n    if (type === Gradient) {\\n      children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length\\n\\n      params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);\\n    } // discrete gradient legend\\n    else if (type === Discrete) {\\n        children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];\\n      } // symbol legend\\n      else {\\n          // determine legend symbol group layout\\n          entryLayout = legendSymbolLayout(spec, config);\\n          children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator\\n\\n          params.size = sizeExpression(spec, scope, children[0].marks);\\n        } // generate legend marks\\n\\n\\n    children = [guideGroup({\\n      role: LegendEntryRole,\\n      from: dataRef,\\n      encode: entryEncode,\\n      marks: children,\\n      layout: entryLayout,\\n      interactive\\n    })]; // include legend title if defined\\n\\n    if (datum.title) {\\n      children.push(legendTitle(spec, config, encode.title, dataRef));\\n    } // parse legend specification\\n\\n\\n    return parseMark(guideGroup({\\n      role: LegendRole,\\n      from: dataRef,\\n      encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\\n      marks: children,\\n      aria: _('aria'),\\n      description: _('description'),\\n      zindex: _('zindex'),\\n      name,\\n      interactive,\\n      style\\n    }), scope);\\n  }\\n\\n  function legendType(spec, scaleType) {\\n    let type = spec.type || Symbols;\\n\\n    if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\\n      type = vegaScale.isContinuous(scaleType) ? Gradient : vegaScale.isDiscretizing(scaleType) ? Discrete : Symbols;\\n    }\\n\\n    return type !== Gradient ? type : vegaScale.isDiscretizing(scaleType) ? Discrete : Gradient;\\n  }\\n\\n  function scaleCount(spec) {\\n    return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\\n  }\\n\\n  function buildLegendEncode(_, spec, config) {\\n    const encode = {\\n      enter: {},\\n      update: {}\\n    };\\n    addEncoders(encode, {\\n      orient: _('orient'),\\n      offset: _('offset'),\\n      padding: _('padding'),\\n      titlePadding: _('titlePadding'),\\n      cornerRadius: _('cornerRadius'),\\n      fill: _('fillColor'),\\n      stroke: _('strokeColor'),\\n      strokeWidth: config.strokeWidth,\\n      strokeDash: config.strokeDash,\\n      x: _('legendX'),\\n      y: _('legendY'),\\n      // accessibility support\\n      format: spec.format,\\n      formatType: spec.formatType\\n    });\\n    return encode;\\n  }\\n\\n  function sizeExpression(spec, scope, marks) {\\n    const size = deref(getChannel('size', spec, marks)),\\n          strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\\n          fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\\n    return vegaFunctions.parseExpression(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);\\n  }\\n\\n  function getChannel(name, spec, marks) {\\n    return spec[name] ? `scale(\\\"${spec[name]}\\\",datum)` : getEncoding(name, marks[0].encode);\\n  }\\n\\n  function getFontSize(encode, scope, style) {\\n    return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\\n  }\\n\\n  const angleExpr = `item.orient===\\\"${Left}\\\"?-90:item.orient===\\\"${Right}\\\"?90:0`;\\n  function parseTitle (spec, scope) {\\n    spec = vegaUtil.isString(spec) ? {\\n      text: spec\\n    } : spec;\\n\\n    const _ = lookup(spec, scope.config.title),\\n          encode = spec.encode || {},\\n          userEncode = encode.group || {},\\n          name = userEncode.name || undefined,\\n          interactive = userEncode.interactive,\\n          style = userEncode.style,\\n          children = []; // single-element data source for group title\\n\\n\\n    const datum = {},\\n          dataRef = ref(scope.add(Collect(null, [datum]))); // include title text\\n\\n    children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text\\n\\n    if (spec.subtitle) {\\n      children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\\n    } // parse title specification\\n\\n\\n    return parseMark(guideGroup({\\n      role: TitleRole,\\n      from: dataRef,\\n      encode: groupEncode(_, userEncode),\\n      marks: children,\\n      aria: _('aria'),\\n      description: _('description'),\\n      zindex: _('zindex'),\\n      name,\\n      interactive,\\n      style\\n    }), scope);\\n  } // provide backwards-compatibility for title custom encode;\\n  // the top-level encode block has been *deprecated*.\\n\\n  function titleEncode(spec) {\\n    const encode = spec.encode;\\n    return encode && encode.title || vegaUtil.extend({\\n      name: spec.name,\\n      interactive: spec.interactive,\\n      style: spec.style\\n    }, encode);\\n  }\\n\\n  function groupEncode(_, userEncode) {\\n    const encode = {\\n      enter: {},\\n      update: {}\\n    };\\n    addEncoders(encode, {\\n      orient: _('orient'),\\n      anchor: _('anchor'),\\n      align: {\\n        signal: alignExpr\\n      },\\n      angle: {\\n        signal: angleExpr\\n      },\\n      limit: _('limit'),\\n      frame: _('frame'),\\n      offset: _('offset') || 0,\\n      padding: _('subtitlePadding')\\n    });\\n    return extendEncode(encode, userEncode, Skip);\\n  }\\n\\n  function buildTitle(spec, _, userEncode, dataRef) {\\n    const zero = {\\n      value: 0\\n    },\\n          text = spec.text,\\n          encode = {\\n      enter: {\\n        opacity: zero\\n      },\\n      update: {\\n        opacity: {\\n          value: 1\\n        }\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      text: text,\\n      align: {\\n        signal: 'item.mark.group.align'\\n      },\\n      angle: {\\n        signal: 'item.mark.group.angle'\\n      },\\n      limit: {\\n        signal: 'item.mark.group.limit'\\n      },\\n      baseline: 'top',\\n      dx: _('dx'),\\n      dy: _('dy'),\\n      fill: _('color'),\\n      font: _('font'),\\n      fontSize: _('fontSize'),\\n      fontStyle: _('fontStyle'),\\n      fontWeight: _('fontWeight'),\\n      lineHeight: _('lineHeight')\\n    }, {\\n      // update\\n      align: _('align'),\\n      angle: _('angle'),\\n      baseline: _('baseline')\\n    });\\n    return guideMark({\\n      type: TextMark,\\n      role: TitleTextRole,\\n      style: GroupTitleStyle,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function buildSubTitle(spec, _, userEncode, dataRef) {\\n    const zero = {\\n      value: 0\\n    },\\n          text = spec.subtitle,\\n          encode = {\\n      enter: {\\n        opacity: zero\\n      },\\n      update: {\\n        opacity: {\\n          value: 1\\n        }\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      text: text,\\n      align: {\\n        signal: 'item.mark.group.align'\\n      },\\n      angle: {\\n        signal: 'item.mark.group.angle'\\n      },\\n      limit: {\\n        signal: 'item.mark.group.limit'\\n      },\\n      baseline: 'top',\\n      dx: _('dx'),\\n      dy: _('dy'),\\n      fill: _('subtitleColor'),\\n      font: _('subtitleFont'),\\n      fontSize: _('subtitleFontSize'),\\n      fontStyle: _('subtitleFontStyle'),\\n      fontWeight: _('subtitleFontWeight'),\\n      lineHeight: _('subtitleLineHeight')\\n    }, {\\n      // update\\n      align: _('align'),\\n      angle: _('angle'),\\n      baseline: _('baseline')\\n    });\\n    return guideMark({\\n      type: TextMark,\\n      role: TitleSubtitleRole,\\n      style: GroupSubtitleStyle,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function parseData$1(data, scope) {\\n    const transforms = [];\\n\\n    if (data.transform) {\\n      data.transform.forEach(tx => {\\n        transforms.push(parseTransform(tx, scope));\\n      });\\n    }\\n\\n    if (data.on) {\\n      data.on.forEach(on => {\\n        parseTrigger(on, scope, data.name);\\n      });\\n    }\\n\\n    scope.addDataPipeline(data.name, analyze(data, scope, transforms));\\n  }\\n  /**\\n   * Analyze a data pipeline, add needed operators.\\n   */\\n\\n  function analyze(data, scope, ops) {\\n    const output = [];\\n    let source = null,\\n        modify = false,\\n        generate = false,\\n        upstream,\\n        i,\\n        n,\\n        t,\\n        m;\\n\\n    if (data.values) {\\n      // hard-wired input data set\\n      if (isSignal(data.values) || hasSignal(data.format)) {\\n        // if either values is signal or format has signal, use dynamic loader\\n        output.push(load(scope, data));\\n        output.push(source = collect());\\n      } else {\\n        // otherwise, ingest upon dataflow init\\n        output.push(source = collect({\\n          $ingest: data.values,\\n          $format: data.format\\n        }));\\n      }\\n    } else if (data.url) {\\n      // load data from external source\\n      if (hasSignal(data.url) || hasSignal(data.format)) {\\n        // if either url or format has signal, use dynamic loader\\n        output.push(load(scope, data));\\n        output.push(source = collect());\\n      } else {\\n        // otherwise, request load upon dataflow init\\n        output.push(source = collect({\\n          $request: data.url,\\n          $format: data.format\\n        }));\\n      }\\n    } else if (data.source) {\\n      // derives from one or more other data sets\\n      source = upstream = vegaUtil.array(data.source).map(d => ref(scope.getData(d).output));\\n      output.push(null); // populate later\\n    } // scan data transforms, add collectors as needed\\n\\n\\n    for (i = 0, n = ops.length; i < n; ++i) {\\n      t = ops[i];\\n      m = t.metadata;\\n\\n      if (!source && !m.source) {\\n        output.push(source = collect());\\n      }\\n\\n      output.push(t);\\n      if (m.generates) generate = true;\\n      if (m.modifies && !generate) modify = true;\\n      if (m.source) source = t;else if (m.changes) source = null;\\n    }\\n\\n    if (upstream) {\\n      n = upstream.length - 1;\\n      output[0] = Relay({\\n        derive: modify,\\n        pulse: n ? upstream : upstream[0]\\n      });\\n\\n      if (modify || n) {\\n        // collect derived and multi-pulse tuples\\n        output.splice(1, 0, collect());\\n      }\\n    }\\n\\n    if (!source) output.push(collect());\\n    output.push(Sieve({}));\\n    return output;\\n  }\\n\\n  function collect(values) {\\n    const s = Collect({}, values);\\n    s.metadata = {\\n      source: true\\n    };\\n    return s;\\n  }\\n\\n  function load(scope, data) {\\n    return Load({\\n      url: data.url ? scope.property(data.url) : undefined,\\n      async: data.async ? scope.property(data.async) : undefined,\\n      values: data.values ? scope.property(data.values) : undefined,\\n      format: scope.objectProperty(data.format)\\n    });\\n  }\\n\\n  const isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient\\n\\n\\n  const getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction\\n\\n  const ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction\\n\\n  const ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;\\n  const ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {\\n    value: a\\n  } : {\\n    value: b\\n  };\\n  const ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {\\n    value: a\\n  } : {\\n    value: b\\n  };\\n\\n  const ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);\\n\\n  const ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);\\n\\n  const ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);\\n\\n  const ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);\\n\\n  const ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);\\n\\n  const ifEnc = (test, a, b) => {\\n    // ensure inputs are encoder objects (or null)\\n    a = a != null ? encoder(a) : a;\\n    b = b != null ? encoder(b) : b;\\n\\n    if (isSimple(a) && isSimple(b)) {\\n      // if possible generate simple signal expression\\n      a = a ? a.signal || vegaUtil.stringValue(a.value) : null;\\n      b = b ? b.signal || vegaUtil.stringValue(b.value) : null;\\n      return {\\n        signal: `${test} ? (${a}) : (${b})`\\n      };\\n    } else {\\n      // otherwise generate rule set\\n      return [vegaUtil.extend({\\n        test\\n      }, a)].concat(b || []);\\n    }\\n  };\\n\\n  const isSimple = enc => enc == null || Object.keys(enc).length === 1;\\n\\n  const ifExpr = (test, a, b) => ({\\n    signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\\n  });\\n\\n  const ifOrient = ($orient, t, b, l, r) => ({\\n    signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'\\n  });\\n\\n  const toExpr = v => isSignal(v) ? v.signal : v == null ? null : vegaUtil.stringValue(v);\\n\\n  const mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {\\n    signal: `(${sign.signal}) * ${value}`\\n  } : {\\n    value: sign * value\\n  };\\n  const patch = (value, base) => {\\n    const s = value.signal;\\n    return s && s.endsWith('(null)') ? {\\n      signal: s.slice(0, -6) + base.signal\\n    } : value;\\n  };\\n\\n  function fallback(prop, config, axisConfig, style) {\\n    let styleProp;\\n\\n    if (config && vegaUtil.hasOwnProperty(config, prop)) {\\n      return config[prop];\\n    } else if (vegaUtil.hasOwnProperty(axisConfig, prop)) {\\n      return axisConfig[prop];\\n    } else if (prop.startsWith('title')) {\\n      switch (prop) {\\n        case 'titleColor':\\n          styleProp = 'fill';\\n          break;\\n\\n        case 'titleFont':\\n        case 'titleFontSize':\\n        case 'titleFontWeight':\\n          styleProp = prop[5].toLowerCase() + prop.slice(6);\\n      }\\n\\n      return style[GuideTitleStyle][styleProp];\\n    } else if (prop.startsWith('label')) {\\n      switch (prop) {\\n        case 'labelColor':\\n          styleProp = 'fill';\\n          break;\\n\\n        case 'labelFont':\\n        case 'labelFontSize':\\n          styleProp = prop[5].toLowerCase() + prop.slice(6);\\n      }\\n\\n      return style[GuideLabelStyle][styleProp];\\n    }\\n\\n    return null;\\n  }\\n\\n  function keys(objects) {\\n    const map = {};\\n\\n    for (const obj of objects) {\\n      if (!obj) continue;\\n\\n      for (const key in obj) map[key] = 1;\\n    }\\n\\n    return Object.keys(map);\\n  }\\n\\n  function axisConfig (spec, scope) {\\n    var config = scope.config,\\n        style = config.style,\\n        axis = config.axis,\\n        band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\\n        orient = spec.orient,\\n        xy,\\n        or,\\n        key;\\n\\n    if (isSignal(orient)) {\\n      const xyKeys = keys([config.axisX, config.axisY]),\\n            orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);\\n      xy = {};\\n\\n      for (key of xyKeys) {\\n        xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));\\n      }\\n\\n      or = {};\\n\\n      for (key of orientKeys) {\\n        or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));\\n      }\\n    } else {\\n      xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;\\n      or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\\n    }\\n\\n    const result = xy || or || band ? vegaUtil.extend({}, axis, xy, or, band) : axis;\\n    return result;\\n  }\\n\\n  function axisDomain (spec, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient;\\n\\n    let enter, update;\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero\\n      },\\n      update: update = {\\n        opacity: one\\n      },\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      stroke: _('domainColor'),\\n      strokeCap: _('domainCap'),\\n      strokeDash: _('domainDash'),\\n      strokeDashOffset: _('domainDashOffset'),\\n      strokeWidth: _('domainWidth'),\\n      strokeOpacity: _('domainOpacity')\\n    });\\n    const pos0 = position(spec, 0);\\n    const pos1 = position(spec, 1);\\n    enter.x = update.x = ifX(orient, pos0, zero);\\n    enter.x2 = update.x2 = ifX(orient, pos1);\\n    enter.y = update.y = ifY(orient, pos0, zero);\\n    enter.y2 = update.y2 = ifY(orient, pos1);\\n    return guideMark({\\n      type: RuleMark,\\n      role: AxisDomainRole,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function position(spec, pos) {\\n    return {\\n      scale: spec.scale,\\n      range: pos\\n    };\\n  }\\n\\n  function axisGrid (spec, config, userEncode, dataRef, band) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient,\\n          vscale = spec.gridScale,\\n          sign = getSign(orient, 1, -1),\\n          offset = offsetValue(spec.offset, sign);\\n\\n    let enter, exit, update;\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero\\n      },\\n      update: update = {\\n        opacity: one\\n      },\\n      exit: exit = {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      stroke: _('gridColor'),\\n      strokeCap: _('gridCap'),\\n      strokeDash: _('gridDash'),\\n      strokeDashOffset: _('gridDashOffset'),\\n      strokeOpacity: _('gridOpacity'),\\n      strokeWidth: _('gridWidth')\\n    });\\n    const tickPos = {\\n      scale: spec.scale,\\n      field: Value,\\n      band: band.band,\\n      extra: band.extra,\\n      offset: band.offset,\\n      round: _('tickRound')\\n    };\\n    const sz = ifX(orient, {\\n      signal: 'height'\\n    }, {\\n      signal: 'width'\\n    });\\n    const gridStart = vscale ? {\\n      scale: vscale,\\n      range: 0,\\n      mult: sign,\\n      offset: offset\\n    } : {\\n      value: 0,\\n      offset: offset\\n    };\\n    const gridEnd = vscale ? {\\n      scale: vscale,\\n      range: 1,\\n      mult: sign,\\n      offset: offset\\n    } : vegaUtil.extend(sz, {\\n      mult: sign,\\n      offset: offset\\n    });\\n    enter.x = update.x = ifX(orient, tickPos, gridStart);\\n    enter.y = update.y = ifY(orient, tickPos, gridStart);\\n    enter.x2 = update.x2 = ifY(orient, gridEnd);\\n    enter.y2 = update.y2 = ifX(orient, gridEnd);\\n    exit.x = ifX(orient, tickPos);\\n    exit.y = ifY(orient, tickPos);\\n    return guideMark({\\n      type: RuleMark,\\n      role: AxisGridRole,\\n      key: Value,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function offsetValue(offset, sign) {\\n    if (sign === 1) ; else if (!vegaUtil.isObject(offset)) {\\n      offset = isSignal(sign) ? {\\n        signal: `(${sign.signal}) * (${offset || 0})`\\n      } : sign * (offset || 0);\\n    } else {\\n      let entry = offset = vegaUtil.extend({}, offset);\\n\\n      while (entry.mult != null) {\\n        if (!vegaUtil.isObject(entry.mult)) {\\n          entry.mult = isSignal(sign) // no offset if sign === 1\\n          ? {\\n            signal: `(${entry.mult}) * (${sign.signal})`\\n          } : entry.mult * sign;\\n          return offset;\\n        } else {\\n          entry = entry.mult = vegaUtil.extend({}, entry.mult);\\n        }\\n      }\\n\\n      entry.mult = sign;\\n    }\\n\\n    return offset;\\n  }\\n\\n  function axisTicks (spec, config, userEncode, dataRef, size, band) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient,\\n          sign = getSign(orient, -1, 1);\\n\\n    let enter, exit, update;\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero\\n      },\\n      update: update = {\\n        opacity: one\\n      },\\n      exit: exit = {\\n        opacity: zero\\n      }\\n    };\\n    addEncoders(encode, {\\n      stroke: _('tickColor'),\\n      strokeCap: _('tickCap'),\\n      strokeDash: _('tickDash'),\\n      strokeDashOffset: _('tickDashOffset'),\\n      strokeOpacity: _('tickOpacity'),\\n      strokeWidth: _('tickWidth')\\n    });\\n    const tickSize = encoder(size);\\n    tickSize.mult = sign;\\n    const tickPos = {\\n      scale: spec.scale,\\n      field: Value,\\n      band: band.band,\\n      extra: band.extra,\\n      offset: band.offset,\\n      round: _('tickRound')\\n    };\\n    update.y = enter.y = ifX(orient, zero, tickPos);\\n    update.y2 = enter.y2 = ifX(orient, tickSize);\\n    exit.x = ifX(orient, tickPos);\\n    update.x = enter.x = ifY(orient, zero, tickPos);\\n    update.x2 = enter.x2 = ifY(orient, tickSize);\\n    exit.y = ifY(orient, tickPos);\\n    return guideMark({\\n      type: RuleMark,\\n      role: AxisTickRole,\\n      key: Value,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function flushExpr(scale, threshold, a, b, c) {\\n    return {\\n      signal: 'flush(range(\\\"' + scale + '\\\"), ' + 'scale(\\\"' + scale + '\\\", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'\\n    };\\n  }\\n\\n  function axisLabels (spec, config, userEncode, dataRef, size, band) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient,\\n          scale = spec.scale,\\n          sign = getSign(orient, -1, 1),\\n          flush = deref(_('labelFlush')),\\n          flushOffset = deref(_('labelFlushOffset')),\\n          labelAlign = _('labelAlign'),\\n          labelBaseline = _('labelBaseline');\\n\\n    let flushOn = flush === 0 || !!flush,\\n        update;\\n    const tickSize = encoder(size);\\n    tickSize.mult = sign;\\n    tickSize.offset = encoder(_('labelPadding') || 0);\\n    tickSize.offset.mult = sign;\\n    const tickPos = {\\n      scale: scale,\\n      field: Value,\\n      band: 0.5,\\n      offset: extendOffset(band.offset, _('labelOffset'))\\n    };\\n    const align = ifX(orient, flushOn ? flushExpr(scale, flush, '\\\"left\\\"', '\\\"right\\\"', '\\\"center\\\"') : {\\n      value: 'center'\\n    }, ifRight(orient, 'left', 'right'));\\n    const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '\\\"top\\\"', '\\\"bottom\\\"', '\\\"middle\\\"') : {\\n      value: 'middle'\\n    });\\n    const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\\n    flushOn = flushOn && flushOffset;\\n    const enter = {\\n      opacity: zero,\\n      x: ifX(orient, tickPos, tickSize),\\n      y: ifY(orient, tickPos, tickSize)\\n    };\\n    const encode = {\\n      enter: enter,\\n      update: update = {\\n        opacity: one,\\n        text: {\\n          field: Label\\n        },\\n        x: enter.x,\\n        y: enter.y,\\n        align,\\n        baseline\\n      },\\n      exit: {\\n        opacity: zero,\\n        x: enter.x,\\n        y: enter.y\\n      }\\n    };\\n    addEncoders(encode, {\\n      dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\\n      dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\\n    });\\n    addEncoders(encode, {\\n      angle: _('labelAngle'),\\n      fill: _('labelColor'),\\n      fillOpacity: _('labelOpacity'),\\n      font: _('labelFont'),\\n      fontSize: _('labelFontSize'),\\n      fontWeight: _('labelFontWeight'),\\n      fontStyle: _('labelFontStyle'),\\n      limit: _('labelLimit'),\\n      lineHeight: _('labelLineHeight')\\n    }, {\\n      align: labelAlign,\\n      baseline: labelBaseline\\n    });\\n\\n    const bound = _('labelBound');\\n\\n    let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal\\n\\n\\n    overlap = overlap || bound ? {\\n      separation: _('labelSeparation'),\\n      method: overlap,\\n      order: 'datum.index',\\n      bound: bound ? {\\n        scale,\\n        orient,\\n        tolerance: bound\\n      } : null\\n    } : undefined;\\n\\n    if (update.align !== align) {\\n      update.align = patch(update.align, align);\\n    }\\n\\n    if (update.baseline !== baseline) {\\n      update.baseline = patch(update.baseline, baseline);\\n    }\\n\\n    return guideMark({\\n      type: TextMark,\\n      role: AxisLabelRole,\\n      style: GuideLabelStyle,\\n      key: Value,\\n      from: dataRef,\\n      encode,\\n      overlap\\n    }, userEncode);\\n  }\\n\\n  function axisTitle (spec, config, userEncode, dataRef) {\\n    const _ = lookup(spec, config),\\n          orient = spec.orient,\\n          sign = getSign(orient, -1, 1);\\n\\n    let enter, update;\\n    const encode = {\\n      enter: enter = {\\n        opacity: zero,\\n        anchor: encoder(_('titleAnchor', null)),\\n        align: {\\n          signal: alignExpr\\n        }\\n      },\\n      update: update = vegaUtil.extend({}, enter, {\\n        opacity: one,\\n        text: encoder(spec.title)\\n      }),\\n      exit: {\\n        opacity: zero\\n      }\\n    };\\n    const titlePos = {\\n      signal: `lerp(range(\\\"${spec.scale}\\\"), ${anchorExpr(0, 1, 0.5)})`\\n    };\\n    update.x = ifX(orient, titlePos);\\n    update.y = ifY(orient, titlePos);\\n    enter.angle = ifX(orient, zero, mult(sign, 90));\\n    enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {\\n      value: Bottom\\n    });\\n    update.angle = enter.angle;\\n    update.baseline = enter.baseline;\\n    addEncoders(encode, {\\n      fill: _('titleColor'),\\n      fillOpacity: _('titleOpacity'),\\n      font: _('titleFont'),\\n      fontSize: _('titleFontSize'),\\n      fontStyle: _('titleFontStyle'),\\n      fontWeight: _('titleFontWeight'),\\n      limit: _('titleLimit'),\\n      lineHeight: _('titleLineHeight')\\n    }, {\\n      // require update\\n      align: _('titleAlign'),\\n      angle: _('titleAngle'),\\n      baseline: _('titleBaseline')\\n    });\\n    autoLayout(_, orient, encode, userEncode);\\n    encode.update.align = patch(encode.update.align, enter.align);\\n    encode.update.angle = patch(encode.update.angle, enter.angle);\\n    encode.update.baseline = patch(encode.update.baseline, enter.baseline);\\n    return guideMark({\\n      type: TextMark,\\n      role: AxisTitleRole,\\n      style: GuideTitleStyle,\\n      from: dataRef,\\n      encode\\n    }, userEncode);\\n  }\\n\\n  function autoLayout(_, orient, encode, userEncode) {\\n    const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;\\n\\n    const autoY = auto(_('titleX'), 'x'),\\n          autoX = auto(_('titleY'), 'y');\\n    encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));\\n  }\\n\\n  function parseAxis (spec, scope) {\\n    const config = axisConfig(spec, scope),\\n          encode = spec.encode || {},\\n          axisEncode = encode.axis || {},\\n          name = axisEncode.name || undefined,\\n          interactive = axisEncode.interactive,\\n          style = axisEncode.style,\\n          _ = lookup(spec, config),\\n          band = tickBand(_); // single-element data source for axis group\\n\\n\\n    const datum = {\\n      scale: spec.scale,\\n      ticks: !!_('ticks'),\\n      labels: !!_('labels'),\\n      grid: !!_('grid'),\\n      domain: !!_('domain'),\\n      title: spec.title != null\\n    };\\n    const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks\\n\\n    const ticksRef = ref(scope.add(AxisTicks({\\n      scale: scope.scaleRef(spec.scale),\\n      extra: scope.property(band.extra),\\n      count: scope.objectProperty(spec.tickCount),\\n      values: scope.objectProperty(spec.values),\\n      minstep: scope.property(spec.tickMinStep),\\n      formatType: scope.property(spec.formatType),\\n      formatSpecifier: scope.property(spec.format)\\n    }))); // generate axis marks\\n\\n    const children = [];\\n    let size; // include axis gridlines if requested\\n\\n    if (datum.grid) {\\n      children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\\n    } // include axis ticks if requested\\n\\n\\n    if (datum.ticks) {\\n      size = _('tickSize');\\n      children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\\n    } // include axis labels if requested\\n\\n\\n    if (datum.labels) {\\n      size = datum.ticks ? size : 0;\\n      children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\\n    } // include axis domain path if requested\\n\\n\\n    if (datum.domain) {\\n      children.push(axisDomain(spec, config, encode.domain, dataRef));\\n    } // include axis title if defined\\n\\n\\n    if (datum.title) {\\n      children.push(axisTitle(spec, config, encode.title, dataRef));\\n    } // parse axis specification\\n\\n\\n    return parseMark(guideGroup({\\n      role: AxisRole,\\n      from: dataRef,\\n      encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\\n      marks: children,\\n      aria: _('aria'),\\n      description: _('description'),\\n      zindex: _('zindex'),\\n      name,\\n      interactive,\\n      style\\n    }), scope);\\n  }\\n\\n  function buildAxisEncode(_, spec) {\\n    const encode = {\\n      enter: {},\\n      update: {}\\n    };\\n    addEncoders(encode, {\\n      orient: _('orient'),\\n      offset: _('offset') || 0,\\n      position: value(spec.position, 0),\\n      titlePadding: _('titlePadding'),\\n      minExtent: _('minExtent'),\\n      maxExtent: _('maxExtent'),\\n      range: {\\n        signal: `abs(span(range(\\\"${spec.scale}\\\")))`\\n      },\\n      translate: _('translate'),\\n      // accessibility support\\n      format: spec.format,\\n      formatType: spec.formatType\\n    });\\n    return encode;\\n  }\\n\\n  function parseScope (spec, scope, preprocessed) {\\n    const signals = vegaUtil.array(spec.signals),\\n          scales = vegaUtil.array(spec.scales); // parse signal definitions, if not already preprocessed\\n\\n    if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions\\n\\n    vegaUtil.array(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references\\n\\n    scales.forEach(_ => initScale(_, scope)); // parse data sources\\n\\n    vegaUtil.array(spec.data).forEach(_ => parseData$1(_, scope)); // parse scale definitions\\n\\n    scales.forEach(_ => parseScale(_, scope)); // parse signal updates\\n\\n    (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions\\n\\n    vegaUtil.array(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions\\n\\n    vegaUtil.array(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions\\n\\n    vegaUtil.array(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined\\n\\n    if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions\\n\\n    scope.parseLambdas();\\n    return scope;\\n  }\\n\\n  const rootEncode = spec => extendEncode({\\n    enter: {\\n      x: {\\n        value: 0\\n      },\\n      y: {\\n        value: 0\\n      }\\n    },\\n    update: {\\n      width: {\\n        signal: 'width'\\n      },\\n      height: {\\n        signal: 'height'\\n      }\\n    }\\n  }, spec);\\n\\n  function parseView(spec, scope) {\\n    const config = scope.config; // add scenegraph root\\n\\n    const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions\\n\\n    const signals = collectSignals(spec, config);\\n    signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration\\n\\n    scope.description = spec.description || config.description;\\n    scope.eventConfig = config.events;\\n    scope.legends = scope.objectProperty(config.legend && config.legend.layout);\\n    scope.locale = config.locale; // store root group item\\n\\n    const input = scope.add(Collect()); // encode root group item\\n\\n    const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {\\n      pulse: ref(input)\\n    }))); // perform view layout\\n\\n    const parent = scope.add(ViewLayout({\\n      layout: scope.objectProperty(spec.layout),\\n      legends: scope.legends,\\n      autosize: scope.signalRef('autosize'),\\n      mark: root,\\n      pulse: ref(encode)\\n    }));\\n    scope.operators.pop(); // parse remainder of specification\\n\\n    scope.pushState(ref(encode), ref(parent), null);\\n    parseScope(spec, scope, signals);\\n    scope.operators.push(parent); // bound / render / sieve root item\\n\\n    let op = scope.add(Bound({\\n      mark: root,\\n      pulse: ref(parent)\\n    }));\\n    op = scope.add(Render({\\n      pulse: ref(op)\\n    }));\\n    op = scope.add(Sieve({\\n      pulse: ref(op)\\n    })); // track metadata for root item\\n\\n    scope.addData('root', new DataScope(scope, input, input, op));\\n    return scope;\\n  }\\n\\n  function signalObject(name, value) {\\n    return value && value.signal ? {\\n      name,\\n      update: value.signal\\n    } : {\\n      name,\\n      value\\n    };\\n  }\\n  /**\\n   * Collect top-level signals, merging values as needed. Signals\\n   * defined in the config signals arrays are added only if that\\n   * signal is not explicitly defined in the specification.\\n   * Built-in signals (autosize, background, padding, width, height)\\n   * receive special treatment. They are initialized using the\\n   * top-level spec property, or, if undefined in the spec, using\\n   * the corresponding top-level config property. If this property\\n   * is a signal reference object, the signal expression maps to the\\n   * signal 'update' property. If the spec's top-level signal array\\n   * contains an entry that matches a built-in signal, that entry\\n   * will be merged with the built-in specification, potentially\\n   * overwriting existing 'value' or 'update' properties.\\n   */\\n\\n\\n  function collectSignals(spec, config) {\\n    const _ = name => value(spec[name], config[name]),\\n          signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],\\n          pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\\n          map = {}; // add spec signal array\\n\\n\\n    vegaUtil.array(spec.signals).forEach(s => {\\n      if (vegaUtil.hasOwnProperty(pre, s.name)) {\\n        // merge if built-in signal\\n        s = vegaUtil.extend(pre[s.name], s);\\n      } else {\\n        // otherwise add to signal list\\n        signals.push(s);\\n      }\\n\\n      map[s.name] = s;\\n    }); // add config signal array\\n\\n    vegaUtil.array(config.signals).forEach(s => {\\n      if (!vegaUtil.hasOwnProperty(map, s.name) && !vegaUtil.hasOwnProperty(pre, s.name)) {\\n        // add to signal list if not already defined\\n        signals.push(s);\\n      }\\n    });\\n    return signals;\\n  }\\n\\n  function Scope$1(config, options) {\\n    this.config = config || {};\\n    this.options = options || {};\\n    this.bindings = [];\\n    this.field = {};\\n    this.signals = {};\\n    this.lambdas = {};\\n    this.scales = {};\\n    this.events = {};\\n    this.data = {};\\n    this.streams = [];\\n    this.updates = [];\\n    this.operators = [];\\n    this.eventConfig = null;\\n    this.locale = null;\\n    this._id = 0;\\n    this._subid = 0;\\n    this._nextsub = [0];\\n    this._parent = [];\\n    this._encode = [];\\n    this._lookup = [];\\n    this._markpath = [];\\n  }\\n\\n  function Subscope(scope) {\\n    this.config = scope.config;\\n    this.options = scope.options;\\n    this.legends = scope.legends;\\n    this.field = Object.create(scope.field);\\n    this.signals = Object.create(scope.signals);\\n    this.lambdas = Object.create(scope.lambdas);\\n    this.scales = Object.create(scope.scales);\\n    this.events = Object.create(scope.events);\\n    this.data = Object.create(scope.data);\\n    this.streams = [];\\n    this.updates = [];\\n    this.operators = [];\\n    this._id = 0;\\n    this._subid = ++scope._nextsub[0];\\n    this._nextsub = scope._nextsub;\\n    this._parent = scope._parent.slice();\\n    this._encode = scope._encode.slice();\\n    this._lookup = scope._lookup.slice();\\n    this._markpath = scope._markpath;\\n  }\\n\\n  Scope$1.prototype = Subscope.prototype = {\\n    parse(spec) {\\n      return parseScope(spec, this);\\n    },\\n\\n    fork() {\\n      return new Subscope(this);\\n    },\\n\\n    isSubscope() {\\n      return this._subid > 0;\\n    },\\n\\n    toRuntime() {\\n      this.finish();\\n      return {\\n        description: this.description,\\n        operators: this.operators,\\n        streams: this.streams,\\n        updates: this.updates,\\n        bindings: this.bindings,\\n        eventConfig: this.eventConfig,\\n        locale: this.locale\\n      };\\n    },\\n\\n    id() {\\n      return (this._subid ? this._subid + ':' : 0) + this._id++;\\n    },\\n\\n    add(op) {\\n      this.operators.push(op);\\n      op.id = this.id(); // if pre-registration references exist, resolve them now\\n\\n      if (op.refs) {\\n        op.refs.forEach(ref => {\\n          ref.$ref = op.id;\\n        });\\n        op.refs = null;\\n      }\\n\\n      return op;\\n    },\\n\\n    proxy(op) {\\n      const vref = op instanceof Entry ? ref(op) : op;\\n      return this.add(Proxy({\\n        value: vref\\n      }));\\n    },\\n\\n    addStream(stream) {\\n      this.streams.push(stream);\\n      stream.id = this.id();\\n      return stream;\\n    },\\n\\n    addUpdate(update) {\\n      this.updates.push(update);\\n      return update;\\n    },\\n\\n    // Apply metadata\\n    finish() {\\n      let name, ds; // annotate root\\n\\n      if (this.root) this.root.root = true; // annotate signals\\n\\n      for (name in this.signals) {\\n        this.signals[name].signal = name;\\n      } // annotate scales\\n\\n\\n      for (name in this.scales) {\\n        this.scales[name].scale = name;\\n      } // annotate data sets\\n\\n\\n      function annotate(op, name, type) {\\n        let data, list;\\n\\n        if (op) {\\n          data = op.data || (op.data = {});\\n          list = data[name] || (data[name] = []);\\n          list.push(type);\\n        }\\n      }\\n\\n      for (name in this.data) {\\n        ds = this.data[name];\\n        annotate(ds.input, name, 'input');\\n        annotate(ds.output, name, 'output');\\n        annotate(ds.values, name, 'values');\\n\\n        for (const field in ds.index) {\\n          annotate(ds.index[field], name, 'index:' + field);\\n        }\\n      }\\n\\n      return this;\\n    },\\n\\n    // ----\\n    pushState(encode, parent, lookup) {\\n      this._encode.push(ref(this.add(Sieve({\\n        pulse: encode\\n      }))));\\n\\n      this._parent.push(parent);\\n\\n      this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\\n\\n      this._markpath.push(-1);\\n    },\\n\\n    popState() {\\n      this._encode.pop();\\n\\n      this._parent.pop();\\n\\n      this._lookup.pop();\\n\\n      this._markpath.pop();\\n    },\\n\\n    parent() {\\n      return vegaUtil.peek(this._parent);\\n    },\\n\\n    encode() {\\n      return vegaUtil.peek(this._encode);\\n    },\\n\\n    lookup() {\\n      return vegaUtil.peek(this._lookup);\\n    },\\n\\n    markpath() {\\n      const p = this._markpath;\\n      return ++p[p.length - 1];\\n    },\\n\\n    // ----\\n    fieldRef(field, name) {\\n      if (vegaUtil.isString(field)) return fieldRef(field, name);\\n\\n      if (!field.signal) {\\n        vegaUtil.error('Unsupported field reference: ' + vegaUtil.stringValue(field));\\n      }\\n\\n      const s = field.signal;\\n      let f = this.field[s];\\n\\n      if (!f) {\\n        const params = {\\n          name: this.signalRef(s)\\n        };\\n        if (name) params.as = name;\\n        this.field[s] = f = ref(this.add(Field(params)));\\n      }\\n\\n      return f;\\n    },\\n\\n    compareRef(cmp) {\\n      let signal = false;\\n\\n      const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr(_) ? (signal = true, this.exprRef(_.expr)) : _;\\n\\n      const fields = vegaUtil.array(cmp.field).map(check),\\n            orders = vegaUtil.array(cmp.order).map(check);\\n      return signal ? ref(this.add(Compare({\\n        fields: fields,\\n        orders: orders\\n      }))) : compareRef(fields, orders);\\n    },\\n\\n    keyRef(fields, flat) {\\n      let signal = false;\\n\\n      const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;\\n\\n      const sig = this.signals;\\n      fields = vegaUtil.array(fields).map(check);\\n      return signal ? ref(this.add(Key({\\n        fields: fields,\\n        flat: flat\\n      }))) : keyRef(fields, flat);\\n    },\\n\\n    sortRef(sort) {\\n      if (!sort) return sort; // including id ensures stable sorting\\n\\n      const a = aggrField(sort.op, sort.field),\\n            o = sort.order || Ascending;\\n      return o.signal ? ref(this.add(Compare({\\n        fields: a,\\n        orders: this.signalRef(o.signal)\\n      }))) : compareRef(a, o);\\n    },\\n\\n    // ----\\n    event(source, type) {\\n      const key = source + ':' + type;\\n\\n      if (!this.events[key]) {\\n        const id = this.id();\\n        this.streams.push({\\n          id: id,\\n          source: source,\\n          type: type\\n        });\\n        this.events[key] = id;\\n      }\\n\\n      return this.events[key];\\n    },\\n\\n    // ----\\n    hasOwnSignal(name) {\\n      return vegaUtil.hasOwnProperty(this.signals, name);\\n    },\\n\\n    addSignal(name, value) {\\n      if (this.hasOwnSignal(name)) {\\n        vegaUtil.error('Duplicate signal name: ' + vegaUtil.stringValue(name));\\n      }\\n\\n      const op = value instanceof Entry ? value : this.add(operator(value));\\n      return this.signals[name] = op;\\n    },\\n\\n    getSignal(name) {\\n      if (!this.signals[name]) {\\n        vegaUtil.error('Unrecognized signal name: ' + vegaUtil.stringValue(name));\\n      }\\n\\n      return this.signals[name];\\n    },\\n\\n    signalRef(s) {\\n      if (this.signals[s]) {\\n        return ref(this.signals[s]);\\n      } else if (!vegaUtil.hasOwnProperty(this.lambdas, s)) {\\n        this.lambdas[s] = this.add(operator(null));\\n      }\\n\\n      return ref(this.lambdas[s]);\\n    },\\n\\n    parseLambdas() {\\n      const code = Object.keys(this.lambdas);\\n\\n      for (let i = 0, n = code.length; i < n; ++i) {\\n        const s = code[i],\\n              e = vegaFunctions.parseExpression(s, this),\\n              op = this.lambdas[s];\\n        op.params = e.$params;\\n        op.update = e.$expr;\\n      }\\n    },\\n\\n    property(spec) {\\n      return spec && spec.signal ? this.signalRef(spec.signal) : spec;\\n    },\\n\\n    objectProperty(spec) {\\n      return !spec || !vegaUtil.isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));\\n    },\\n\\n    exprRef(code, name) {\\n      const params = {\\n        expr: vegaFunctions.parseExpression(code, this)\\n      };\\n      if (name) params.expr.$name = name;\\n      return ref(this.add(Expression(params)));\\n    },\\n\\n    addBinding(name, bind) {\\n      if (!this.bindings) {\\n        vegaUtil.error('Nested signals do not support binding: ' + vegaUtil.stringValue(name));\\n      }\\n\\n      this.bindings.push(vegaUtil.extend({\\n        signal: name\\n      }, bind));\\n    },\\n\\n    // ----\\n    addScaleProj(name, transform) {\\n      if (vegaUtil.hasOwnProperty(this.scales, name)) {\\n        vegaUtil.error('Duplicate scale or projection name: ' + vegaUtil.stringValue(name));\\n      }\\n\\n      this.scales[name] = this.add(transform);\\n    },\\n\\n    addScale(name, params) {\\n      this.addScaleProj(name, Scale(params));\\n    },\\n\\n    addProjection(name, params) {\\n      this.addScaleProj(name, Projection(params));\\n    },\\n\\n    getScale(name) {\\n      if (!this.scales[name]) {\\n        vegaUtil.error('Unrecognized scale name: ' + vegaUtil.stringValue(name));\\n      }\\n\\n      return this.scales[name];\\n    },\\n\\n    scaleRef(name) {\\n      return ref(this.getScale(name));\\n    },\\n\\n    scaleType(name) {\\n      return this.getScale(name).params.type;\\n    },\\n\\n    projectionRef(name) {\\n      return this.scaleRef(name);\\n    },\\n\\n    projectionType(name) {\\n      return this.scaleType(name);\\n    },\\n\\n    // ----\\n    addData(name, dataScope) {\\n      if (vegaUtil.hasOwnProperty(this.data, name)) {\\n        vegaUtil.error('Duplicate data set name: ' + vegaUtil.stringValue(name));\\n      }\\n\\n      return this.data[name] = dataScope;\\n    },\\n\\n    getData(name) {\\n      if (!this.data[name]) {\\n        vegaUtil.error('Undefined data set name: ' + vegaUtil.stringValue(name));\\n      }\\n\\n      return this.data[name];\\n    },\\n\\n    addDataPipeline(name, entries) {\\n      if (vegaUtil.hasOwnProperty(this.data, name)) {\\n        vegaUtil.error('Duplicate data set name: ' + vegaUtil.stringValue(name));\\n      }\\n\\n      return this.addData(name, DataScope.fromEntries(this, entries));\\n    }\\n\\n  };\\n\\n  function propertyLambda(spec) {\\n    return (vegaUtil.isArray(spec) ? arrayLambda : objectLambda)(spec);\\n  }\\n\\n  function arrayLambda(array) {\\n    const n = array.length;\\n    let code = '[';\\n\\n    for (let i = 0; i < n; ++i) {\\n      const value = array[i];\\n      code += (i > 0 ? ',' : '') + (vegaUtil.isObject(value) ? value.signal || propertyLambda(value) : vegaUtil.stringValue(value));\\n    }\\n\\n    return code + ']';\\n  }\\n\\n  function objectLambda(obj) {\\n    let code = '{',\\n        i = 0,\\n        key,\\n        value;\\n\\n    for (key in obj) {\\n      value = obj[key];\\n      code += (++i > 1 ? ',' : '') + vegaUtil.stringValue(key) + ':' + (vegaUtil.isObject(value) ? value.signal || propertyLambda(value) : vegaUtil.stringValue(value));\\n    }\\n\\n    return code + '}';\\n  }\\n\\n  /**\\n   * Standard configuration defaults for Vega specification parsing.\\n   * Users can provide their own (sub-)set of these default values\\n   * by passing in a config object to the top-level parse method.\\n   */\\n  function defaults () {\\n    const defaultFont = 'sans-serif',\\n          defaultSymbolSize = 30,\\n          defaultStrokeWidth = 2,\\n          defaultColor = '#4c78a8',\\n          black = '#000',\\n          gray = '#888',\\n          lightGray = '#ddd';\\n    return {\\n      // default visualization description\\n      description: 'Vega visualization',\\n      // default padding around visualization\\n      padding: 0,\\n      // default for automatic sizing; options: 'none', 'pad', 'fit'\\n      // or provide an object (e.g., {'type': 'pad', 'resize': true})\\n      autosize: 'pad',\\n      // default view background color\\n      // covers the entire view component\\n      background: null,\\n      // default event handling configuration\\n      // preventDefault for view-sourced event types except 'wheel'\\n      events: {\\n        defaults: {\\n          allow: ['wheel']\\n        }\\n      },\\n      // defaults for top-level group marks\\n      // accepts mark properties (fill, stroke, etc)\\n      // covers the data rectangle within group width/height\\n      group: null,\\n      // defaults for basic mark types\\n      // each subset accepts mark properties (fill, stroke, etc)\\n      mark: null,\\n      arc: {\\n        fill: defaultColor\\n      },\\n      area: {\\n        fill: defaultColor\\n      },\\n      image: null,\\n      line: {\\n        stroke: defaultColor,\\n        strokeWidth: defaultStrokeWidth\\n      },\\n      path: {\\n        stroke: defaultColor\\n      },\\n      rect: {\\n        fill: defaultColor\\n      },\\n      rule: {\\n        stroke: black\\n      },\\n      shape: {\\n        stroke: defaultColor\\n      },\\n      symbol: {\\n        fill: defaultColor,\\n        size: 64\\n      },\\n      text: {\\n        fill: black,\\n        font: defaultFont,\\n        fontSize: 11\\n      },\\n      trail: {\\n        fill: defaultColor,\\n        size: defaultStrokeWidth\\n      },\\n      // style definitions\\n      style: {\\n        // axis & legend labels\\n        'guide-label': {\\n          fill: black,\\n          font: defaultFont,\\n          fontSize: 10\\n        },\\n        // axis & legend titles\\n        'guide-title': {\\n          fill: black,\\n          font: defaultFont,\\n          fontSize: 11,\\n          fontWeight: 'bold'\\n        },\\n        // headers, including chart title\\n        'group-title': {\\n          fill: black,\\n          font: defaultFont,\\n          fontSize: 13,\\n          fontWeight: 'bold'\\n        },\\n        // chart subtitle\\n        'group-subtitle': {\\n          fill: black,\\n          font: defaultFont,\\n          fontSize: 12\\n        },\\n        // defaults for styled point marks in Vega-Lite\\n        point: {\\n          size: defaultSymbolSize,\\n          strokeWidth: defaultStrokeWidth,\\n          shape: 'circle'\\n        },\\n        circle: {\\n          size: defaultSymbolSize,\\n          strokeWidth: defaultStrokeWidth\\n        },\\n        square: {\\n          size: defaultSymbolSize,\\n          strokeWidth: defaultStrokeWidth,\\n          shape: 'square'\\n        },\\n        // defaults for styled group marks in Vega-Lite\\n        cell: {\\n          fill: 'transparent',\\n          stroke: lightGray\\n        }\\n      },\\n      // defaults for title\\n      title: {\\n        orient: 'top',\\n        anchor: 'middle',\\n        offset: 4,\\n        subtitlePadding: 3\\n      },\\n      // defaults for axes\\n      axis: {\\n        minExtent: 0,\\n        maxExtent: 200,\\n        bandPosition: 0.5,\\n        domain: true,\\n        domainWidth: 1,\\n        domainColor: gray,\\n        grid: false,\\n        gridWidth: 1,\\n        gridColor: lightGray,\\n        labels: true,\\n        labelAngle: 0,\\n        labelLimit: 180,\\n        labelOffset: 0,\\n        labelPadding: 2,\\n        ticks: true,\\n        tickColor: gray,\\n        tickOffset: 0,\\n        tickRound: true,\\n        tickSize: 5,\\n        tickWidth: 1,\\n        titlePadding: 4\\n      },\\n      // correction for centering bias\\n      axisBand: {\\n        tickOffset: -0.5\\n      },\\n      // defaults for cartographic projection\\n      projection: {\\n        type: 'mercator'\\n      },\\n      // defaults for legends\\n      legend: {\\n        orient: 'right',\\n        padding: 0,\\n        gridAlign: 'each',\\n        columnPadding: 10,\\n        rowPadding: 2,\\n        symbolDirection: 'vertical',\\n        gradientDirection: 'vertical',\\n        gradientLength: 200,\\n        gradientThickness: 16,\\n        gradientStrokeColor: lightGray,\\n        gradientStrokeWidth: 0,\\n        gradientLabelOffset: 2,\\n        labelAlign: 'left',\\n        labelBaseline: 'middle',\\n        labelLimit: 160,\\n        labelOffset: 4,\\n        labelOverlap: true,\\n        symbolLimit: 30,\\n        symbolType: 'circle',\\n        symbolSize: 100,\\n        symbolOffset: 0,\\n        symbolStrokeWidth: 1.5,\\n        symbolBaseFillColor: 'transparent',\\n        symbolBaseStrokeColor: gray,\\n        titleLimit: 180,\\n        titleOrient: 'top',\\n        titlePadding: 5,\\n        layout: {\\n          offset: 18,\\n          direction: 'horizontal',\\n          left: {\\n            direction: 'vertical'\\n          },\\n          right: {\\n            direction: 'vertical'\\n          }\\n        }\\n      },\\n      // defaults for scale ranges\\n      range: {\\n        category: {\\n          scheme: 'tableau10'\\n        },\\n        ordinal: {\\n          scheme: 'blues'\\n        },\\n        heatmap: {\\n          scheme: 'yellowgreenblue'\\n        },\\n        ramp: {\\n          scheme: 'blues'\\n        },\\n        diverging: {\\n          scheme: 'blueorange',\\n          extent: [1, 0]\\n        },\\n        symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']\\n      }\\n    };\\n  }\\n\\n  function parse$1 (spec, config, options) {\\n    if (!vegaUtil.isObject(spec)) {\\n      vegaUtil.error('Input Vega specification must be an object.');\\n    }\\n\\n    config = vegaUtil.mergeConfig(defaults(), config, spec.config);\\n    return parseView(spec, new Scope$1(config, options)).toRuntime();\\n  }\\n\\n  exports.AxisDomainRole = AxisDomainRole;\\n  exports.AxisGridRole = AxisGridRole;\\n  exports.AxisLabelRole = AxisLabelRole;\\n  exports.AxisRole = AxisRole;\\n  exports.AxisTickRole = AxisTickRole;\\n  exports.AxisTitleRole = AxisTitleRole;\\n  exports.DataScope = DataScope;\\n  exports.FrameRole = FrameRole;\\n  exports.LegendEntryRole = LegendEntryRole;\\n  exports.LegendLabelRole = LegendLabelRole;\\n  exports.LegendRole = LegendRole;\\n  exports.LegendSymbolRole = LegendSymbolRole;\\n  exports.LegendTitleRole = LegendTitleRole;\\n  exports.MarkRole = MarkRole;\\n  exports.Scope = Scope$1;\\n  exports.ScopeRole = ScopeRole;\\n  exports.config = defaults;\\n  exports.parse = parse$1;\\n  exports.signal = parseSignal;\\n  exports.signalUpdates = parseSignalUpdates;\\n  exports.stream = parseStream;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"vegaUtil\",\"vegaFunctions\",\"vegaEventSelector\",\"vegaScale\",\"vegaDataflow\",\"parseAutosize\",\"spec\",\"isObject\",\"type\",\"parsePadding\",\"_\",\"top\",\"bottom\",\"left\",\"right\",\"addEncode\",\"object\",\"name\",\"value\",\"set\",\"isArray\",\"length\",\"update\",\"addEncoders\",\"enter\",\"extendEncode\",\"encode\",\"extra\",\"skip\",\"hasOwnProperty\",\"extend\",\"has\",\"key\",\"applyDefaults\",\"role\",\"style\",\"config\",\"defaults\",\"applyDefault\",\"String\",\"startsWith\",\"props\",\"FrameRole\",\"group\",\"MarkRole\",\"mark\",\"array\",\"forEach\",\"signal\",\"entry\",\"enc\",\"gradient\",\"c\",\"_color\",\"h\",\"l\",\"s\",\"a\",\"b\",\"r\",\"g\",\"scale\",\"scaleRef\",\"range\",\"undefined\",\"band\",\"property\",\"exponent\",\"mult\",\"offset\",\"round\",\"args\",\"start\",\"stop\",\"count\",\"map\",\"stringValue\",\"peek\",\"pop\",\"unshift\",\"join\",\"field\",\"ref\",\"resolveField\",\"datum\",\"parent\",\"level\",\"Math\",\"max\",\"error\",\"isString\",\"splitAccessPath\",\"rule\",\"code\",\"test\",\"parseEncode\",\"scope\",\"params\",\"encoders\",\"$encode\",\"channels\",\"fields\",\"block\",\"parse\",\"$expr\",\"marktype\",\"$fields\",\"Object\",\"keys\",\"$output\",\"expr\",\"parseExpression\",\"$params\",\"outerError\",\"prefix\",\"parseSignal\",\"OUTER\",\"push\",\"signals\",\"OUTER_INVALID\",\"prop\",\"op\",\"addSignal\",\"react\",\"bind\",\"addBinding\",\"Entry\",\"id\",\"$ref\",\"refs\",\"fieldRef\",\"$field\",\"$name\",\"keyRef\",\"flat\",\"$key\",\"$flat\",\"aggrField\",\"isSignal\",\"hasSignal\",\"specValue\",\"defaultValue\",\"deref\",\"v\",\"parseStream\",\"stream\",\"merge\",\"method\",\"mergeStream\",\"nestedStream\",\"eventStream\",\"list\",\"streamParameters\",\"addStream\",\"Timer\",\"event\",\"throttle\",\"between\",\"filter\",\"source\",\"Scope\",\"View\",\"param\",\"concat\",\"markname\",\"markrole\",\"item\",\"debounce\",\"consume\",\"parseUpdate\",\"target\",\"events\",\"sources\",\"selector\",\"isSubscope\",\"mergeSources\",\"OP_VALUE_EXPR\",\"$value\",\"signalRef\",\"force\",\"options\",\"addUpdate\",\"parseSignalUpdates\",\"getSignal\",\"init\",\"initonly\",\"on\",\"parseLiteral\",\"parseArray\",\"dataLookupError\",\"parseScaleDomain\",\"domain\",\"explicitDomain\",\"multipleDomain\",\"singularDomain\",\"domainMin\",\"domainMax\",\"data\",\"getData\",\"isDiscrete\",\"valuesRef\",\"parseSort\",\"sort\",\"isQuantile\",\"domainRef\",\"extentRef\",\"reduce\",\"dom\",\"d\",\"FIELD_REF_ID\",\"coll\",\"Collect\",\"$ingest\",\"input\",\"addDataPipeline\",\"Sieve\",\"ordinalMultipleDomain\",\"quantileMultipleDomain\",\"numericMultipleDomain\",\"counts\",\"f\",\"countsRef\",\"p\",\"groupby\",\"keyFieldRef\",\"pulse\",\"ops\",\"MULTIDOMAIN_SORT_OPS\",\"as\",\"add\",\"Aggregate\",\"Values\",\"sortRef\",\"multidomain\",\"values\",\"MultiValues\",\"extents\",\"MultiExtent\",\"parseScaleRange\",\"scheme\",\"extent\",\"schemeExtent\",\"schemeCount\",\"step\",\"rangeStep\",\"parseParameter\",\"guideGroup\",\"GroupMark\",\"interactive\",\"lookup\",\"dflt\",\"isVertical\",\"_.isVertical\",\"Vertical\",\"direction\",\"symbolDirection\",\"gradientDirection\",\"gradientLength\",\"_.gradientLength\",\"gradientWidth\",\"gradientThickness\",\"_.gradientThickness\",\"gradientHeight\",\"entryColumns\",\"_.entryColumns\",\"columns\",\"getEncoding\",\"anchorExpr\",\"e\",\"m\",\"Start\",\"End\",\"extendOffset\",\"assign\",\"guideMark\",\"extras\",\"Skip\",\"legendGradient\",\"userEncode\",\"vertical\",\"thickness\",\"width\",\"height\",\"opacity\",\"zero\",\"x\",\"y\",\"encoder\",\"one\",\"fill\",\"exit\",\"stroke\",\"strokeWidth\",\"RectMark\",\"LegendGradientRole\",\"legendGradientDiscrete\",\"dataRef\",\"u\",\"uu\",\"vv\",\"adjust\",\"Value\",\"LegendBandRole\",\"from\",\"legendGradientLabels\",\"overlap\",\"text\",\"Label\",\"fillOpacity\",\"font\",\"fontSize\",\"fontStyle\",\"fontWeight\",\"limit\",\"labelLimit\",\"gradientLabelLimit\",\"align\",\"baseline\",\"baselineExpr\",\"alignExpr$1\",\"labelOffset\",\"gradientLabelOffset\",\"separation\",\"order\",\"TextMark\",\"LegendLabelRole\",\"GuideLabelStyle\",\"legendSymbolGroups\",\"entries\",\"symbolOffset\",\"valueRef\",\"xSignal\",\"Offset\",\"Size\",\"yEncode\",\"ncols\",\"baseFill\",\"baseStroke\",\"symbolBaseFillColor\",\"symbolBaseStrokeColor\",\"shape\",\"size\",\"strokeDash\",\"strokeDashOffset\",\"LegendScales\",\"symbols\",\"SymbolMark\",\"LegendSymbolRole\",\"clip\",\"labels\",\"noBound\",\"row\",\"column\",\"nrows\",\"index\",\"facet\",\"Index\",\"ScopeRole\",\"marks\",\"legendSymbolLayout\",\"center\",\"padding\",\"legendTitle\",\"orient\",\"_anchor\",\"anchor\",\"exprAnchor\",\"angle\",\"exprAngle\",\"exprAlign\",\"exprBaseline\",\"title\",\"lineHeight\",\"LegendTitleRole\",\"GuideTitleStyle\",\"path\",\"sphere\",\"getRole\",\"indexOf\",\"definition\",\"zindex\",\"aria\",\"description\",\"parseTransform\",\"def\",\"toLowerCase\",\"parseParameters\",\"proxy\",\"t\",\"metadata\",\"n\",\"i\",\"pdef\",\"parseParameter$1\",\"parseIndexParameter\",\"required\",\"parseSubParameters\",\"projectionRef\",\"parameterValue\",\"compareRef\",\"exprRef\",\"lookupRef\",\"parseSubParameter\",\"k\",\"Params\",\"parseData\",\"getDataRef\",\"aggregate\",\"output\",\"DataScope\",\"aggr\",\"fieldKey\",\"addSortField\",\"cache\",\"ds\",\"optype\",\"Descending\",\"parseFacet\",\"PreFacet\",\"Facet\",\"subscope\",\"fork\",\"addData\",\"subflow\",\"$subflow\",\"toRuntime\",\"parseSubflow\",\"parseTrigger\",\"remove\",\"insert\",\"toggle\",\"modify\",\"trigger\",\"parseMark\",\"layout\",\"store\",\"layoutRef\",\"nested\",\"DataJoin\",\"clean\",\"joinRef\",\"Mark\",\"markdef\",\"context\",\"$context\",\"groups\",\"markpath\",\"markRef\",\"Encode\",\"mod\",\"transform\",\"tx\",\"md\",\"generates\",\"changes\",\"nomod\",\"SortItems\",\"encodeRef\",\"ViewLayout\",\"objectProperty\",\"legends\",\"bound\",\"Bound\",\"boundRef\",\"operators\",\"pushState\",\"popState\",\"parseOverlap\",\"render\",\"Render\",\"sieve\",\"sep\",\"tol\",\"tolerance\",\"boundTolerance\",\"boundScale\",\"boundOrient\",\"Overlap\",\"parseLegend\",\"legend\",\"legendEncode\",\"scales\",\"entryLayout\",\"legendType\",\"scaleType\",\"vgrad\",\"entryRef\",\"LegendEntries\",\"minstep\",\"tickMinStep\",\"formatType\",\"formatSpecifier\",\"format\",\"Gradient\",\"children\",\"Discrete\",\"sizeExpression\",\"LegendEntryRole\",\"entryEncode\",\"LegendRole\",\"buildLegendEncode\",\"Symbols\",\"scaleCount\",\"isContinuous\",\"isDiscretizing\",\"titlePadding\",\"cornerRadius\",\"getChannel\",\"parseTitle\",\"dx\",\"dy\",\"TitleTextRole\",\"GroupTitleStyle\",\"subtitle\",\"TitleSubtitleRole\",\"GroupSubtitleStyle\",\"alignExpr\",\"angleExpr\",\"frame\",\"TitleRole\",\"parseData$1\",\"transforms\",\"analyze\",\"generate\",\"upstream\",\"load\",\"collect\",\"$format\",\"url\",\"$request\",\"modifies\",\"Relay\",\"derive\",\"splice\",\"Load\",\"async\",\"fallback\",\"axisConfig\",\"styleProp\",\"slice\",\"objects\",\"obj\",\"flushExpr\",\"threshold\",\"autoLayout\",\"auto\",\"dim\",\"patch\",\"autoY\",\"autoX\",\"ifX\",\"parseScope\",\"preprocessed\",\"projections\",\"projection\",\"addProjection\",\"isValidScaleType\",\"addScale\",\"getScale\",\"interpolate\",\"gamma\",\"interpolateGamma\",\"nice\",\"interval\",\"bins\",\"axes\",\"axis\",\"axisBand\",\"xyKeys\",\"axisX\",\"axisY\",\"orientKeys\",\"axisTop\",\"axisBottom\",\"axisLeft\",\"axisRight\",\"xy\",\"or\",\"$orient\",\"Left\",\"toExpr\",\"Bottom\",\"Right\",\"Top\",\"toUpperCase\",\"result\",\"axisEncode\",\"ticks\",\"grid\",\"ticksRef\",\"AxisTicks\",\"tickCount\",\"vscale\",\"gridScale\",\"sign\",\"getSign\",\"strokeCap\",\"strokeOpacity\",\"tickPos\",\"sz\",\"gridStart\",\"gridEnd\",\"ifY\",\"x2\",\"y2\",\"RuleMark\",\"AxisGridRole\",\"tickSize\",\"AxisTickRole\",\"flush\",\"flushOffset\",\"labelAlign\",\"labelBaseline\",\"flushOn\",\"ifExpr\",\"ifTop\",\"offsetExpr\",\"AxisLabelRole\",\"pos0\",\"pos\",\"pos1\",\"AxisDomainRole\",\"titlePos\",\"AxisTitleRole\",\"position\",\"minExtent\",\"maxExtent\",\"translate\",\"AxisRole\",\"parseLambdas\",\"parseView\",\"root\",\"collectSignals\",\"eventConfig\",\"locale\",\"autosize\",\"signalObject\",\"pre\",\"Scope$1\",\"bindings\",\"lambdas\",\"streams\",\"updates\",\"_subid\",\"_id\",\"_nextsub\",\"_parent\",\"_encode\",\"_lookup\",\"_markpath\",\"Subscope\",\"create\",\"propertyLambda\",\"arrayLambda\",\"objectLambda\",\"background\",\"allow\",\"arc\",\"defaultColor\",\"area\",\"image\",\"line\",\"defaultStrokeWidth\",\"rect\",\"black\",\"symbol\",\"defaultFont\",\"trail\",\"point\",\"defaultSymbolSize\",\"circle\",\"square\",\"cell\",\"lightGray\",\"subtitlePadding\",\"bandPosition\",\"domainWidth\",\"domainColor\",\"gray\",\"gridWidth\",\"gridColor\",\"labelAngle\",\"labelPadding\",\"tickColor\",\"tickOffset\",\"tickRound\",\"tickWidth\",\"gridAlign\",\"columnPadding\",\"rowPadding\",\"gradientStrokeColor\",\"gradientStrokeWidth\",\"labelOverlap\",\"symbolLimit\",\"symbolType\",\"symbolSize\",\"symbolStrokeWidth\",\"titleLimit\",\"titleOrient\",\"category\",\"ordinal\",\"heatmap\",\"ramp\",\"diverging\",\"z\",\"ast\",\"Compare\",\"Expression\",\"Field\",\"Key\",\"Projection\",\"Proxy\",\"Scale\",\"min\",\"Center\",\"isR\",\"alignFlip\",\"isLR\",\"isL\",\"fromEntries\",\"DataScope.fromEntries\",\"prototype\",\"agg\",\"tuplesRef\",\"indataRef\",\"ifEnc\",\"base\",\"endsWith\",\"finish\",\"vref\",\"annotate\",\"cmp\",\"check\",\"orders\",\"$compare\",\"$order\",\"sig\",\"o\",\"Ascending\",\"hasOwnSignal\",\"addScaleProj\",\"projectionType\",\"dataScope\",\"parse$1\",\"mergeConfig\",\"signalUpdates\",\"defineProperty\"]\n}\n"]