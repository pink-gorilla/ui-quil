["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/layout-base/layout-base.js"],"~:js","shadow$provide.module$node_modules$layout_base$layout_base=function(global,require,module$jscomp$0,exports$jscomp$0){(function(root,factory){\"object\"===typeof exports$jscomp$0&&\"object\"===typeof module$jscomp$0?module$jscomp$0.exports=factory():\"function\"===typeof define&&define.amd?define([],factory):\"object\"===typeof exports$jscomp$0?exports$jscomp$0.layoutBase=factory():root.layoutBase=factory()})(this,function(){return function(modules){function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;\nvar module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);module.l=!0;return module.exports}var installedModules={};__webpack_require__.m=modules;__webpack_require__.c=installedModules;__webpack_require__.i=function(value){return value};__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{configurable:!1,enumerable:!0,get:getter})};__webpack_require__.n=\nfunction(module){var getter=module&&module.__esModule?function(){return module[\"default\"]}:function(){return module};__webpack_require__.d(getter,\"a\",getter);return getter};__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)};__webpack_require__.p=\"\";return __webpack_require__(__webpack_require__.s=26)}([function(module,exports,__webpack_require__){function LayoutConstants(){}LayoutConstants.QUALITY=1;LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED=\n!1;LayoutConstants.DEFAULT_INCREMENTAL=!1;LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT=!0;LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT=!1;LayoutConstants.DEFAULT_ANIMATION_PERIOD=50;LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES=!1;LayoutConstants.DEFAULT_GRAPH_MARGIN=15;LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS=!1;LayoutConstants.SIMPLE_NODE_SIZE=40;LayoutConstants.SIMPLE_NODE_HALF_SIZE=LayoutConstants.SIMPLE_NODE_SIZE/2;LayoutConstants.EMPTY_COMPOUND_NODE_SIZE=40;LayoutConstants.MIN_EDGE_LENGTH=\n1;LayoutConstants.WORLD_BOUNDARY=1E6;LayoutConstants.INITIAL_WORLD_BOUNDARY=LayoutConstants.WORLD_BOUNDARY/1E3;LayoutConstants.WORLD_CENTER_X=1200;LayoutConstants.WORLD_CENTER_Y=900;module.exports=LayoutConstants},function(module,exports,__webpack_require__){function LEdge(source,target,vEdge){LGraphObject.call(this,vEdge);this.isOverlapingSourceAndTarget=!1;this.vGraphObject=vEdge;this.bendpoints=[];this.source=source;this.target=target}var LGraphObject=__webpack_require__(2),IGeometry=__webpack_require__(8),\nIMath=__webpack_require__(9);LEdge.prototype=Object.create(LGraphObject.prototype);for(var prop in LGraphObject)LEdge[prop]=LGraphObject[prop];LEdge.prototype.getSource=function(){return this.source};LEdge.prototype.getTarget=function(){return this.target};LEdge.prototype.isInterGraph=function(){return this.isInterGraph};LEdge.prototype.getLength=function(){return this.length};LEdge.prototype.isOverlapingSourceAndTarget=function(){return this.isOverlapingSourceAndTarget};LEdge.prototype.getBendpoints=\nfunction(){return this.bendpoints};LEdge.prototype.getLca=function(){return this.lca};LEdge.prototype.getSourceInLca=function(){return this.sourceInLca};LEdge.prototype.getTargetInLca=function(){return this.targetInLca};LEdge.prototype.getOtherEnd=function(node){if(this.source===node)return this.target;if(this.target===node)return this.source;throw\"Node is not incident with this edge\";};LEdge.prototype.getOtherEndInGraph=function(node,graph){node=this.getOtherEnd(node);for(var root=graph.getGraphManager().getRoot();;){if(node.getOwner()==\ngraph)return node;if(node.getOwner()==root)break;node=node.getOwner().getParent()}return null};LEdge.prototype.updateLength=function(){var clipPointCoordinates=Array(4);this.isOverlapingSourceAndTarget=IGeometry.getIntersection(this.target.getRect(),this.source.getRect(),clipPointCoordinates);this.isOverlapingSourceAndTarget||(this.lengthX=clipPointCoordinates[0]-clipPointCoordinates[2],this.lengthY=clipPointCoordinates[1]-clipPointCoordinates[3],1>Math.abs(this.lengthX)&&(this.lengthX=IMath.sign(this.lengthX)),\n1>Math.abs(this.lengthY)&&(this.lengthY=IMath.sign(this.lengthY)),this.length=Math.sqrt(this.lengthX*this.lengthX+this.lengthY*this.lengthY))};LEdge.prototype.updateLengthSimple=function(){this.lengthX=this.target.getCenterX()-this.source.getCenterX();this.lengthY=this.target.getCenterY()-this.source.getCenterY();1>Math.abs(this.lengthX)&&(this.lengthX=IMath.sign(this.lengthX));1>Math.abs(this.lengthY)&&(this.lengthY=IMath.sign(this.lengthY));this.length=Math.sqrt(this.lengthX*this.lengthX+this.lengthY*\nthis.lengthY)};module.exports=LEdge},function(module,exports,__webpack_require__){module.exports=function(vGraphObject){this.vGraphObject=vGraphObject}},function(module,exports,__webpack_require__){function LNode(gm,loc,size,vNode){null==size&&null==vNode&&(vNode=loc);LGraphObject.call(this,vNode);null!=gm.graphManager&&(gm=gm.graphManager);this.estimatedSize=Integer.MIN_VALUE;this.inclusionTreeDepth=Integer.MAX_VALUE;this.vGraphObject=vNode;this.edges=[];this.graphManager=gm;this.rect=null!=size&&\nnull!=loc?new RectangleD(loc.x,loc.y,size.width,size.height):new RectangleD}var LGraphObject=__webpack_require__(2),Integer=__webpack_require__(10),RectangleD=__webpack_require__(13),LayoutConstants=__webpack_require__(0),RandomSeed=__webpack_require__(16),PointD=__webpack_require__(4);LNode.prototype=Object.create(LGraphObject.prototype);for(var prop in LGraphObject)LNode[prop]=LGraphObject[prop];LNode.prototype.getEdges=function(){return this.edges};LNode.prototype.getChild=function(){return this.child};\nLNode.prototype.getOwner=function(){return this.owner};LNode.prototype.getWidth=function(){return this.rect.width};LNode.prototype.setWidth=function(width){this.rect.width=width};LNode.prototype.getHeight=function(){return this.rect.height};LNode.prototype.setHeight=function(height){this.rect.height=height};LNode.prototype.getCenterX=function(){return this.rect.x+this.rect.width/2};LNode.prototype.getCenterY=function(){return this.rect.y+this.rect.height/2};LNode.prototype.getCenter=function(){return new PointD(this.rect.x+\nthis.rect.width/2,this.rect.y+this.rect.height/2)};LNode.prototype.getLocation=function(){return new PointD(this.rect.x,this.rect.y)};LNode.prototype.getRect=function(){return this.rect};LNode.prototype.getDiagonal=function(){return Math.sqrt(this.rect.width*this.rect.width+this.rect.height*this.rect.height)};LNode.prototype.getHalfTheDiagonal=function(){return Math.sqrt(this.rect.height*this.rect.height+this.rect.width*this.rect.width)/2};LNode.prototype.setRect=function(upperLeft,dimension){this.rect.x=\nupperLeft.x;this.rect.y=upperLeft.y;this.rect.width=dimension.width;this.rect.height=dimension.height};LNode.prototype.setCenter=function(cx,cy){this.rect.x=cx-this.rect.width/2;this.rect.y=cy-this.rect.height/2};LNode.prototype.setLocation=function(x,y){this.rect.x=x;this.rect.y=y};LNode.prototype.moveBy=function(dx,dy){this.rect.x+=dx;this.rect.y+=dy};LNode.prototype.getEdgeListToNode=function(to){var edgeList=[],self=this;self.edges.forEach(function(edge){if(edge.target==to){if(edge.source!=self)throw\"Incorrect edge source!\";\nedgeList.push(edge)}});return edgeList};LNode.prototype.getEdgesBetween=function(other){var edgeList=[],self=this;self.edges.forEach(function(edge){if(edge.source!=self&&edge.target!=self)throw\"Incorrect edge source and/or target\";edge.target!=other&&edge.source!=other||edgeList.push(edge)});return edgeList};LNode.prototype.getNeighborsList=function(){var neighbors=new Set,self=this;self.edges.forEach(function(edge){if(edge.source==self)neighbors.add(edge.target);else{if(edge.target!=self)throw\"Incorrect incidency!\";\nneighbors.add(edge.source)}});return neighbors};LNode.prototype.withChildren=function(){var withNeighborsList=new Set;withNeighborsList.add(this);if(null!=this.child)for(var nodes=this.child.getNodes(),i=0;i<nodes.length;i++){var childNode=nodes[i];childNode=childNode.withChildren();childNode.forEach(function(node){withNeighborsList.add(node)})}return withNeighborsList};LNode.prototype.getNoOfChildren=function(){var noOfChildren=0;if(null==this.child)noOfChildren=1;else for(var nodes=this.child.getNodes(),\ni=0;i<nodes.length;i++){var childNode=nodes[i];noOfChildren+=childNode.getNoOfChildren()}0==noOfChildren&&(noOfChildren=1);return noOfChildren};LNode.prototype.getEstimatedSize=function(){if(this.estimatedSize==Integer.MIN_VALUE)throw\"assert failed\";return this.estimatedSize};LNode.prototype.calcEstimatedSize=function(){if(null==this.child)return this.estimatedSize=(this.rect.width+this.rect.height)/2;this.estimatedSize=this.child.calcEstimatedSize();this.rect.width=this.estimatedSize;return this.rect.height=\nthis.estimatedSize};LNode.prototype.scatter=function(){var randomCenterX=-LayoutConstants.INITIAL_WORLD_BOUNDARY;var randomCenterY=LayoutConstants.INITIAL_WORLD_BOUNDARY;randomCenterX=LayoutConstants.WORLD_CENTER_X+RandomSeed.nextDouble()*(randomCenterY-randomCenterX)+randomCenterX;randomCenterY=-LayoutConstants.INITIAL_WORLD_BOUNDARY;var maxY=LayoutConstants.INITIAL_WORLD_BOUNDARY;randomCenterY=LayoutConstants.WORLD_CENTER_Y+RandomSeed.nextDouble()*(maxY-randomCenterY)+randomCenterY;this.rect.x=\nrandomCenterX;this.rect.y=randomCenterY};LNode.prototype.updateBounds=function(){if(null==this.getChild())throw\"assert failed\";if(0!=this.getChild().getNodes().length){var childGraph=this.getChild();childGraph.updateBounds(!0);this.rect.x=childGraph.getLeft();this.rect.y=childGraph.getTop();this.setWidth(childGraph.getRight()-childGraph.getLeft());this.setHeight(childGraph.getBottom()-childGraph.getTop());if(LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS){var width=childGraph.getRight()-childGraph.getLeft();\nchildGraph=childGraph.getBottom()-childGraph.getTop();this.labelWidth>width&&(this.rect.x-=(this.labelWidth-width)/2,this.setWidth(this.labelWidth));this.labelHeight>childGraph&&(\"center\"==this.labelPos?this.rect.y-=(this.labelHeight-childGraph)/2:\"top\"==this.labelPos&&(this.rect.y-=this.labelHeight-childGraph),this.setHeight(this.labelHeight))}}};LNode.prototype.getInclusionTreeDepth=function(){if(this.inclusionTreeDepth==Integer.MAX_VALUE)throw\"assert failed\";return this.inclusionTreeDepth};LNode.prototype.transform=\nfunction(trans){var left=this.rect.x;left>LayoutConstants.WORLD_BOUNDARY?left=LayoutConstants.WORLD_BOUNDARY:left<-LayoutConstants.WORLD_BOUNDARY&&(left=-LayoutConstants.WORLD_BOUNDARY);var top=this.rect.y;top>LayoutConstants.WORLD_BOUNDARY?top=LayoutConstants.WORLD_BOUNDARY:top<-LayoutConstants.WORLD_BOUNDARY&&(top=-LayoutConstants.WORLD_BOUNDARY);left=new PointD(left,top);trans=trans.inverseTransformPoint(left);this.setLocation(trans.x,trans.y)};LNode.prototype.getLeft=function(){return this.rect.x};\nLNode.prototype.getRight=function(){return this.rect.x+this.rect.width};LNode.prototype.getTop=function(){return this.rect.y};LNode.prototype.getBottom=function(){return this.rect.y+this.rect.height};LNode.prototype.getParent=function(){return null==this.owner?null:this.owner.getParent()};module.exports=LNode},function(module,exports,__webpack_require__){function PointD(x,y){null==x&&null==y?this.y=this.x=0:(this.x=x,this.y=y)}PointD.prototype.getX=function(){return this.x};PointD.prototype.getY=\nfunction(){return this.y};PointD.prototype.setX=function(x){this.x=x};PointD.prototype.setY=function(y){this.y=y};PointD.prototype.getDifference=function(pt){return new DimensionD(this.x-pt.x,this.y-pt.y)};PointD.prototype.getCopy=function(){return new PointD(this.x,this.y)};PointD.prototype.translate=function(dim){this.x+=dim.width;this.y+=dim.height;return this};module.exports=PointD},function(module,exports,__webpack_require__){function LGraph(parent,obj2,vGraph){LGraphObject.call(this,vGraph);\nthis.estimatedSize=Integer.MIN_VALUE;this.margin=LayoutConstants.DEFAULT_GRAPH_MARGIN;this.edges=[];this.nodes=[];this.isConnected=!1;this.parent=parent;null!=obj2&&obj2 instanceof LGraphManager?this.graphManager=obj2:null!=obj2&&obj2 instanceof Layout&&(this.graphManager=obj2.graphManager)}var LGraphObject=__webpack_require__(2),Integer=__webpack_require__(10),LayoutConstants=__webpack_require__(0),LGraphManager=__webpack_require__(6),LNode=__webpack_require__(3),LEdge=__webpack_require__(1),RectangleD=\n__webpack_require__(13),Point=__webpack_require__(12),LinkedList=__webpack_require__(11);LGraph.prototype=Object.create(LGraphObject.prototype);for(var prop in LGraphObject)LGraph[prop]=LGraphObject[prop];LGraph.prototype.getNodes=function(){return this.nodes};LGraph.prototype.getEdges=function(){return this.edges};LGraph.prototype.getGraphManager=function(){return this.graphManager};LGraph.prototype.getParent=function(){return this.parent};LGraph.prototype.getLeft=function(){return this.left};LGraph.prototype.getRight=\nfunction(){return this.right};LGraph.prototype.getTop=function(){return this.top};LGraph.prototype.getBottom=function(){return this.bottom};LGraph.prototype.isConnected=function(){return this.isConnected};LGraph.prototype.add=function(obj1,sourceNode,targetNode){if(null==sourceNode&&null==targetNode){if(null==this.graphManager)throw\"Graph has no graph mgr!\";if(-1<this.getNodes().indexOf(obj1))throw\"Node already in graph!\";obj1.owner=this;this.getNodes().push(obj1)}else{if(!(-1<this.getNodes().indexOf(sourceNode)&&\n-1<this.getNodes().indexOf(targetNode)))throw\"Source or target not in graph!\";if(sourceNode.owner!=targetNode.owner||sourceNode.owner!=this)throw\"Both owners must be this graph!\";if(sourceNode.owner!=targetNode.owner)return null;obj1.source=sourceNode;obj1.target=targetNode;obj1.isInterGraph=!1;this.getEdges().push(obj1);sourceNode.edges.push(obj1);targetNode!=sourceNode&&targetNode.edges.push(obj1)}return obj1};LGraph.prototype.remove=function(obj){if(obj instanceof LNode){if(null==obj)throw\"Node is null!\";\nif(null==obj.owner||obj.owner!=this)throw\"Owner graph is invalid!\";if(null==this.graphManager)throw\"Owner graph manager is invalid!\";for(var edgesToBeRemoved=obj.edges.slice(),edge,s=edgesToBeRemoved.length,i=0;i<s;i++)edge=edgesToBeRemoved[i],edge.isInterGraph?this.graphManager.remove(edge):edge.source.owner.remove(edge);obj=this.nodes.indexOf(obj);if(-1==obj)throw\"Node not in owner node list!\";this.nodes.splice(obj,1)}else if(obj instanceof LEdge){edge=obj;if(null==edge)throw\"Edge is null!\";if(null==\nedge.source||null==edge.target)throw\"Source and/or target is null!\";if(null==edge.source.owner||null==edge.target.owner||edge.source.owner!=this||edge.target.owner!=this)throw\"Source and/or target owner is invalid!\";obj=edge.source.edges.indexOf(edge);edgesToBeRemoved=edge.target.edges.indexOf(edge);if(!(-1<obj&&-1<edgesToBeRemoved))throw\"Source and/or target doesn't know this edge!\";edge.source.edges.splice(obj,1);edge.target!=edge.source&&edge.target.edges.splice(edgesToBeRemoved,1);obj=edge.source.owner.getEdges().indexOf(edge);\nif(-1==obj)throw\"Not in owner's edge list!\";edge.source.owner.getEdges().splice(obj,1)}};LGraph.prototype.updateLeftTop=function(){for(var top=Integer.MAX_VALUE,left=Integer.MAX_VALUE,nodeTop,nodeLeft,nodes=this.getNodes(),s=nodes.length,i=0;i<s;i++)nodeLeft=nodes[i],nodeTop=nodeLeft.getTop(),nodeLeft=nodeLeft.getLeft(),top>nodeTop&&(top=nodeTop),left>nodeLeft&&(left=nodeLeft);if(top==Integer.MAX_VALUE)return null;nodeTop=void 0!=nodes[0].getParent().paddingLeft?nodes[0].getParent().paddingLeft:this.margin;\nthis.left=left-nodeTop;this.top=top-nodeTop;return new Point(this.left,this.top)};LGraph.prototype.updateBounds=function(recursive){for(var left=Integer.MAX_VALUE,right=-Integer.MAX_VALUE,top=Integer.MAX_VALUE,bottom=-Integer.MAX_VALUE,nodeLeft,nodeRight,nodeTop,nodeBottom,nodes=this.nodes,s=nodes.length,i=0;i<s;i++)nodeBottom=nodes[i],recursive&&null!=nodeBottom.child&&nodeBottom.updateBounds(),nodeLeft=nodeBottom.getLeft(),nodeRight=nodeBottom.getRight(),nodeTop=nodeBottom.getTop(),nodeBottom=nodeBottom.getBottom(),\nleft>nodeLeft&&(left=nodeLeft),right<nodeRight&&(right=nodeRight),top>nodeTop&&(top=nodeTop),bottom<nodeBottom&&(bottom=nodeBottom);recursive=new RectangleD(left,top,right-left,bottom-top);left==Integer.MAX_VALUE&&(this.left=this.parent.getLeft(),this.right=this.parent.getRight(),this.top=this.parent.getTop(),this.bottom=this.parent.getBottom());left=void 0!=nodes[0].getParent().paddingLeft?nodes[0].getParent().paddingLeft:this.margin;this.left=recursive.x-left;this.right=recursive.x+recursive.width+\nleft;this.top=recursive.y-left;this.bottom=recursive.y+recursive.height+left};LGraph.calculateBounds=function(nodes){for(var left=Integer.MAX_VALUE,right=-Integer.MAX_VALUE,top=Integer.MAX_VALUE,bottom=-Integer.MAX_VALUE,nodeLeft,nodeRight,nodeTop,nodeBottom,s=nodes.length,i=0;i<s;i++)nodeBottom=nodes[i],nodeLeft=nodeBottom.getLeft(),nodeRight=nodeBottom.getRight(),nodeTop=nodeBottom.getTop(),nodeBottom=nodeBottom.getBottom(),left>nodeLeft&&(left=nodeLeft),right<nodeRight&&(right=nodeRight),top>nodeTop&&\n(top=nodeTop),bottom<nodeBottom&&(bottom=nodeBottom);return new RectangleD(left,top,right-left,bottom-top)};LGraph.prototype.getInclusionTreeDepth=function(){return this==this.graphManager.getRoot()?1:this.parent.getInclusionTreeDepth()};LGraph.prototype.getEstimatedSize=function(){if(this.estimatedSize==Integer.MIN_VALUE)throw\"assert failed\";return this.estimatedSize};LGraph.prototype.calcEstimatedSize=function(){for(var size=0,nodes=this.nodes,s=nodes.length,i=0;i<s;i++)size+=nodes[i].calcEstimatedSize();\nreturn this.estimatedSize=0==size?LayoutConstants.EMPTY_COMPOUND_NODE_SIZE:size/Math.sqrt(this.nodes.length)};LGraph.prototype.updateConnected=function(){var self=this;if(0==this.nodes.length)this.isConnected=!0;else{var queue=new LinkedList,visited=new Set,currentNode=this.nodes[0];for(currentNode.withChildren().forEach(function(node){queue.push(node);visited.add(node)});0!==queue.length;){currentNode=queue.shift();var neighborEdges=currentNode.getEdges();for(var size=neighborEdges.length,i=0;i<\nsize;i++){var currentNeighbor=neighborEdges[i].getOtherEndInGraph(currentNode,this);null==currentNeighbor||visited.has(currentNeighbor)||currentNeighbor.withChildren().forEach(function(node){queue.push(node);visited.add(node)})}}this.isConnected=!1;if(visited.size>=this.nodes.length){var noOfVisitedInThisGraph=0;visited.forEach(function(visitedNode){visitedNode.owner==self&&noOfVisitedInThisGraph++});noOfVisitedInThisGraph==this.nodes.length&&(this.isConnected=!0)}}};module.exports=LGraph},function(module,\nexports,__webpack_require__){function LGraphManager(layout){LGraph=__webpack_require__(5);this.layout=layout;this.graphs=[];this.edges=[]}var LGraph,LEdge=__webpack_require__(1);LGraphManager.prototype.addRoot=function(){var ngraph=this.layout.newGraph(),nnode=this.layout.newNode(null);ngraph=this.add(ngraph,nnode);this.setRootGraph(ngraph);return this.rootGraph};LGraphManager.prototype.add=function(newGraph,parentNode,newEdge,sourceNode,targetNode){if(null==newEdge&&null==sourceNode&&null==targetNode){if(null==\nnewGraph)throw\"Graph is null!\";if(null==parentNode)throw\"Parent node is null!\";if(-1<this.graphs.indexOf(newGraph))throw\"Graph already in this graph mgr!\";this.graphs.push(newGraph);if(null!=newGraph.parent)throw\"Already has a parent!\";if(null!=parentNode.child)throw\"Already has a child!\";newGraph.parent=parentNode;return parentNode.child=newGraph}targetNode=newEdge;sourceNode=parentNode;newEdge=newGraph;newGraph=sourceNode.getOwner();parentNode=targetNode.getOwner();if(null==newGraph||newGraph.getGraphManager()!=\nthis)throw\"Source not in this graph mgr!\";if(null==parentNode||parentNode.getGraphManager()!=this)throw\"Target not in this graph mgr!\";if(newGraph==parentNode)return newEdge.isInterGraph=!1,newGraph.add(newEdge,sourceNode,targetNode);newEdge.isInterGraph=!0;newEdge.source=sourceNode;newEdge.target=targetNode;if(-1<this.edges.indexOf(newEdge))throw\"Edge already in inter-graph edge list!\";this.edges.push(newEdge);if(null==newEdge.source||null==newEdge.target)throw\"Edge source and/or target is null!\";\nif(-1!=newEdge.source.edges.indexOf(newEdge)||-1!=newEdge.target.edges.indexOf(newEdge))throw\"Edge already in source and/or target incidency list!\";newEdge.source.edges.push(newEdge);newEdge.target.edges.push(newEdge);return newEdge};LGraphManager.prototype.remove=function(lObj){if(lObj instanceof LGraph){if(lObj.getGraphManager()!=this)throw\"Graph not in this graph mgr\";if(lObj!=this.rootGraph&&(null==lObj.parent||lObj.parent.graphManager!=this))throw\"Invalid parent node!\";var edgesToBeRemoved=[];\nedgesToBeRemoved=edgesToBeRemoved.concat(lObj.getEdges());for(var edge,s=edgesToBeRemoved.length,i=0;i<s;i++)edge=edgesToBeRemoved[i],lObj.remove(edge);edge=[];edge=edge.concat(lObj.getNodes());s=edge.length;for(i=0;i<s;i++)edgesToBeRemoved=edge[i],lObj.remove(edgesToBeRemoved);lObj==this.rootGraph&&this.setRootGraph(null);s=this.graphs.indexOf(lObj);this.graphs.splice(s,1);lObj.parent=null}else if(lObj instanceof LEdge){edge=lObj;if(null==edge)throw\"Edge is null!\";if(!edge.isInterGraph)throw\"Not an inter-graph edge!\";\nif(null==edge.source||null==edge.target)throw\"Source and/or target is null!\";if(-1==edge.source.edges.indexOf(edge)||-1==edge.target.edges.indexOf(edge))throw\"Source and/or target doesn't know this edge!\";s=edge.source.edges.indexOf(edge);edge.source.edges.splice(s,1);s=edge.target.edges.indexOf(edge);edge.target.edges.splice(s,1);if(null==edge.source.owner||null==edge.source.owner.getGraphManager())throw\"Edge owner graph or owner graph manager is null!\";if(-1==edge.source.owner.getGraphManager().edges.indexOf(edge))throw\"Not in owner graph manager's edge list!\";\ns=edge.source.owner.getGraphManager().edges.indexOf(edge);edge.source.owner.getGraphManager().edges.splice(s,1)}};LGraphManager.prototype.updateBounds=function(){this.rootGraph.updateBounds(!0)};LGraphManager.prototype.getGraphs=function(){return this.graphs};LGraphManager.prototype.getAllNodes=function(){if(null==this.allNodes){for(var nodeList=[],graphs=this.getGraphs(),s=graphs.length,i=0;i<s;i++)nodeList=nodeList.concat(graphs[i].getNodes());this.allNodes=nodeList}return this.allNodes};LGraphManager.prototype.resetAllNodes=\nfunction(){this.allNodes=null};LGraphManager.prototype.resetAllEdges=function(){this.allEdges=null};LGraphManager.prototype.resetAllNodesToApplyGravitation=function(){this.allNodesToApplyGravitation=null};LGraphManager.prototype.getAllEdges=function(){if(null==this.allEdges){for(var edgeList=[],graphs=this.getGraphs(),i=0;i<graphs.length;i++)edgeList=edgeList.concat(graphs[i].getEdges());this.allEdges=edgeList=edgeList.concat(this.edges)}return this.allEdges};LGraphManager.prototype.getAllNodesToApplyGravitation=\nfunction(){return this.allNodesToApplyGravitation};LGraphManager.prototype.setAllNodesToApplyGravitation=function(nodeList){if(null!=this.allNodesToApplyGravitation)throw\"assert failed\";this.allNodesToApplyGravitation=nodeList};LGraphManager.prototype.getRoot=function(){return this.rootGraph};LGraphManager.prototype.setRootGraph=function(graph){if(graph.getGraphManager()!=this)throw\"Root not in this graph mgr!\";this.rootGraph=graph;null==graph.parent&&(graph.parent=this.layout.newNode(\"Root node\"))};\nLGraphManager.prototype.getLayout=function(){return this.layout};LGraphManager.prototype.isOneAncestorOfOther=function(firstNode,secondNode){if(null==firstNode||null==secondNode)throw\"assert failed\";if(firstNode==secondNode)return!0;var ownerGraph=firstNode.getOwner();do{ownerGraph=ownerGraph.getParent();if(null==ownerGraph)break;if(ownerGraph==secondNode)return!0;ownerGraph=ownerGraph.getOwner();if(null==ownerGraph)break}while(1);ownerGraph=secondNode.getOwner();do{ownerGraph=ownerGraph.getParent();\nif(null==ownerGraph)break;if(ownerGraph==firstNode)return!0;ownerGraph=ownerGraph.getOwner();if(null==ownerGraph)break}while(1);return!1};LGraphManager.prototype.calcLowestCommonAncestors=function(){for(var edge,sourceNode,targetNode,targetAncestorGraph,edges=this.getAllEdges(),s=edges.length,i=0;i<s;i++)if(edge=edges[i],sourceNode=edge.source,targetNode=edge.target,edge.lca=null,edge.sourceInLca=sourceNode,edge.targetInLca=targetNode,sourceNode==targetNode)edge.lca=sourceNode.getOwner();else{for(sourceNode=\nsourceNode.getOwner();null==edge.lca;){edge.targetInLca=targetNode;for(targetAncestorGraph=targetNode.getOwner();null==edge.lca;){if(targetAncestorGraph==sourceNode){edge.lca=targetAncestorGraph;break}if(targetAncestorGraph==this.rootGraph)break;if(null!=edge.lca)throw\"assert failed\";edge.targetInLca=targetAncestorGraph.getParent();targetAncestorGraph=edge.targetInLca.getOwner()}if(sourceNode==this.rootGraph)break;null==edge.lca&&(edge.sourceInLca=sourceNode.getParent(),sourceNode=edge.sourceInLca.getOwner())}if(null==\nedge.lca)throw\"assert failed\";}};LGraphManager.prototype.calcLowestCommonAncestor=function(firstNode,secondNode){if(firstNode==secondNode)return firstNode.getOwner();firstNode=firstNode.getOwner();do{if(null==firstNode)break;var secondOwnerGraph=secondNode.getOwner();do{if(null==secondOwnerGraph)break;if(secondOwnerGraph==firstNode)return secondOwnerGraph;secondOwnerGraph=secondOwnerGraph.getParent().getOwner()}while(1);firstNode=firstNode.getParent().getOwner()}while(1);return firstNode};LGraphManager.prototype.calcInclusionTreeDepths=\nfunction(graph,depth){null==graph&&null==depth&&(graph=this.rootGraph,depth=1);for(var nodes=graph.getNodes(),s=nodes.length,i=0;i<s;i++)graph=nodes[i],graph.inclusionTreeDepth=depth,null!=graph.child&&this.calcInclusionTreeDepths(graph.child,depth+1)};LGraphManager.prototype.includesInvalidEdge=function(){for(var edge,s=this.edges.length,i=0;i<s;i++)if(edge=this.edges[i],this.isOneAncestorOfOther(edge.source,edge.target))return!0;return!1};module.exports=LGraphManager},function(module,exports,__webpack_require__){function FDLayoutConstants(){}\nexports=__webpack_require__(0);for(var prop in exports)FDLayoutConstants[prop]=exports[prop];FDLayoutConstants.MAX_ITERATIONS=2500;FDLayoutConstants.DEFAULT_EDGE_LENGTH=50;FDLayoutConstants.DEFAULT_SPRING_STRENGTH=.45;FDLayoutConstants.DEFAULT_REPULSION_STRENGTH=4500;FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH=.4;FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH=1;FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR=3.8;FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR=1.5;FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION=\n!0;FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION=!0;FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL=.3;FDLayoutConstants.COOLING_ADAPTATION_FACTOR=.33;FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT=1E3;FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT=5E3;FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL=100;FDLayoutConstants.MAX_NODE_DISPLACEMENT=3*FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;FDLayoutConstants.MIN_REPULSION_DIST=FDLayoutConstants.DEFAULT_EDGE_LENGTH/10;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD=100;FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR=.1;FDLayoutConstants.MIN_EDGE_LENGTH=1;FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD=10;module.exports=FDLayoutConstants},function(module,exports,__webpack_require__){function IGeometry(){}var Point=__webpack_require__(12);IGeometry.calcSeparationAmount=function(rectA,rectB,overlapAmount,separationBuffer){if(!rectA.intersects(rectB))throw\"assert failed\";var directions=Array(2);this.decideDirectionsForOverlappingNodes(rectA,\nrectB,directions);overlapAmount[0]=Math.min(rectA.getRight(),rectB.getRight())-Math.max(rectA.x,rectB.x);overlapAmount[1]=Math.min(rectA.getBottom(),rectB.getBottom())-Math.max(rectA.y,rectB.y);rectA.getX()<=rectB.getX()&&rectA.getRight()>=rectB.getRight()?overlapAmount[0]+=Math.min(rectB.getX()-rectA.getX(),rectA.getRight()-rectB.getRight()):rectB.getX()<=rectA.getX()&&rectB.getRight()>=rectA.getRight()&&(overlapAmount[0]+=Math.min(rectA.getX()-rectB.getX(),rectB.getRight()-rectA.getRight()));rectA.getY()<=\nrectB.getY()&&rectA.getBottom()>=rectB.getBottom()?overlapAmount[1]+=Math.min(rectB.getY()-rectA.getY(),rectA.getBottom()-rectB.getBottom()):rectB.getY()<=rectA.getY()&&rectB.getBottom()>=rectA.getBottom()&&(overlapAmount[1]+=Math.min(rectA.getY()-rectB.getY(),rectB.getBottom()-rectA.getBottom()));var slope=Math.abs((rectB.getCenterY()-rectA.getCenterY())/(rectB.getCenterX()-rectA.getCenterX()));rectB.getCenterY()===rectA.getCenterY()&&rectB.getCenterX()===rectA.getCenterX()&&(slope=1);rectA=slope*\noverlapAmount[0];slope=overlapAmount[1]/slope;overlapAmount[0]<slope?slope=overlapAmount[0]:rectA=overlapAmount[1];overlapAmount[0]=-1*directions[0]*(slope/2+separationBuffer);overlapAmount[1]=-1*directions[1]*(rectA/2+separationBuffer)};IGeometry.decideDirectionsForOverlappingNodes=function(rectA,rectB,directions){rectA.getCenterX()<rectB.getCenterX()?directions[0]=-1:directions[0]=1;rectA.getCenterY()<rectB.getCenterY()?directions[1]=-1:directions[1]=1};IGeometry.getIntersection2=function(rectA,\nrectB,result){var p1x=rectA.getCenterX(),p1y=rectA.getCenterY(),p2x=rectB.getCenterX(),p2y=rectB.getCenterY();if(rectA.intersects(rectB))return result[0]=p1x,result[1]=p1y,result[2]=p2x,result[3]=p2y,!0;var topLeftAx=rectA.getX(),topLeftAy=rectA.getY(),topRightAx=rectA.getRight(),bottomLeftAx=rectA.getX(),bottomLeftAy=rectA.getBottom(),bottomRightAx=rectA.getRight(),halfWidthA=rectA.getWidthHalf(),halfHeightA=rectA.getHeightHalf(),topLeftBx=rectB.getX(),topLeftBy=rectB.getY(),topRightBx=rectB.getRight(),\nbottomLeftBx=rectB.getX(),bottomLeftBy=rectB.getBottom(),bottomRightBx=rectB.getRight(),halfWidthB=rectB.getWidthHalf(),halfHeightB=rectB.getHeightHalf(),clipPointAFound=!1,clipPointBFound=!1;if(p1x===p2x)p1y>p2y?(result[0]=p1x,result[1]=topLeftAy,result[2]=p2x,result[3]=bottomLeftBy):p1y<p2y&&(result[0]=p1x,result[1]=bottomLeftAy,result[2]=p2x,result[3]=topLeftBy);else if(p1y===p2y)p1x>p2x?(result[0]=topLeftAx,result[1]=p1y,result[2]=topRightBx,result[3]=p2y):p1x<p2x&&(result[0]=topRightAx,result[1]=\np1y,result[2]=topLeftBx,result[3]=p2y);else{rectA=rectA.height/rectA.width;var slopeB=rectB.height/rectB.width;rectB=(p2y-p1y)/(p2x-p1x);-rectA===rectB?(p1x>p2x?(result[0]=bottomLeftAx,result[1]=bottomLeftAy):(result[0]=topRightAx,result[1]=topLeftAy),clipPointAFound=!0):rectA===rectB&&(p1x>p2x?(result[0]=topLeftAx,result[1]=topLeftAy):(result[0]=bottomRightAx,result[1]=bottomLeftAy),clipPointAFound=!0);-slopeB===rectB?(p2x>p1x?(result[2]=bottomLeftBx,result[3]=bottomLeftBy):(result[2]=topRightBx,\nresult[3]=topLeftBy),clipPointBFound=!0):slopeB===rectB&&(p2x>p1x?(result[2]=topLeftBx,result[3]=topLeftBy):(result[2]=bottomRightBx,result[3]=bottomLeftBy),clipPointBFound=!0);if(clipPointAFound&&clipPointBFound)return!1;p1x>p2x?p1y>p2y?(topLeftAx=this.getCardinalDirection(rectA,rectB,4),topRightAx=this.getCardinalDirection(slopeB,rectB,2)):(topLeftAx=this.getCardinalDirection(-rectA,rectB,3),topRightAx=this.getCardinalDirection(-slopeB,rectB,1)):p1y>p2y?(topLeftAx=this.getCardinalDirection(-rectA,\nrectB,1),topRightAx=this.getCardinalDirection(-slopeB,rectB,3)):(topLeftAx=this.getCardinalDirection(rectA,rectB,2),topRightAx=this.getCardinalDirection(slopeB,rectB,4));if(!clipPointAFound)switch(topLeftAx){case 1:result[0]=p1x+-halfHeightA/rectB;result[1]=topLeftAy;break;case 2:result[0]=bottomRightAx;result[1]=p1y+halfWidthA*rectB;break;case 3:result[0]=p1x+halfHeightA/rectB;result[1]=bottomLeftAy;break;case 4:result[0]=bottomLeftAx,result[1]=p1y+-halfWidthA*rectB}if(!clipPointBFound)switch(topRightAx){case 1:result[2]=\np2x+-halfHeightB/rectB;result[3]=topLeftBy;break;case 2:result[2]=bottomRightBx;result[3]=p2y+halfWidthB*rectB;break;case 3:result[2]=p2x+halfHeightB/rectB;result[3]=bottomLeftBy;break;case 4:result[2]=bottomLeftBx,result[3]=p2y+-halfWidthB*rectB}}return!1};IGeometry.getCardinalDirection=function(slope,slopePrime,line){return slope>slopePrime?line:1+line%4};IGeometry.getIntersection=function(s1,s2,f1,f2){if(null==f2)return this.getIntersection2(s1,s2,f1);var x1=s1.x,y1=s1.y,x2=s2.x,y2=s2.y;s2=f1.x;\ns1=f1.y;var x4=f2.x,y4=f2.y;f2=y2-y1;f1=x1-x2;x2=x2*y1-x1*y2;x1=y4-s1;y1=s2-x4;s2=x4*s1-s2*y4;s1=f2*y1-x1*f1;return 0===s1?null:new Point((f1*s2-y1*x2)/s1,(x1*x2-f2*s2)/s1)};IGeometry.angleOfVector=function(Cx,Cy,Nx,Ny){if(Cx!==Nx){var C_angle=Math.atan((Ny-Cy)/(Nx-Cx));Nx<Cx?C_angle+=Math.PI:Ny<Cy&&(C_angle+=this.TWO_PI)}else C_angle=Ny<Cy?this.ONE_AND_HALF_PI:this.HALF_PI;return C_angle};IGeometry.doIntersect=function(p1,p2,p3,p4){var a=p1.x;p1=p1.y;var c=p2.x;p2=p2.y;var p=p3.x,q=p3.y;p3=p4.x;\np4=p4.y;var det=(c-a)*(p4-q)-(p3-p)*(p2-p1);if(0===det)return!1;p=((p4-q)*(p3-a)+(p-p3)*(p4-p1))/det;a=((p1-p2)*(p3-a)+(c-a)*(p4-p1))/det;return 0<p&&1>p&&0<a&&1>a};IGeometry.HALF_PI=.5*Math.PI;IGeometry.ONE_AND_HALF_PI=1.5*Math.PI;IGeometry.TWO_PI=2*Math.PI;IGeometry.THREE_PI=3*Math.PI;module.exports=IGeometry},function(module,exports,__webpack_require__){function IMath(){}IMath.sign=function(value){return 0<value?1:0>value?-1:0};IMath.floor=function(value){return 0>value?Math.ceil(value):Math.floor(value)};\nIMath.ceil=function(value){return 0>value?Math.floor(value):Math.ceil(value)};module.exports=IMath},function(module,exports,__webpack_require__){function Integer(){}Integer.MAX_VALUE=2147483647;Integer.MIN_VALUE=-2147483648;module.exports=Integer},function(module,exports,__webpack_require__){var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in\ndescriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}(),nodeFrom=function(value){return{value,next:null,prev:null}},add=function(prev,node,next,list){null!==prev?prev.next=node:list.head=node;null!==next?next.prev=node:list.tail=node;node.prev=prev;node.next=next;list.length++;\nreturn node},_remove=function(node,list){var prev=node.prev,next=node.next;null!==prev?prev.next=next:list.head=next;null!==next?next.prev=prev:list.tail=prev;node.prev=node.next=null;list.length--;return node};exports=function(){function LinkedList(vals){var _this=this;if(!(this instanceof LinkedList))throw new TypeError(\"Cannot call a class as a function\");this.length=0;this.tail=this.head=null;null!=vals&&vals.forEach(function(v){return _this.push(v)})}_createClass(LinkedList,[{key:\"size\",value:function(){return this.length}},\n{key:\"insertBefore\",value:function(val,otherNode){return add(otherNode.prev,nodeFrom(val),otherNode,this)}},{key:\"insertAfter\",value:function(val,otherNode){return add(otherNode,nodeFrom(val),otherNode.next,this)}},{key:\"insertNodeBefore\",value:function(newNode,otherNode){return add(otherNode.prev,newNode,otherNode,this)}},{key:\"insertNodeAfter\",value:function(newNode,otherNode){return add(otherNode,newNode,otherNode.next,this)}},{key:\"push\",value:function(val){return add(this.tail,nodeFrom(val),\nnull,this)}},{key:\"unshift\",value:function(val){return add(null,nodeFrom(val),this.head,this)}},{key:\"remove\",value:function(node){return _remove(node,this)}},{key:\"pop\",value:function(){return _remove(this.tail,this).value}},{key:\"popNode\",value:function(){return _remove(this.tail,this)}},{key:\"shift\",value:function(){return _remove(this.head,this).value}},{key:\"shiftNode\",value:function(){return _remove(this.head,this)}},{key:\"get_object_at\",value:function(index){if(index<=this.length()){for(var i=\n1,current=this.head;i<index;)current=current.next,i++;return current.value}}},{key:\"set_object_at\",value:function(index,value){if(index<=this.length()){for(var i=1,current=this.head;i<index;)current=current.next,i++;current.value=value}}}]);return LinkedList}();module.exports=exports},function(module,exports,__webpack_require__){function Point(x,y,p){this.y=this.x=null;null==x&&null==y&&null==p?this.y=this.x=0:\"number\"==typeof x&&\"number\"==typeof y&&null==p?(this.x=x,this.y=y):\"Point\"==x.constructor.name&&\nnull==y&&null==p&&(p=x,this.x=p.x,this.y=p.y)}Point.prototype.getX=function(){return this.x};Point.prototype.getY=function(){return this.y};Point.prototype.getLocation=function(){return new Point(this.x,this.y)};Point.prototype.setLocation=function(x,y,p){\"Point\"==x.constructor.name&&null==y&&null==p?(p=x,this.setLocation(p.x,p.y)):\"number\"==typeof x&&\"number\"==typeof y&&null==p&&(parseInt(x)==x&&parseInt(y)==y?this.move(x,y):(this.x=Math.floor(x+.5),this.y=Math.floor(y+.5)))};Point.prototype.move=\nfunction(x,y){this.x=x;this.y=y};Point.prototype.translate=function(dx,dy){this.x+=dx;this.y+=dy};Point.prototype.equals=function(obj){return\"Point\"==obj.constructor.name?this.x==obj.x&&this.y==obj.y:this==obj};Point.prototype.toString=function(){return(new Point).constructor.name+\"[x\\x3d\"+this.x+\",y\\x3d\"+this.y+\"]\"};module.exports=Point},function(module,exports,__webpack_require__){function RectangleD(x,y,width,height){this.height=this.width=this.y=this.x=0;null!=x&&null!=y&&null!=width&&null!=height&&\n(this.x=x,this.y=y,this.width=width,this.height=height)}RectangleD.prototype.getX=function(){return this.x};RectangleD.prototype.setX=function(x){this.x=x};RectangleD.prototype.getY=function(){return this.y};RectangleD.prototype.setY=function(y){this.y=y};RectangleD.prototype.getWidth=function(){return this.width};RectangleD.prototype.setWidth=function(width){this.width=width};RectangleD.prototype.getHeight=function(){return this.height};RectangleD.prototype.setHeight=function(height){this.height=\nheight};RectangleD.prototype.getRight=function(){return this.x+this.width};RectangleD.prototype.getBottom=function(){return this.y+this.height};RectangleD.prototype.intersects=function(a){return this.getRight()<a.x||this.getBottom()<a.y||a.getRight()<this.x||a.getBottom()<this.y?!1:!0};RectangleD.prototype.getCenterX=function(){return this.x+this.width/2};RectangleD.prototype.getMinX=function(){return this.getX()};RectangleD.prototype.getMaxX=function(){return this.getX()+this.width};RectangleD.prototype.getCenterY=\nfunction(){return this.y+this.height/2};RectangleD.prototype.getMinY=function(){return this.getY()};RectangleD.prototype.getMaxY=function(){return this.getY()+this.height};RectangleD.prototype.getWidthHalf=function(){return this.width/2};RectangleD.prototype.getHeightHalf=function(){return this.height/2};module.exports=RectangleD},function(module,exports,__webpack_require__){function UniqueIDGeneretor(){}var _typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:\nfunction(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj};UniqueIDGeneretor.lastID=0;UniqueIDGeneretor.createID=function(obj){if(UniqueIDGeneretor.isPrimitive(obj))return obj;if(null!=obj.uniqueID)return obj.uniqueID;obj.uniqueID=UniqueIDGeneretor.getString();UniqueIDGeneretor.lastID++;return obj.uniqueID};UniqueIDGeneretor.getString=function(id){null==id&&(id=UniqueIDGeneretor.lastID);return\"Object#\"+id};UniqueIDGeneretor.isPrimitive=\nfunction(arg){var type=\"undefined\"===typeof arg?\"undefined\":_typeof(arg);return null==arg||\"object\"!=type&&\"function\"!=type};module.exports=UniqueIDGeneretor},function(module,exports,__webpack_require__){function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2}return Array.from(arr)}function Layout(isRemoteUse){Emitter.call(this);this.layoutQuality=LayoutConstants.QUALITY;this.createBendsAsNeeded=LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\nthis.incremental=LayoutConstants.DEFAULT_INCREMENTAL;this.animationOnLayout=LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;this.animationDuringLayout=LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;this.animationPeriod=LayoutConstants.DEFAULT_ANIMATION_PERIOD;this.uniformLeafNodeSizes=LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;this.edgeToDummyNodes=new Map;this.graphManager=new LGraphManager(this);this.isRemoteUse=this.isSubLayout=this.isLayoutFinished=!1;null!=isRemoteUse&&(this.isRemoteUse=isRemoteUse)}\nvar LayoutConstants=__webpack_require__(0),LGraphManager=__webpack_require__(6),LNode=__webpack_require__(3),LEdge=__webpack_require__(1),LGraph=__webpack_require__(5),PointD=__webpack_require__(4),Transform=__webpack_require__(17),Emitter=__webpack_require__(27);Layout.RANDOM_SEED=1;Layout.prototype=Object.create(Emitter.prototype);Layout.prototype.getGraphManager=function(){return this.graphManager};Layout.prototype.getAllNodes=function(){return this.graphManager.getAllNodes()};Layout.prototype.getAllEdges=\nfunction(){return this.graphManager.getAllEdges()};Layout.prototype.getAllNodesToApplyGravitation=function(){return this.graphManager.getAllNodesToApplyGravitation()};Layout.prototype.newGraphManager=function(){var gm=new LGraphManager(this);return this.graphManager=gm};Layout.prototype.newGraph=function(vGraph){return new LGraph(null,this.graphManager,vGraph)};Layout.prototype.newNode=function(vNode){return new LNode(this.graphManager,vNode)};Layout.prototype.newEdge=function(vEdge){return new LEdge(null,\nnull,vEdge)};Layout.prototype.checkLayoutSuccess=function(){return null==this.graphManager.getRoot()||0==this.graphManager.getRoot().getNodes().length||this.graphManager.includesInvalidEdge()};Layout.prototype.runLayout=function(){this.isLayoutFinished=!1;this.tilingPreLayout&&this.tilingPreLayout();this.initParameters();var isLayoutSuccessfull=this.checkLayoutSuccess()?!1:this.layout();if(\"during\"===LayoutConstants.ANIMATE)return!1;isLayoutSuccessfull&&(this.isSubLayout||this.doPostLayout());this.tilingPostLayout&&\nthis.tilingPostLayout();this.isLayoutFinished=!0;return isLayoutSuccessfull};Layout.prototype.doPostLayout=function(){this.incremental||this.transform();this.update()};Layout.prototype.update2=function(){this.createBendsAsNeeded&&(this.createBendpointsFromDummyNodes(),this.graphManager.resetAllEdges());if(!this.isRemoteUse){for(var allEdges=this.graphManager.getAllEdges(),i=0;i<allEdges.length;i++);allEdges=this.graphManager.getRoot().getNodes();for(i=0;i<allEdges.length;i++);this.update(this.graphManager.getRoot())}};\nLayout.prototype.update=function(obj){if(null==obj)this.update2();else if(obj instanceof LNode){if(null!=obj.getChild())for(var nodes=obj.getChild().getNodes(),i=0;i<nodes.length;i++)update(nodes[i]);null!=obj.vGraphObject&&obj.vGraphObject.update(obj)}else obj instanceof LEdge?null!=obj.vGraphObject&&obj.vGraphObject.update(obj):obj instanceof LGraph&&null!=obj.vGraphObject&&obj.vGraphObject.update(obj)};Layout.prototype.initParameters=function(){this.isSubLayout||(this.layoutQuality=LayoutConstants.QUALITY,\nthis.animationDuringLayout=LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT,this.animationPeriod=LayoutConstants.DEFAULT_ANIMATION_PERIOD,this.animationOnLayout=LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT,this.incremental=LayoutConstants.DEFAULT_INCREMENTAL,this.createBendsAsNeeded=LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED,this.uniformLeafNodeSizes=LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES);this.animationDuringLayout&&(this.animationOnLayout=!1)};Layout.prototype.transform=function(newLeftTop){if(void 0==\nnewLeftTop)this.transform(new PointD(0,0));else{var trans=new Transform,leftTop=this.graphManager.getRoot().updateLeftTop();if(null!=leftTop){trans.setWorldOrgX(newLeftTop.x);trans.setWorldOrgY(newLeftTop.y);trans.setDeviceOrgX(leftTop.x);trans.setDeviceOrgY(leftTop.y);newLeftTop=this.getAllNodes();for(var i=0;i<newLeftTop.length;i++)leftTop=newLeftTop[i],leftTop.transform(trans)}}};Layout.prototype.positionNodesRandomly=function(graph){if(void 0==graph)this.positionNodesRandomly(this.getGraphManager().getRoot()),\nthis.getGraphManager().getRoot().updateBounds(!0);else for(var childGraph,nodes=graph.getNodes(),i=0;i<nodes.length;i++)graph=nodes[i],childGraph=graph.getChild(),null==childGraph?graph.scatter():0==childGraph.getNodes().length?graph.scatter():(this.positionNodesRandomly(childGraph),graph.updateBounds())};Layout.prototype.getFlatForest=function(){for(var flatForest=[],isForest=!0,allNodes=this.graphManager.getRoot().getNodes(),isFlat=!0,i=0;i<allNodes.length;i++)null!=allNodes[i].getChild()&&(isFlat=\n!1);if(!isFlat)return flatForest;var visited=new Set;isFlat=[];var parents=new Map,unProcessedNodes=[];for(unProcessedNodes=unProcessedNodes.concat(allNodes);0<unProcessedNodes.length&&isForest;){for(isFlat.push(unProcessedNodes[0]);0<isFlat.length&&isForest;){allNodes=isFlat[0];isFlat.splice(0,1);visited.add(allNodes);var neighborEdges=allNodes.getEdges();for(i=0;i<neighborEdges.length;i++){var currentNeighbor=neighborEdges[i].getOtherEnd(allNodes);if(parents.get(allNodes)!=currentNeighbor)if(visited.has(currentNeighbor)){isForest=\n!1;break}else isFlat.push(currentNeighbor),parents.set(currentNeighbor,allNodes)}}if(isForest){visited=[].concat(_toConsumableArray(visited));flatForest.push(visited);for(i=0;i<visited.length;i++)parents=unProcessedNodes.indexOf(visited[i]),-1<parents&&unProcessedNodes.splice(parents,1);visited=new Set;parents=new Map}else flatForest=[]}return flatForest};Layout.prototype.createDummyNodesForBendpoints=function(edge){for(var dummyNodes=[],prev=edge.source,graph=this.graphManager.calcLowestCommonAncestor(edge.source,\nedge.target),i=0;i<edge.bendpoints.length;i++){var dummyNode=this.newNode(null);dummyNode.setRect(new Point(0,0),new Dimension(1,1));graph.add(dummyNode);var dummyEdge=this.newEdge(null);this.graphManager.add(dummyEdge,prev,dummyNode);dummyNodes.add(dummyNode);prev=dummyNode}dummyEdge=this.newEdge(null);this.graphManager.add(dummyEdge,prev,edge.target);this.edgeToDummyNodes.set(edge,dummyNodes);edge.isInterGraph()?this.graphManager.remove(edge):graph.remove(edge);return dummyNodes};Layout.prototype.createBendpointsFromDummyNodes=\nfunction(){var edges=[];edges=edges.concat(this.graphManager.getAllEdges());edges=[].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);for(var k=0;k<edges.length;k++){var lEdge=edges[k];if(0<lEdge.bendpoints.length){for(var path=this.edgeToDummyNodes.get(lEdge),i=0;i<path.length;i++){var dummyNode=path[i],p=new PointD(dummyNode.getCenterX(),dummyNode.getCenterY()),ebp=lEdge.bendpoints.get(i);ebp.x=p.x;ebp.y=p.y;dummyNode.getOwner().remove(dummyNode)}this.graphManager.add(lEdge,\nlEdge.source,lEdge.target)}}};Layout.transform=function(sliderValue,defaultValue,minDiv,maxMul){if(void 0!=minDiv&&void 0!=maxMul){var value=defaultValue;return 50>=sliderValue?value-(defaultValue-defaultValue/minDiv)/50*(50-sliderValue):value+(defaultValue*maxMul-defaultValue)/50*(sliderValue-50)}50>=sliderValue?(minDiv=9*defaultValue/500,defaultValue/=10):(minDiv=9*defaultValue/50,defaultValue*=-8);return minDiv*sliderValue+defaultValue};Layout.findCenterOfTree=function(nodes){var list=[];list=\nlist.concat(nodes);var removedNodes=[],remainingDegrees=new Map;nodes=!1;var centerNode=null;if(1==list.length||2==list.length)nodes=!0,centerNode=list[0];for(var i=0;i<list.length;i++){var node=list[i],degree=node.getNeighborsList().size;remainingDegrees.set(node,node.getNeighborsList().size);1==degree&&removedNodes.push(node)}var tempList=[];for(tempList=tempList.concat(removedNodes);!nodes;){i=[];i=i.concat(tempList);tempList=[];for(i=0;i<list.length;i++)node=list[i],degree=list.indexOf(node),\n0<=degree&&list.splice(degree,1),node.getNeighborsList().forEach(function(neighbour){if(0>removedNodes.indexOf(neighbour)){var newDegree=remainingDegrees.get(neighbour)-1;1==newDegree&&tempList.push(neighbour);remainingDegrees.set(neighbour,newDegree)}});removedNodes=removedNodes.concat(tempList);if(1==list.length||2==list.length)nodes=!0,centerNode=list[0]}return centerNode};Layout.prototype.setGraphManager=function(gm){this.graphManager=gm};module.exports=Layout},function(module,exports,__webpack_require__){function RandomSeed(){}\nRandomSeed.seed=1;RandomSeed.x=0;RandomSeed.nextDouble=function(){RandomSeed.x=1E4*Math.sin(RandomSeed.seed++);return RandomSeed.x-Math.floor(RandomSeed.x)};module.exports=RandomSeed},function(module,exports,__webpack_require__){function Transform(x,y){this.ldeviceOrgY=this.ldeviceOrgX=this.lworldOrgY=this.lworldOrgX=0;this.ldeviceExtY=this.ldeviceExtX=this.lworldExtY=this.lworldExtX=1}var PointD=__webpack_require__(4);Transform.prototype.getWorldOrgX=function(){return this.lworldOrgX};Transform.prototype.setWorldOrgX=\nfunction(wox){this.lworldOrgX=wox};Transform.prototype.getWorldOrgY=function(){return this.lworldOrgY};Transform.prototype.setWorldOrgY=function(woy){this.lworldOrgY=woy};Transform.prototype.getWorldExtX=function(){return this.lworldExtX};Transform.prototype.setWorldExtX=function(wex){this.lworldExtX=wex};Transform.prototype.getWorldExtY=function(){return this.lworldExtY};Transform.prototype.setWorldExtY=function(wey){this.lworldExtY=wey};Transform.prototype.getDeviceOrgX=function(){return this.ldeviceOrgX};\nTransform.prototype.setDeviceOrgX=function(dox){this.ldeviceOrgX=dox};Transform.prototype.getDeviceOrgY=function(){return this.ldeviceOrgY};Transform.prototype.setDeviceOrgY=function(doy){this.ldeviceOrgY=doy};Transform.prototype.getDeviceExtX=function(){return this.ldeviceExtX};Transform.prototype.setDeviceExtX=function(dex){this.ldeviceExtX=dex};Transform.prototype.getDeviceExtY=function(){return this.ldeviceExtY};Transform.prototype.setDeviceExtY=function(dey){this.ldeviceExtY=dey};Transform.prototype.transformX=\nfunction(x){var xDevice=0,worldExtX=this.lworldExtX;0!=worldExtX&&(xDevice=this.ldeviceOrgX+(x-this.lworldOrgX)*this.ldeviceExtX/worldExtX);return xDevice};Transform.prototype.transformY=function(y){var yDevice=0,worldExtY=this.lworldExtY;0!=worldExtY&&(yDevice=this.ldeviceOrgY+(y-this.lworldOrgY)*this.ldeviceExtY/worldExtY);return yDevice};Transform.prototype.inverseTransformX=function(x){var xWorld=0,deviceExtX=this.ldeviceExtX;0!=deviceExtX&&(xWorld=this.lworldOrgX+(x-this.ldeviceOrgX)*this.lworldExtX/\ndeviceExtX);return xWorld};Transform.prototype.inverseTransformY=function(y){var yWorld=0,deviceExtY=this.ldeviceExtY;0!=deviceExtY&&(yWorld=this.lworldOrgY+(y-this.ldeviceOrgY)*this.lworldExtY/deviceExtY);return yWorld};Transform.prototype.inverseTransformPoint=function(inPoint){return new PointD(this.inverseTransformX(inPoint.x),this.inverseTransformY(inPoint.y))};module.exports=Transform},function(module,exports,__webpack_require__){function FDLayout(){Layout.call(this);this.useSmartIdealEdgeLengthCalculation=\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;this.idealEdgeLength=FDLayoutConstants.DEFAULT_EDGE_LENGTH;this.springConstant=FDLayoutConstants.DEFAULT_SPRING_STRENGTH;this.repulsionConstant=FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;this.gravityConstant=FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;this.compoundGravityConstant=FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;this.gravityRangeFactor=FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;this.compoundGravityRangeFactor=\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;this.displacementThresholdPerNode=3*FDLayoutConstants.DEFAULT_EDGE_LENGTH/100;this.initialCoolingFactor=this.coolingFactor=FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;this.oldTotalDisplacement=this.totalDisplacement=0;this.maxIterations=FDLayoutConstants.MAX_ITERATIONS}var Layout=__webpack_require__(15),FDLayoutConstants=__webpack_require__(7),LayoutConstants=__webpack_require__(0),IGeometry=__webpack_require__(8),IMath=__webpack_require__(9);\nFDLayout.prototype=Object.create(Layout.prototype);for(var prop in Layout)FDLayout[prop]=Layout[prop];FDLayout.prototype.initParameters=function(){Layout.prototype.initParameters.call(this,arguments);this.notAnimatedIterations=this.totalIterations=0;this.useFRGridVariant=FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;this.grid=[]};FDLayout.prototype.calcIdealEdgeLengths=function(){for(var edge,lcaDepth,source,target,sizeOfTargetInLca,allEdges=this.getGraphManager().getAllEdges(),\ni=0;i<allEdges.length;i++)edge=allEdges[i],edge.idealLength=this.idealEdgeLength,edge.isInterGraph&&(source=edge.getSource(),target=edge.getTarget(),lcaDepth=edge.getSourceInLca().getEstimatedSize(),sizeOfTargetInLca=edge.getTargetInLca().getEstimatedSize(),this.useSmartIdealEdgeLengthCalculation&&(edge.idealLength+=lcaDepth+sizeOfTargetInLca-2*LayoutConstants.SIMPLE_NODE_SIZE),lcaDepth=edge.getLca().getInclusionTreeDepth(),edge.idealLength+=FDLayoutConstants.DEFAULT_EDGE_LENGTH*FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR*\n(source.getInclusionTreeDepth()+target.getInclusionTreeDepth()-2*lcaDepth))};FDLayout.prototype.initSpringEmbedder=function(){var s=this.getAllNodes().length;this.incremental?(s>FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT&&(this.coolingFactor=Math.max(this.coolingFactor*FDLayoutConstants.COOLING_ADAPTATION_FACTOR,this.coolingFactor-(s-FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT)/(FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT-FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT)*this.coolingFactor*(1-\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR))),this.maxNodeDisplacement=FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL):(this.initialCoolingFactor=this.coolingFactor=s>FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT?Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR,1-(s-FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT)/(FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT-FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT)*(1-FDLayoutConstants.COOLING_ADAPTATION_FACTOR)):1,this.maxNodeDisplacement=FDLayoutConstants.MAX_NODE_DISPLACEMENT);\nthis.maxIterations=Math.max(5*this.getAllNodes().length,this.maxIterations);this.totalDisplacementThreshold=this.displacementThresholdPerNode*this.getAllNodes().length;this.repulsionRange=this.calcRepulsionRange()};FDLayout.prototype.calcSpringForces=function(){for(var lEdges=this.getAllEdges(),edge,i=0;i<lEdges.length;i++)edge=lEdges[i],this.calcSpringForce(edge,edge.idealLength)};FDLayout.prototype.calcRepulsionForces=function(){var gridUpdateAllowed=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\n!0,forceToNodeSurroundingUpdate=1<arguments.length&&void 0!==arguments[1]?arguments[1]:!1,i,lNodes=this.getAllNodes();if(this.useFRGridVariant){1==this.totalIterations%FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD&&gridUpdateAllowed&&this.updateGrid();var processedNodeSet=new Set;for(i=0;i<lNodes.length;i++){var nodeA=lNodes[i];this.calculateRepulsionForceOfANode(nodeA,processedNodeSet,gridUpdateAllowed,forceToNodeSurroundingUpdate);processedNodeSet.add(nodeA)}}else for(i=0;i<lNodes.length;i++)for(nodeA=\nlNodes[i],gridUpdateAllowed=i+1;gridUpdateAllowed<lNodes.length;gridUpdateAllowed++)forceToNodeSurroundingUpdate=lNodes[gridUpdateAllowed],nodeA.getOwner()==forceToNodeSurroundingUpdate.getOwner()&&this.calcRepulsionForce(nodeA,forceToNodeSurroundingUpdate)};FDLayout.prototype.calcGravitationalForces=function(){for(var node,lNodes=this.getAllNodesToApplyGravitation(),i=0;i<lNodes.length;i++)node=lNodes[i],this.calcGravitationalForce(node)};FDLayout.prototype.moveNodes=function(){for(var lNodes=this.getAllNodes(),\nnode,i=0;i<lNodes.length;i++)node=lNodes[i],node.move()};FDLayout.prototype.calcSpringForce=function(edge,idealLength){var sourceNode=edge.getSource(),targetNode=edge.getTarget();if(this.uniformLeafNodeSizes&&null==sourceNode.getChild()&&null==targetNode.getChild())edge.updateLengthSimple();else if(edge.updateLength(),edge.isOverlapingSourceAndTarget)return;var length=edge.getLength();if(0!=length){var springForce=this.springConstant*(length-idealLength);idealLength=edge.lengthX/length*springForce;\nedge=edge.lengthY/length*springForce;sourceNode.springForceX+=idealLength;sourceNode.springForceY+=edge;targetNode.springForceX-=idealLength;targetNode.springForceY-=edge}};FDLayout.prototype.calcRepulsionForce=function(nodeA,nodeB){var rectA=nodeA.getRect(),rectB=nodeB.getRect(),overlapAmount=Array(2),clipPoints=Array(4);if(rectA.intersects(rectB)){IGeometry.calcSeparationAmount(rectA,rectB,overlapAmount,FDLayoutConstants.DEFAULT_EDGE_LENGTH/2);var distanceX=2*overlapAmount[0];rectA=2*overlapAmount[1];\nrectB=nodeA.noOfChildren*nodeB.noOfChildren/(nodeA.noOfChildren+nodeB.noOfChildren);nodeA.repulsionForceX-=rectB*distanceX;nodeA.repulsionForceY-=rectB*rectA;nodeB.repulsionForceX+=rectB*distanceX;nodeB.repulsionForceY+=rectB*rectA}else this.uniformLeafNodeSizes&&null==nodeA.getChild()&&null==nodeB.getChild()?(distanceX=rectB.getCenterX()-rectA.getCenterX(),rectA=rectB.getCenterY()-rectA.getCenterY()):(IGeometry.getIntersection(rectA,rectB,clipPoints),distanceX=clipPoints[2]-clipPoints[0],rectA=clipPoints[3]-\nclipPoints[1]),Math.abs(distanceX)<FDLayoutConstants.MIN_REPULSION_DIST&&(distanceX=IMath.sign(distanceX)*FDLayoutConstants.MIN_REPULSION_DIST),Math.abs(rectA)<FDLayoutConstants.MIN_REPULSION_DIST&&(rectA=IMath.sign(rectA)*FDLayoutConstants.MIN_REPULSION_DIST),overlapAmount=distanceX*distanceX+rectA*rectA,rectB=Math.sqrt(overlapAmount),overlapAmount=this.repulsionConstant*nodeA.noOfChildren*nodeB.noOfChildren/overlapAmount,distanceX=overlapAmount*distanceX/rectB,rectA=overlapAmount*rectA/rectB,nodeA.repulsionForceX-=\ndistanceX,nodeA.repulsionForceY-=rectA,nodeB.repulsionForceX+=distanceX,nodeB.repulsionForceY+=rectA};FDLayout.prototype.calcGravitationalForce=function(node){var ownerGraph=node.getOwner();var ownerCenterX=(ownerGraph.getRight()+ownerGraph.getLeft())/2;var ownerCenterY=(ownerGraph.getTop()+ownerGraph.getBottom())/2;ownerCenterX=node.getCenterX()-ownerCenterX;ownerCenterY=node.getCenterY()-ownerCenterY;var absDistanceX=Math.abs(ownerCenterX)+node.getWidth()/2;var absDistanceY=Math.abs(ownerCenterY)+\nnode.getHeight()/2;if(node.getOwner()==this.graphManager.getRoot()){if(ownerGraph=ownerGraph.getEstimatedSize()*this.gravityRangeFactor,absDistanceX>ownerGraph||absDistanceY>ownerGraph)node.gravitationForceX=-this.gravityConstant*ownerCenterX,node.gravitationForceY=-this.gravityConstant*ownerCenterY}else if(ownerGraph=ownerGraph.getEstimatedSize()*this.compoundGravityRangeFactor,absDistanceX>ownerGraph||absDistanceY>ownerGraph)node.gravitationForceX=-this.gravityConstant*ownerCenterX*this.compoundGravityConstant,\nnode.gravitationForceY=-this.gravityConstant*ownerCenterY*this.compoundGravityConstant};FDLayout.prototype.isConverged=function(){var oscilating=!1;this.totalIterations>this.maxIterations/3&&(oscilating=2>Math.abs(this.totalDisplacement-this.oldTotalDisplacement));var converged=this.totalDisplacement<this.totalDisplacementThreshold;this.oldTotalDisplacement=this.totalDisplacement;return converged||oscilating};FDLayout.prototype.animate=function(){this.animationDuringLayout&&!this.isSubLayout&&(this.notAnimatedIterations==\nthis.animationPeriod?(this.update(),this.notAnimatedIterations=0):this.notAnimatedIterations++)};FDLayout.prototype.calcNoOfChildrenForAllNodes=function(){for(var node,allNodes=this.graphManager.getAllNodes(),i=0;i<allNodes.length;i++)node=allNodes[i],node.noOfChildren=node.getNoOfChildren()};FDLayout.prototype.calcGrid=function(graph){var sizeX=parseInt(Math.ceil((graph.getRight()-graph.getLeft())/this.repulsionRange));graph=parseInt(Math.ceil((graph.getBottom()-graph.getTop())/this.repulsionRange));\nfor(var grid=Array(sizeX),i=0;i<sizeX;i++)grid[i]=Array(graph);for(i=0;i<sizeX;i++)for(var j=0;j<graph;j++)grid[i][j]=[];return grid};FDLayout.prototype.addNodeToGrid=function(v,left,top){var startX=parseInt(Math.floor((v.getRect().x-left)/this.repulsionRange));left=parseInt(Math.floor((v.getRect().width+v.getRect().x-left)/this.repulsionRange));var startY=parseInt(Math.floor((v.getRect().y-top)/this.repulsionRange));top=parseInt(Math.floor((v.getRect().height+v.getRect().y-top)/this.repulsionRange));\nfor(var i=startX;i<=left;i++)for(var j=startY;j<=top;j++)this.grid[i][j].push(v),v.setGridCoordinates(startX,left,startY,top)};FDLayout.prototype.updateGrid=function(){var i,lNodes=this.getAllNodes();this.grid=this.calcGrid(this.graphManager.getRoot());for(i=0;i<lNodes.length;i++){var nodeA=lNodes[i];this.addNodeToGrid(nodeA,this.graphManager.getRoot().getLeft(),this.graphManager.getRoot().getTop())}};FDLayout.prototype.calculateRepulsionForceOfANode=function(nodeA,processedNodeSet,gridUpdateAllowed,\nforceToNodeSurroundingUpdate){if(1==this.totalIterations%FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD&&gridUpdateAllowed||forceToNodeSurroundingUpdate){gridUpdateAllowed=new Set;nodeA.surrounding=[];for(var grid=this.grid,i=nodeA.startX-1;i<nodeA.finishX+2;i++)for(var j=nodeA.startY-1;j<nodeA.finishY+2;j++)if(!(0>i||0>j||i>=grid.length||j>=grid[0].length))for(var k=0;k<grid[i][j].length;k++)if(forceToNodeSurroundingUpdate=grid[i][j][k],nodeA.getOwner()==forceToNodeSurroundingUpdate.getOwner()&&\nnodeA!=forceToNodeSurroundingUpdate&&!processedNodeSet.has(forceToNodeSurroundingUpdate)&&!gridUpdateAllowed.has(forceToNodeSurroundingUpdate)){var distanceX=Math.abs(nodeA.getCenterX()-forceToNodeSurroundingUpdate.getCenterX())-(nodeA.getWidth()/2+forceToNodeSurroundingUpdate.getWidth()/2),distanceY=Math.abs(nodeA.getCenterY()-forceToNodeSurroundingUpdate.getCenterY())-(nodeA.getHeight()/2+forceToNodeSurroundingUpdate.getHeight()/2);distanceX<=this.repulsionRange&&distanceY<=this.repulsionRange&&\ngridUpdateAllowed.add(forceToNodeSurroundingUpdate)}processedNodeSet=[];forceToNodeSurroundingUpdate=processedNodeSet.concat;if(Array.isArray(gridUpdateAllowed)){grid=0;for(i=Array(gridUpdateAllowed.length);grid<gridUpdateAllowed.length;grid++)i[grid]=gridUpdateAllowed[grid];gridUpdateAllowed=i}else gridUpdateAllowed=Array.from(gridUpdateAllowed);nodeA.surrounding=forceToNodeSurroundingUpdate.call(processedNodeSet,gridUpdateAllowed)}for(i=0;i<nodeA.surrounding.length;i++)this.calcRepulsionForce(nodeA,\nnodeA.surrounding[i])};FDLayout.prototype.calcRepulsionRange=function(){return 0};module.exports=FDLayout},function(module,exports,__webpack_require__){function FDLayoutEdge(source,target,vEdge){LEdge.call(this,source,target,vEdge);this.idealLength=FDLayoutConstants.DEFAULT_EDGE_LENGTH}var LEdge=__webpack_require__(1),FDLayoutConstants=__webpack_require__(7);FDLayoutEdge.prototype=Object.create(LEdge.prototype);for(var prop in LEdge)FDLayoutEdge[prop]=LEdge[prop];module.exports=FDLayoutEdge},function(module,\nexports,__webpack_require__){function FDLayoutNode(gm,loc,size,vNode){LNode.call(this,gm,loc,size,vNode);this.finishY=this.startY=this.finishX=this.startX=this.displacementY=this.displacementX=this.gravitationForceY=this.gravitationForceX=this.repulsionForceY=this.repulsionForceX=this.springForceY=this.springForceX=0;this.surrounding=[]}var LNode=__webpack_require__(3);FDLayoutNode.prototype=Object.create(LNode.prototype);for(var prop in LNode)FDLayoutNode[prop]=LNode[prop];FDLayoutNode.prototype.setGridCoordinates=\nfunction(_startX,_finishX,_startY,_finishY){this.startX=_startX;this.finishX=_finishX;this.startY=_startY;this.finishY=_finishY};module.exports=FDLayoutNode},function(module,exports,__webpack_require__){function DimensionD(width,height){this.height=this.width=0;null!==width&&null!==height&&(this.height=height,this.width=width)}DimensionD.prototype.getWidth=function(){return this.width};DimensionD.prototype.setWidth=function(width){this.width=width};DimensionD.prototype.getHeight=function(){return this.height};\nDimensionD.prototype.setHeight=function(height){this.height=height};module.exports=DimensionD},function(module,exports,__webpack_require__){function HashMap(){this.map={};this.keys=[]}var UniqueIDGeneretor=__webpack_require__(14);HashMap.prototype.put=function(key,value){var theId=UniqueIDGeneretor.createID(key);this.contains(theId)||(this.map[theId]=value,this.keys.push(key))};HashMap.prototype.contains=function(key){UniqueIDGeneretor.createID(key);return null!=this.map[key]};HashMap.prototype.get=\nfunction(key){key=UniqueIDGeneretor.createID(key);return this.map[key]};HashMap.prototype.keySet=function(){return this.keys};module.exports=HashMap},function(module,exports,__webpack_require__){function HashSet(){this.set={}}var UniqueIDGeneretor=__webpack_require__(14);HashSet.prototype.add=function(obj){var theId=UniqueIDGeneretor.createID(obj);this.contains(theId)||(this.set[theId]=obj)};HashSet.prototype.remove=function(obj){delete this.set[UniqueIDGeneretor.createID(obj)]};HashSet.prototype.clear=\nfunction(){this.set={}};HashSet.prototype.contains=function(obj){return this.set[UniqueIDGeneretor.createID(obj)]==obj};HashSet.prototype.isEmpty=function(){return 0===this.size()};HashSet.prototype.size=function(){return Object.keys(this.set).length};HashSet.prototype.addAllTo=function(list){for(var keys=Object.keys(this.set),length=keys.length,i=0;i<length;i++)list.push(this.set[keys[i]])};HashSet.prototype.size=function(){return Object.keys(this.set).length};HashSet.prototype.addAll=function(list){for(var s=\nlist.length,i=0;i<s;i++)this.add(list[i])};module.exports=HashSet},function(module,exports,__webpack_require__){var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,\nprotoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}(),LinkedList=__webpack_require__(11);exports=function(){function Quicksort(A,compareFunction){if(!(this instanceof Quicksort))throw new TypeError(\"Cannot call a class as a function\");if(null!==compareFunction||void 0!==compareFunction)this.compareFunction=this._defaultCompareFunction;compareFunction=A instanceof LinkedList?A.size():A.length;this._quicksort(A,0,compareFunction-1)}_createClass(Quicksort,[{key:\"_quicksort\",\nvalue:function(A,p,r){if(p<r){var q=this._partition(A,p,r);this._quicksort(A,p,q);this._quicksort(A,q+1,r)}}},{key:\"_partition\",value:function(A,p,r){for(var x=this._get(A,p);;){for(;this.compareFunction(x,this._get(A,r));)r--;for(;this.compareFunction(this._get(A,p),x);)p++;if(p<r)this._swap(A,p,r),p++,r--;else return r}}},{key:\"_get\",value:function(object,index){return object instanceof LinkedList?object.get_object_at(index):object[index]}},{key:\"_set\",value:function(object,index,value){object instanceof\nLinkedList?object.set_object_at(index,value):object[index]=value}},{key:\"_swap\",value:function(A,i,j){var temp=this._get(A,i);this._set(A,i,this._get(A,j));this._set(A,j,temp)}},{key:\"_defaultCompareFunction\",value:function(a,b){return b>a}}]);return Quicksort}();module.exports=exports},function(module,exports,__webpack_require__){var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||\n!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}();exports=function(){function NeedlemanWunsch(sequence1,sequence2){var match_score=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1,mismatch_penalty=3<arguments.length&&\nvoid 0!==arguments[3]?arguments[3]:-1,gap_penalty=4<arguments.length&&void 0!==arguments[4]?arguments[4]:-1;if(!(this instanceof NeedlemanWunsch))throw new TypeError(\"Cannot call a class as a function\");this.sequence1=sequence1;this.sequence2=sequence2;this.match_score=match_score;this.mismatch_penalty=mismatch_penalty;this.gap_penalty=gap_penalty;this.iMax=sequence1.length+1;this.jMax=sequence2.length+1;this.grid=Array(this.iMax);for(match_score=0;match_score<this.iMax;match_score++)for(this.grid[match_score]=\nArray(this.jMax),mismatch_penalty=0;mismatch_penalty<this.jMax;mismatch_penalty++)this.grid[match_score][mismatch_penalty]=0;this.tracebackGrid=Array(this.iMax);for(match_score=0;match_score<this.iMax;match_score++)for(this.tracebackGrid[match_score]=Array(this.jMax),mismatch_penalty=0;mismatch_penalty<this.jMax;mismatch_penalty++)this.tracebackGrid[match_score][mismatch_penalty]=[null,null,null];this.alignments=[];this.score=-1;this.computeGrids()}_createClass(NeedlemanWunsch,[{key:\"getScore\",value:function(){return this.score}},\n{key:\"getAlignments\",value:function(){return this.alignments}},{key:\"computeGrids\",value:function(){for(var j=1;j<this.jMax;j++)this.grid[0][j]=this.grid[0][j-1]+this.gap_penalty,this.tracebackGrid[0][j]=[!1,!1,!0];for(j=1;j<this.iMax;j++)this.grid[j][0]=this.grid[j-1][0]+this.gap_penalty,this.tracebackGrid[j][0]=[!1,!0,!1];for(j=1;j<this.iMax;j++)for(var _j2=1;_j2<this.jMax;_j2++){var maxOf=[this.sequence1[j-1]===this.sequence2[_j2-1]?this.grid[j-1][_j2-1]+this.match_score:this.grid[j-1][_j2-1]+\nthis.mismatch_penalty,this.grid[j-1][_j2]+this.gap_penalty,this.grid[j][_j2-1]+this.gap_penalty],indices=this.arrayAllMaxIndexes(maxOf);this.grid[j][_j2]=maxOf[indices[0]];this.tracebackGrid[j][_j2]=[indices.includes(0),indices.includes(1),indices.includes(2)]}this.score=this.grid[this.iMax-1][this.jMax-1]}},{key:\"alignmentTraceback\",value:function(){var inProcessAlignments=[];for(inProcessAlignments.push({pos:[this.sequence1.length,this.sequence2.length],seq1:\"\",seq2:\"\"});inProcessAlignments[0];){var current=\ninProcessAlignments[0],directions=this.tracebackGrid[current.pos[0]][current.pos[1]];directions[0]&&inProcessAlignments.push({pos:[current.pos[0]-1,current.pos[1]-1],seq1:this.sequence1[current.pos[0]-1]+current.seq1,seq2:this.sequence2[current.pos[1]-1]+current.seq2});directions[1]&&inProcessAlignments.push({pos:[current.pos[0]-1,current.pos[1]],seq1:this.sequence1[current.pos[0]-1]+current.seq1,seq2:\"-\"+current.seq2});directions[2]&&inProcessAlignments.push({pos:[current.pos[0],current.pos[1]-1],\nseq1:\"-\"+current.seq1,seq2:this.sequence2[current.pos[1]-1]+current.seq2});0===current.pos[0]&&0===current.pos[1]&&this.alignments.push({sequence1:current.seq1,sequence2:current.seq2});inProcessAlignments.shift()}return this.alignments}},{key:\"getAllIndexes\",value:function(arr,val){for(var indexes=[],i=-1;-1!==(i=arr.indexOf(val,i+1));)indexes.push(i);return indexes}},{key:\"arrayAllMaxIndexes\",value:function(array){return this.getAllIndexes(array,Math.max.apply(null,array))}}]);return NeedlemanWunsch}();\nmodule.exports=exports},function(module,exports,__webpack_require__){exports=function(){};exports.FDLayout=__webpack_require__(18);exports.FDLayoutConstants=__webpack_require__(7);exports.FDLayoutEdge=__webpack_require__(19);exports.FDLayoutNode=__webpack_require__(20);exports.DimensionD=__webpack_require__(21);exports.HashMap=__webpack_require__(22);exports.HashSet=__webpack_require__(23);exports.IGeometry=__webpack_require__(8);exports.IMath=__webpack_require__(9);exports.Integer=__webpack_require__(10);\nexports.Point=__webpack_require__(12);exports.PointD=__webpack_require__(4);exports.RandomSeed=__webpack_require__(16);exports.RectangleD=__webpack_require__(13);exports.Transform=__webpack_require__(17);exports.UniqueIDGeneretor=__webpack_require__(14);exports.Quicksort=__webpack_require__(24);exports.LinkedList=__webpack_require__(11);exports.LGraphObject=__webpack_require__(2);exports.LGraph=__webpack_require__(5);exports.LEdge=__webpack_require__(1);exports.LGraphManager=__webpack_require__(6);\nexports.LNode=__webpack_require__(3);exports.Layout=__webpack_require__(15);exports.LayoutConstants=__webpack_require__(0);exports.NeedlemanWunsch=__webpack_require__(25);module.exports=exports},function(module,exports,__webpack_require__){function Emitter(){this.listeners=[]}exports=Emitter.prototype;exports.addListener=function(event,callback){this.listeners.push({event,callback})};exports.removeListener=function(event,callback){for(var i=this.listeners.length;0<=i;i--){var l=this.listeners[i];\nl.event===event&&l.callback===callback&&this.listeners.splice(i,1)}};exports.emit=function(event,data){for(var i=0;i<this.listeners.length;i++){var l=this.listeners[i];event===l.event&&l.callback(data)}};module.exports=Emitter}])})}","~:source","shadow$provide[\"module$node_modules$layout_base$layout_base\"] = function(global,require,module,exports) {\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"layoutBase\"] = factory();\n\telse\n\t\troot[\"layoutBase\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar RectangleD = __webpack_require__(13);\nvar LayoutConstants = __webpack_require__(0);\nvar RandomSeed = __webpack_require__(16);\nvar PointD = __webpack_require__(4);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth > width) {\n        this.rect.x -= (this.labelWidth - width) / 2;\n        this.setWidth(this.labelWidth);\n      }\n\n      if (this.labelHeight > height) {\n        if (this.labelPos == \"center\") {\n          this.rect.y -= (this.labelHeight - height) / 2;\n        } else if (this.labelPos == \"top\") {\n          this.rect.y -= this.labelHeight - height;\n        }\n        this.setHeight(this.labelHeight);\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __webpack_require__(2);\nvar Integer = __webpack_require__(10);\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar RectangleD = __webpack_require__(13);\nvar Point = __webpack_require__(12);\nvar LinkedList = __webpack_require__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __webpack_require__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __webpack_require__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __webpack_require__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __webpack_require__(0);\nvar LGraphManager = __webpack_require__(6);\nvar LNode = __webpack_require__(3);\nvar LEdge = __webpack_require__(1);\nvar LGraph = __webpack_require__(5);\nvar PointD = __webpack_require__(4);\nvar Transform = __webpack_require__(17);\nvar Emitter = __webpack_require__(27);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PointD = __webpack_require__(4);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __webpack_require__(15);\nvar FDLayoutConstants = __webpack_require__(7);\nvar LayoutConstants = __webpack_require__(0);\nvar IGeometry = __webpack_require__(8);\nvar IMath = __webpack_require__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LEdge = __webpack_require__(1);\nvar FDLayoutConstants = __webpack_require__(7);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar LNode = __webpack_require__(3);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __webpack_require__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __webpack_require__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __webpack_require__(18);\nlayoutBase.FDLayoutConstants = __webpack_require__(7);\nlayoutBase.FDLayoutEdge = __webpack_require__(19);\nlayoutBase.FDLayoutNode = __webpack_require__(20);\nlayoutBase.DimensionD = __webpack_require__(21);\nlayoutBase.HashMap = __webpack_require__(22);\nlayoutBase.HashSet = __webpack_require__(23);\nlayoutBase.IGeometry = __webpack_require__(8);\nlayoutBase.IMath = __webpack_require__(9);\nlayoutBase.Integer = __webpack_require__(10);\nlayoutBase.Point = __webpack_require__(12);\nlayoutBase.PointD = __webpack_require__(4);\nlayoutBase.RandomSeed = __webpack_require__(16);\nlayoutBase.RectangleD = __webpack_require__(13);\nlayoutBase.Transform = __webpack_require__(17);\nlayoutBase.UniqueIDGeneretor = __webpack_require__(14);\nlayoutBase.Quicksort = __webpack_require__(24);\nlayoutBase.LinkedList = __webpack_require__(11);\nlayoutBase.LGraphObject = __webpack_require__(2);\nlayoutBase.LGraph = __webpack_require__(5);\nlayoutBase.LEdge = __webpack_require__(1);\nlayoutBase.LGraphManager = __webpack_require__(6);\nlayoutBase.LNode = __webpack_require__(3);\nlayoutBase.Layout = __webpack_require__(15);\nlayoutBase.LayoutConstants = __webpack_require__(0);\nlayoutBase.NeedlemanWunsch = __webpack_require__(25);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["addAll","ADAPTATION_LOWER_NODE_LIMIT","getMaxY","IGeometry","getWorldOrgX","setDeviceExtY","updateLeftTop","callback","d","floor","getCenterX","n","map","compoundGravityRangeFactor","ceil","setWorldOrgX","surrounding","repulsionConstant","idealEdgeLength","initParameters","compoundGravityConstant","tail","oldTotalDisplacement","setRect","DEFAULT_REPULSION_STRENGTH","owner","tracebackGrid","calcSeparationAmount","DimensionD","setGraphManager","score","incremental","graphManager","doPostLayout","LGraphManager","getDeviceExtY","createBendsAsNeeded","allEdges","getLocation","positionNodesRandomly","s","moveNodes","width","getDeviceOrgX","pos","getWidth","PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR","setCenter","right","vGraphObject","angleOfVector","DEFAULT_ANIMATION_ON_LAYOUT","DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR","next","newGraph","top","keys","RectangleD","setWorldExtX","getFlatForest","setLocation","HALF_PI","lworldOrgX","gravityRangeFactor","setWidth","graphs","finishX","getLeft","FDLayoutNode","estimatedSize","uniformLeafNodeSizes","DEFAULT_GRAPH_MARGIN","calcLowestCommonAncestors","getDifference","getAllEdges","translate","getWidthHalf","inclusionTreeDepth","allNodes","prototype","height","margin","getTargetInLca","initSpringEmbedder","updateLength","grid","repulsionForceX","seq1","EMPTY_COMPOUND_NODE_SIZE","resetAllNodesToApplyGravitation","put","useFRGridVariant","transformY","animationPeriod","getMaxX","getDiagonal","updateGrid","addAllTo","child","p","gravitationForceX","MAX_NODE_DISPLACEMENT","LayoutConstants","getWorldOrgY","initialCoolingFactor","getString","contains","DEFAULT_EDGE_LENGTH","key","calcGravitationalForce","setHeight","parent","maxIterations","calcNoOfChildrenForAllNodes","ONE_AND_HALF_PI","newNode","x","SIMPLE_NODE_HALF_SIZE","getEdgesBetween","newEdge","WORLD_CENTER_X","coolingFactor","DEFAULT_SPRING_STRENGTH","compareFunction","noOfChildren","lworldExtX","TWO_PI","ldeviceOrgX","calculateRepulsionForceOfANode","DEFAULT_ANIMATION_DURING_LAYOUT","gravityConstant","isConnected","lengthX","getOtherEndInGraph","calculateBounds","LGraphObject","isSubLayout","HashSet","findCenterOfTree","transform","toString","getMinY","getSourceInLca","checkLayoutSuccess","DEFAULT_GRAVITY_RANGE_FACTOR","event","withChildren","setWorldOrgY","getIntersection","setWorldExtY","DEFAULT_COMPOUND_GRAVITY_STRENGTH","getCenterY","startY","bendpoints","isPrimitive","Quicksort","update","calcGrid","createDummyNodesForBendpoints","springForceY","getGraphs","updateConnected","MAX_VALUE","isRemoteUse","lworldExtY","getGraphManager","FDLayoutEdge","transformX","getLayout","ldeviceExtX","getBendpoints","decideDirectionsForOverlappingNodes","WORLD_CENTER_Y","getNodes","DEFAULT_CREATE_BENDS_AS_NEEDED","scatter","addRoot","jMax","configurable","startX","calcIdealEdgeLengths","getWorldExtX","ldeviceOrgY","animate","getEdgeListToNode","animationOnLayout","getBottom","value","inverseTransformX","removeListener","gravitationForceY","getY","match_score","getEstimatedSize","alignments","INITIAL_WORLD_BOUNDARY","isOverlapingSourceAndTarget","enumerable","getCenter","seed","addListener","getNeighborsList","getSource","calcGravitationalForces","getRight","FDLayoutConstants","SIMPLE_NODE_SIZE","emit","prev","calcSpringForce","getParent","remove","LEdge","setDeviceExtX","DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION","RandomSeed","displacementThresholdPerNode","layout","writable","updateLengthSimple","getOwner","getInclusionTreeDepth","QUALITY","getRoot","sourceInLca","allNodesToApplyGravitation","getChild","inverseTransformY","getOtherEnd","getWorldExtY","DEFAULT_COOLING_FACTOR_INCREMENTAL","doIntersect","calcRepulsionForces","getX","getAllNodes","setDeviceOrgX","keySet","maxNodeDisplacement","NODE_DIMENSIONS_INCLUDE_LABELS","getIntersection2","repulsionForceY","getHeight","Integer","Point","length","getLength","getCopy","Transform","isOneAncestorOfOther","resetAllNodes","nodes","head","updateBounds","setRootGraph","calcInclusionTreeDepths","getCardinalDirection","edgeToDummyNodes","COOLING_ADAPTATION_FACTOR","setY","DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION","move","MIN_EDGE_LENGTH","DEFAULT_INCREMENTAL","HashMap","i","GRID_CALCULATION_CHECK_PERIOD","update2","source","edges","DEFAULT_UNIFORM_LEAF_NODE_SIZES","ldeviceExtY","y","seq2","displacementX","LinkedList","createID","moveBy","setX","lworldOrgY","setGridCoordinates","LGraph","inverseTransformPoint","target","FDLayout","setAllNodesToApplyGravitation","finishY","sequence1","repulsionRange","getNoOfChildren","l","newGraphManager","WORLD_BOUNDARY","PointD","LNode","notAnimatedIterations","MAX_NODE_DISPLACEMENT_INCREMENTAL","gap_penalty","calcSpringForces","getMinX","springForceX","CONVERGENCE_CHECK_PERIOD","addNodeToGrid","add","useSmartIdealEdgeLengthCalculation","bottom","set","totalIterations","sequence2","createBendpointsFromDummyNodes","mismatch_penalty","getTarget","rect","getDeviceExtX","setDeviceOrgY","isEmpty","DEFAULT_ANIMATION_PERIOD","size","springConstant","displacementY","ADAPTATION_UPPER_NODE_LIMIT","isLayoutFinished","clear","isConverged","lengthY","uniqueID","getTop","UniqueIDGeneretor","MIN_VALUE","DEFAULT_GRAVITY_STRENGTH","getEdges","nextDouble","lca","IMath","calcRepulsionForce","getHeightHalf","MIN_REPULSION_DIST","listeners","getDeviceOrgY","getLca","m","isInterGraph","lastID","get","getAllNodesToApplyGravitation","calcLowestCommonAncestor","sign","totalDisplacementThreshold","layoutQuality","equals","intersects","THREE_PI","getHalfTheDiagonal","calcRepulsionRange","NeedlemanWunsch","resetAllEdges","MAX_ITERATIONS","includesInvalidEdge","o","c","Layout","left","totalDisplacement","RANDOM_SEED","getRect","runLayout","rootGraph","animationDuringLayout","calcEstimatedSize","targetInLca","idealLength","iMax"]],"~:compiled-at",1621210441986,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$layout_base$layout_base.js\",\n\"lineCount\":141,\n\"mappings\":\"AAAAA,cAAA,CAAA,2CAAA,CAAgE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,eAAhB,CAAuBC,gBAAvB,CAAgC,CACvGC,SAAyC,CAACC,IAAD,CAAOC,OAAP,CAAgB,CACnC,QAAtB,GAAG,MAAOH,iBAAV,EAAoD,QAApD,GAAkC,MAAOD,gBAAzC,CACCA,eAAOC,CAAAA,OADR,CACkBG,OAAA,EADlB,CAE0B,UAArB,GAAG,MAAOC,OAAV,EAAmCA,MAAOC,CAAAA,GAA1C,CACJD,MAAA,CAAO,EAAP,CAAWD,OAAX,CADI,CAEsB,QAAtB,GAAG,MAAOH,iBAAV,CACJA,gBAAA,CAAA,UADI,CACoBG,OAAA,EADpB,CAGJD,IAAA,CAAA,UAHI,CAGiBC,OAAA,EARmC,CAAzDF,CAAD,CASG,IATH,CASS,QAAQ,EAAG,CACpB,MAAiB,SAAQ,CAACK,OAAD,CAAU,CAKzBC,QAASA,oBAAmB,CAACC,QAAD,CAAW,CAGtC,GAAGC,gBAAA,CAAiBD,QAAjB,CAAH,CACC,MAAOC,iBAAA,CAAiBD,QAAjB,CAA2BR,CAAAA,OAGnC;IAAID,OAASU,gBAAA,CAAiBD,QAAjB,CAATT,CAAsC,CACzCW,EAAGF,QADsC,CAEzCG,EAAG,CAAA,CAFsC,CAGzCX,QAAS,EAHgC,CAO1CM,QAAA,CAAQE,QAAR,CAAkBI,CAAAA,IAAlB,CAAuBb,MAAOC,CAAAA,OAA9B,CAAuCD,MAAvC,CAA+CA,MAAOC,CAAAA,OAAtD,CAA+DO,mBAA/D,CAGAR,OAAOY,CAAAA,CAAP,CAAW,CAAA,CAGX,OAAOZ,OAAOC,CAAAA,OApBwB,CAHvC,IAAIS,iBAAmB,EA4BvBF,oBAAoBM,CAAAA,CAApB,CAAwBP,OAGxBC,oBAAoBO,CAAAA,CAApB,CAAwBL,gBAGxBF,oBAAoBG,CAAAA,CAApB,CAAwBK,QAAQ,CAACC,KAAD,CAAQ,CAAE,MAAOA,MAAT,CAGxCT,oBAAoBU,CAAAA,CAApB,CAAwBC,QAAQ,CAAClB,OAAD,CAAUmB,IAAV,CAAgBC,MAAhB,CAAwB,CACnDb,mBAAoBc,CAAAA,CAApB,CAAsBrB,OAAtB,CAA+BmB,IAA/B,CAAJ,EACCG,MAAOC,CAAAA,cAAP,CAAsBvB,OAAtB,CAA+BmB,IAA/B,CAAqC,CACpCK,aAAc,CAAA,CADsB,CAEpCC,WAAY,CAAA,CAFwB,CAGpCC,IAAKN,MAH+B,CAArC,CAFsD,CAWxDb,oBAAoBoB,CAAAA,CAApB;AAAwBC,QAAQ,CAAC7B,MAAD,CAAS,CACxC,IAAIqB,OAASrB,MAAA,EAAUA,MAAO8B,CAAAA,UAAjB,CACZC,QAAmB,EAAG,CAAE,MAAO/B,OAAA,CAAO,SAAP,CAAT,CADV,CAEZgC,QAAyB,EAAG,CAAE,MAAOhC,OAAT,CAC7BQ,oBAAoBU,CAAAA,CAApB,CAAsBG,MAAtB,CAA8B,GAA9B,CAAmCA,MAAnC,CACA,OAAOA,OALiC,CASzCb,oBAAoBc,CAAAA,CAApB,CAAwBW,QAAQ,CAACC,MAAD,CAASC,QAAT,CAAmB,CAAE,MAAOZ,OAAOa,CAAAA,SAAUC,CAAAA,cAAexB,CAAAA,IAAhC,CAAqCqB,MAArC,CAA6CC,QAA7C,CAAT,CAGnD3B,oBAAoB8B,CAAAA,CAApB,CAAwB,EAGxB,OAAO9B,oBAAA,CAAoBA,mBAAoB+B,CAAAA,CAAxC,CAA4C,EAA5C,CAjEkB,CAAnB,CAoEN,CAEH,QAAQ,CAACvC,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtDgC,QAASA,gBAAe,EAAG,EAK3BA,eAAgBC,CAAAA,OAAhB,CAA0B,CAK1BD,gBAAgBE,CAAAA,8BAAhB;AAAiD,CAAA,CACjDF,gBAAgBG,CAAAA,mBAAhB,CAAsC,CAAA,CACtCH,gBAAgBI,CAAAA,2BAAhB,CAA8C,CAAA,CAC9CJ,gBAAgBK,CAAAA,+BAAhB,CAAkD,CAAA,CAClDL,gBAAgBM,CAAAA,wBAAhB,CAA2C,EAC3CN,gBAAgBO,CAAAA,+BAAhB,CAAkD,CAAA,CASlDP,gBAAgBQ,CAAAA,oBAAhB,CAAuC,EAKvCR,gBAAgBS,CAAAA,8BAAhB,CAAiD,CAAA,CAKjDT,gBAAgBU,CAAAA,gBAAhB,CAAmC,EAKnCV,gBAAgBW,CAAAA,qBAAhB,CAAwCX,eAAgBU,CAAAA,gBAAxD,CAA2E,CAM3EV,gBAAgBY,CAAAA,wBAAhB,CAA2C,EAK3CZ,gBAAgBa,CAAAA,eAAhB;AAAkC,CAKlCb,gBAAgBc,CAAAA,cAAhB,CAAiC,GAKjCd,gBAAgBe,CAAAA,sBAAhB,CAAyCf,eAAgBc,CAAAA,cAAzD,CAA0E,GAK1Ed,gBAAgBgB,CAAAA,cAAhB,CAAiC,IACjChB,gBAAgBiB,CAAAA,cAAhB,CAAiC,GAEjCzD,OAAOC,CAAAA,OAAP,CAAiBuC,eAzEqC,CAF5C,CA+EH,QAAQ,CAACxC,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAStDkD,QAASA,MAAK,CAACC,MAAD,CAASC,MAAT,CAAiBC,KAAjB,CAAwB,CACpCC,YAAajD,CAAAA,IAAb,CAAkB,IAAlB,CAAwBgD,KAAxB,CAEA,KAAKE,CAAAA,2BAAL,CAAmC,CAAA,CACnC,KAAKC,CAAAA,YAAL,CAAoBH,KACpB,KAAKI,CAAAA,UAAL,CAAkB,EAClB,KAAKN,CAAAA,MAAL,CAAcA,MACd,KAAKC,CAAAA,MAAL,CAAcA,MAPsB,CAJtC,IAAIE,aAAetD,mBAAA,CAAoB,CAApB,CAAnB,CACI0D,UAAY1D,mBAAA,CAAoB,CAApB,CADhB;AAEI2D,MAAQ3D,mBAAA,CAAoB,CAApB,CAYZkD,MAAMtB,CAAAA,SAAN,CAAkBb,MAAO6C,CAAAA,MAAP,CAAcN,YAAa1B,CAAAA,SAA3B,CAElB,KAAKiC,IAAIA,IAAT,GAAiBP,aAAjB,CACEJ,KAAA,CAAMW,IAAN,CAAA,CAAcP,YAAA,CAAaO,IAAb,CAGhBX,MAAMtB,CAAAA,SAAUkC,CAAAA,SAAhB,CAA4BC,QAAS,EAAG,CACtC,MAAO,KAAKZ,CAAAA,MAD0B,CAIxCD,MAAMtB,CAAAA,SAAUoC,CAAAA,SAAhB,CAA4BC,QAAS,EAAG,CACtC,MAAO,KAAKb,CAAAA,MAD0B,CAIxCF,MAAMtB,CAAAA,SAAUsC,CAAAA,YAAhB,CAA+BC,QAAS,EAAG,CACzC,MAAO,KAAKD,CAAAA,YAD6B,CAI3ChB,MAAMtB,CAAAA,SAAUwC,CAAAA,SAAhB,CAA4BC,QAAS,EAAG,CACtC,MAAO,KAAKC,CAAAA,MAD0B,CAIxCpB,MAAMtB,CAAAA,SAAU2B,CAAAA,2BAAhB,CAA8CgB,QAAS,EAAG,CACxD,MAAO,KAAKhB,CAAAA,2BAD4C,CAI1DL,MAAMtB,CAAAA,SAAU4C,CAAAA,aAAhB;AAAgCC,QAAS,EAAG,CAC1C,MAAO,KAAKhB,CAAAA,UAD8B,CAI5CP,MAAMtB,CAAAA,SAAU8C,CAAAA,MAAhB,CAAyBC,QAAS,EAAG,CACnC,MAAO,KAAKC,CAAAA,GADuB,CAIrC1B,MAAMtB,CAAAA,SAAUiD,CAAAA,cAAhB,CAAiCC,QAAS,EAAG,CAC3C,MAAO,KAAKC,CAAAA,WAD+B,CAI7C7B,MAAMtB,CAAAA,SAAUoD,CAAAA,cAAhB,CAAiCC,QAAS,EAAG,CAC3C,MAAO,KAAKC,CAAAA,WAD+B,CAI7ChC,MAAMtB,CAAAA,SAAUuD,CAAAA,WAAhB,CAA8BC,QAAS,CAACC,IAAD,CAAO,CAC5C,GAAI,IAAKlC,CAAAA,MAAT,GAAoBkC,IAApB,CACE,MAAO,KAAKjC,CAAAA,MACP,IAAI,IAAKA,CAAAA,MAAT,GAAoBiC,IAApB,CACL,MAAO,KAAKlC,CAAAA,MAEZ,MAAM,qCAAN,CAN0C,CAU9CD,MAAMtB,CAAAA,SAAU0D,CAAAA,kBAAhB,CAAqCC,QAAS,CAACF,IAAD,CAAOG,KAAP,CAAc,CACtDC,IAAAA,CAAW,IAAKN,CAAAA,WAAL,CAAiBE,IAAjB,CAGf,KAFA,IAAI1F,KAAO6F,KAAME,CAAAA,eAAN,EAAwBC,CAAAA,OAAxB,EAEX,CAAA,CAAA,CAAa,CACX,GAAIF,IAASG,CAAAA,QAAT,EAAJ;AAA2BJ,KAA3B,CACE,MAAOC,KAGT,IAAIA,IAASG,CAAAA,QAAT,EAAJ,EAA2BjG,IAA3B,CACE,KAGF8F,KAAA,CAAWA,IAASG,CAAAA,QAAT,EAAoBC,CAAAA,SAApB,EATA,CAYb,MAAO,KAhBmD,CAmB5D3C,MAAMtB,CAAAA,SAAUkE,CAAAA,YAAhB,CAA+BC,QAAS,EAAG,CACzC,IAAIC,qBAA2BC,KAAJ,CAAU,CAAV,CAE3B,KAAK1C,CAAAA,2BAAL,CAAmCG,SAAUwC,CAAAA,eAAV,CAA0B,IAAK9C,CAAAA,MAAO+C,CAAAA,OAAZ,EAA1B,CAAiD,IAAKhD,CAAAA,MAAOgD,CAAAA,OAAZ,EAAjD,CAAwEH,oBAAxE,CAE9B,KAAKzC,CAAAA,2BAAV,GACE,IAAK6C,CAAAA,OAWL,CAXeJ,oBAAA,CAAqB,CAArB,CAWf,CAXyCA,oBAAA,CAAqB,CAArB,CAWzC,CAVA,IAAKK,CAAAA,OAUL,CAVeL,oBAAA,CAAqB,CAArB,CAUf,CAVyCA,oBAAA,CAAqB,CAArB,CAUzC,CAR6B,CAQ7B,CARIM,IAAKC,CAAAA,GAAL,CAAS,IAAKH,CAAAA,OAAd,CAQJ,GAPE,IAAKA,CAAAA,OAOP,CAPiBzC,KAAM6C,CAAAA,IAAN,CAAW,IAAKJ,CAAAA,OAAhB,CAOjB;AAJ6B,CAI7B,CAJIE,IAAKC,CAAAA,GAAL,CAAS,IAAKF,CAAAA,OAAd,CAIJ,GAHE,IAAKA,CAAAA,OAGP,CAHiB1C,KAAM6C,CAAAA,IAAN,CAAW,IAAKH,CAAAA,OAAhB,CAGjB,EAAA,IAAK/B,CAAAA,MAAL,CAAcgC,IAAKG,CAAAA,IAAL,CAAU,IAAKL,CAAAA,OAAf,CAAyB,IAAKA,CAAAA,OAA9B,CAAwC,IAAKC,CAAAA,OAA7C,CAAuD,IAAKA,CAAAA,OAA5D,CAZhB,CALyC,CAqB3CnD,MAAMtB,CAAAA,SAAU8E,CAAAA,kBAAhB,CAAqCC,QAAS,EAAG,CAC/C,IAAKP,CAAAA,OAAL,CAAe,IAAKhD,CAAAA,MAAOwD,CAAAA,UAAZ,EAAf,CAA0C,IAAKzD,CAAAA,MAAOyD,CAAAA,UAAZ,EAC1C,KAAKP,CAAAA,OAAL,CAAe,IAAKjD,CAAAA,MAAOyD,CAAAA,UAAZ,EAAf,CAA0C,IAAK1D,CAAAA,MAAO0D,CAAAA,UAAZ,EAEb,EAA7B,CAAIP,IAAKC,CAAAA,GAAL,CAAS,IAAKH,CAAAA,OAAd,CAAJ,GACE,IAAKA,CAAAA,OADP,CACiBzC,KAAM6C,CAAAA,IAAN,CAAW,IAAKJ,CAAAA,OAAhB,CADjB,CAI6B,EAA7B,CAAIE,IAAKC,CAAAA,GAAL,CAAS,IAAKF,CAAAA,OAAd,CAAJ,GACE,IAAKA,CAAAA,OADP,CACiB1C,KAAM6C,CAAAA,IAAN,CAAW,IAAKH,CAAAA,OAAhB,CADjB,CAIA,KAAK/B,CAAAA,MAAL,CAAcgC,IAAKG,CAAAA,IAAL,CAAU,IAAKL,CAAAA,OAAf,CAAyB,IAAKA,CAAAA,OAA9B,CAAwC,IAAKC,CAAAA,OAA7C;AAAuD,IAAKA,CAAAA,OAA5D,CAZiC,CAejD7G,OAAOC,CAAAA,OAAP,CAAiByD,KA9HqC,CA/E5C,CAiNH,QAAQ,CAAC1D,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAStDR,MAAOC,CAAAA,OAAP,CAJA6D,QAAqB,CAACE,YAAD,CAAe,CAClC,IAAKA,CAAAA,YAAL,CAAoBA,YADc,CALkB,CAjN5C,CA8NH,QAAQ,CAAChE,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAYtD8G,QAASA,MAAK,CAACC,EAAD,CAAKC,GAAL,CAAUC,IAAV,CAAgBC,KAAhB,CAAuB,CAEvB,IAAZ,EAAID,IAAJ,EAA6B,IAA7B,EAAoBC,KAApB,GACEA,KADF,CACUF,GADV,CAIA1D,aAAajD,CAAAA,IAAb,CAAkB,IAAlB,CAAwB6G,KAAxB,CAGuB,KAAvB,EAAIH,EAAGI,CAAAA,YAAP,GAA6BJ,EAA7B,CAAkCA,EAAGI,CAAAA,YAArC,CAEA,KAAKC,CAAAA,aAAL,CAAqBC,OAAQC,CAAAA,SAC7B,KAAKC,CAAAA,kBAAL,CAA0BF,OAAQG,CAAAA,SAClC,KAAKhE,CAAAA,YAAL,CAAoB0D,KACpB,KAAKO,CAAAA,KAAL,CAAa,EACb,KAAKN,CAAAA,YAAL,CAAoBJ,EAEa,KAAKW,CAAAA,IAAL,CAArB,IAAZ,EAAIT,IAAJ;AAA2B,IAA3B,EAAoBD,GAApB,CAA6C,IAAIW,UAAJ,CAAeX,GAAIY,CAAAA,CAAnB,CAAsBZ,GAAIa,CAAAA,CAA1B,CAA6BZ,IAAKa,CAAAA,KAAlC,CAAyCb,IAAKc,CAAAA,MAA9C,CAA7C,CAAoH,IAAIJ,UAjBrF,CAPrC,IAAIrE,aAAetD,mBAAA,CAAoB,CAApB,CAAnB,CACIqH,QAAUrH,mBAAA,CAAoB,EAApB,CADd,CAEI2H,WAAa3H,mBAAA,CAAoB,EAApB,CAFjB,CAGIgC,gBAAkBhC,mBAAA,CAAoB,CAApB,CAHtB,CAIIgI,WAAahI,mBAAA,CAAoB,EAApB,CAJjB,CAKIiI,OAASjI,mBAAA,CAAoB,CAApB,CAsBb8G,MAAMlF,CAAAA,SAAN,CAAkBb,MAAO6C,CAAAA,MAAP,CAAcN,YAAa1B,CAAAA,SAA3B,CAClB,KAAKiC,IAAIA,IAAT,GAAiBP,aAAjB,CACEwD,KAAA,CAAMjD,IAAN,CAAA,CAAcP,YAAA,CAAaO,IAAb,CAGhBiD,MAAMlF,CAAAA,SAAUsG,CAAAA,QAAhB,CAA2BC,QAAS,EAAG,CACrC,MAAO,KAAKV,CAAAA,KADyB,CAIvCX,MAAMlF,CAAAA,SAAUwG,CAAAA,QAAhB,CAA2BC,QAAS,EAAG,CACrC,MAAO,KAAKC,CAAAA,KADyB,CAIvCxB;KAAMlF,CAAAA,SAAUgE,CAAAA,QAAhB,CAA2B2C,QAAS,EAAG,CAOrC,MAAO,KAAKC,CAAAA,KAPyB,CAUvC1B,MAAMlF,CAAAA,SAAU6G,CAAAA,QAAhB,CAA2BC,QAAS,EAAG,CACrC,MAAO,KAAKhB,CAAAA,IAAKI,CAAAA,KADoB,CAIvChB,MAAMlF,CAAAA,SAAU+G,CAAAA,QAAhB,CAA2BC,QAAS,CAACd,KAAD,CAAQ,CAC1C,IAAKJ,CAAAA,IAAKI,CAAAA,KAAV,CAAkBA,KADwB,CAI5ChB,MAAMlF,CAAAA,SAAUiH,CAAAA,SAAhB,CAA4BC,QAAS,EAAG,CACtC,MAAO,KAAKpB,CAAAA,IAAKK,CAAAA,MADqB,CAIxCjB,MAAMlF,CAAAA,SAAUmH,CAAAA,SAAhB,CAA4BC,QAAS,CAACjB,MAAD,CAAS,CAC5C,IAAKL,CAAAA,IAAKK,CAAAA,MAAV,CAAmBA,MADyB,CAI9CjB,MAAMlF,CAAAA,SAAUgF,CAAAA,UAAhB,CAA6BqC,QAAS,EAAG,CACvC,MAAO,KAAKvB,CAAAA,IAAKE,CAAAA,CAAjB,CAAqB,IAAKF,CAAAA,IAAKI,CAAAA,KAA/B,CAAuC,CADA,CAIzChB,MAAMlF,CAAAA,SAAUiF,CAAAA,UAAhB,CAA6BqC,QAAS,EAAG,CACvC,MAAO,KAAKxB,CAAAA,IAAKG,CAAAA,CAAjB,CAAqB,IAAKH,CAAAA,IAAKK,CAAAA,MAA/B,CAAwC,CADD,CAIzCjB,MAAMlF,CAAAA,SAAUuH,CAAAA,SAAhB,CAA4BC,QAAS,EAAG,CACtC,MAAO,KAAInB,MAAJ,CAAW,IAAKP,CAAAA,IAAKE,CAAAA,CAArB;AAAyB,IAAKF,CAAAA,IAAKI,CAAAA,KAAnC,CAA2C,CAA3C,CAA8C,IAAKJ,CAAAA,IAAKG,CAAAA,CAAxD,CAA4D,IAAKH,CAAAA,IAAKK,CAAAA,MAAtE,CAA+E,CAA/E,CAD+B,CAIxCjB,MAAMlF,CAAAA,SAAUyH,CAAAA,WAAhB,CAA8BC,QAAS,EAAG,CACxC,MAAO,KAAIrB,MAAJ,CAAW,IAAKP,CAAAA,IAAKE,CAAAA,CAArB,CAAwB,IAAKF,CAAAA,IAAKG,CAAAA,CAAlC,CADiC,CAI1Cf,MAAMlF,CAAAA,SAAUuE,CAAAA,OAAhB,CAA0BoD,QAAS,EAAG,CACpC,MAAO,KAAK7B,CAAAA,IADwB,CAItCZ,MAAMlF,CAAAA,SAAU4H,CAAAA,WAAhB,CAA8BC,QAAS,EAAG,CACxC,MAAOnD,KAAKG,CAAAA,IAAL,CAAU,IAAKiB,CAAAA,IAAKI,CAAAA,KAApB,CAA4B,IAAKJ,CAAAA,IAAKI,CAAAA,KAAtC,CAA8C,IAAKJ,CAAAA,IAAKK,CAAAA,MAAxD,CAAiE,IAAKL,CAAAA,IAAKK,CAAAA,MAA3E,CADiC,CAO1CjB,MAAMlF,CAAAA,SAAU8H,CAAAA,kBAAhB,CAAqCC,QAAS,EAAG,CAC/C,MAAOrD,KAAKG,CAAAA,IAAL,CAAU,IAAKiB,CAAAA,IAAKK,CAAAA,MAApB,CAA6B,IAAKL,CAAAA,IAAKK,CAAAA,MAAvC,CAAgD,IAAKL,CAAAA,IAAKI,CAAAA,KAA1D,CAAkE,IAAKJ,CAAAA,IAAKI,CAAAA,KAA5E,CAAP,CAA4F,CAD7C,CAIjDhB,MAAMlF,CAAAA,SAAUgI,CAAAA,OAAhB,CAA0BC,QAAS,CAACC,SAAD,CAAYC,SAAZ,CAAuB,CACxD,IAAKrC,CAAAA,IAAKE,CAAAA,CAAV;AAAckC,SAAUlC,CAAAA,CACxB,KAAKF,CAAAA,IAAKG,CAAAA,CAAV,CAAciC,SAAUjC,CAAAA,CACxB,KAAKH,CAAAA,IAAKI,CAAAA,KAAV,CAAkBiC,SAAUjC,CAAAA,KAC5B,KAAKJ,CAAAA,IAAKK,CAAAA,MAAV,CAAmBgC,SAAUhC,CAAAA,MAJ2B,CAO1DjB,MAAMlF,CAAAA,SAAUoI,CAAAA,SAAhB,CAA4BC,QAAS,CAACC,EAAD,CAAKC,EAAL,CAAS,CAC5C,IAAKzC,CAAAA,IAAKE,CAAAA,CAAV,CAAcsC,EAAd,CAAmB,IAAKxC,CAAAA,IAAKI,CAAAA,KAA7B,CAAqC,CACrC,KAAKJ,CAAAA,IAAKG,CAAAA,CAAV,CAAcsC,EAAd,CAAmB,IAAKzC,CAAAA,IAAKK,CAAAA,MAA7B,CAAsC,CAFM,CAK9CjB,MAAMlF,CAAAA,SAAUwI,CAAAA,WAAhB,CAA8BC,QAAS,CAACzC,CAAD,CAAIC,CAAJ,CAAO,CAC5C,IAAKH,CAAAA,IAAKE,CAAAA,CAAV,CAAcA,CACd,KAAKF,CAAAA,IAAKG,CAAAA,CAAV,CAAcA,CAF8B,CAK9Cf,MAAMlF,CAAAA,SAAU0I,CAAAA,MAAhB,CAAyBC,QAAS,CAACC,EAAD,CAAKC,EAAL,CAAS,CACzC,IAAK/C,CAAAA,IAAKE,CAAAA,CAAV,EAAe4C,EACf,KAAK9C,CAAAA,IAAKG,CAAAA,CAAV,EAAe4C,EAF0B,CAK3C3D,MAAMlF,CAAAA,SAAU8I,CAAAA,iBAAhB,CAAoCC,QAAS,CAACC,EAAD,CAAK,CAChD,IAAIC,SAAW,EAAf,CAEIC,KAAO,IAEXA,KAAKrD,CAAAA,KAAMsD,CAAAA,OAAX,CAAmB,QAAS,CAACC,IAAD,CAAO,CAEjC,GAAIA,IAAK5H,CAAAA,MAAT,EAAmBwH,EAAnB,CAAuB,CACrB,GAAII,IAAK7H,CAAAA,MAAT,EAAmB2H,IAAnB,CAAyB,KAAM,wBAAN;AAEzBD,QAASI,CAAAA,IAAT,CAAcD,IAAd,CAHqB,CAFU,CAAnC,CASA,OAAOH,SAdyC,CAiBlD/D,MAAMlF,CAAAA,SAAUsJ,CAAAA,eAAhB,CAAkCC,QAAS,CAACC,KAAD,CAAQ,CACjD,IAAIP,SAAW,EAAf,CAGIC,KAAO,IACXA,KAAKrD,CAAAA,KAAMsD,CAAAA,OAAX,CAAmB,QAAS,CAACC,IAAD,CAAO,CAEjC,GAAMA,IAAK7H,CAAAA,MAAX,EAAqB2H,IAArB,EAA6BE,IAAK5H,CAAAA,MAAlC,EAA4C0H,IAA5C,CAAmD,KAAM,qCAAN,CAE/CE,IAAK5H,CAAAA,MAAT,EAAmBgI,KAAnB,EAA4BJ,IAAK7H,CAAAA,MAAjC,EAA2CiI,KAA3C,EACEP,QAASI,CAAAA,IAAT,CAAcD,IAAd,CAL+B,CAAnC,CASA,OAAOH,SAd0C,CAiBnD/D,MAAMlF,CAAAA,SAAUyJ,CAAAA,gBAAhB,CAAmCC,QAAS,EAAG,CAC7C,IAAIC,UAAY,IAAIC,GAApB,CAEIV,KAAO,IACXA,KAAKrD,CAAAA,KAAMsD,CAAAA,OAAX,CAAmB,QAAS,CAACC,IAAD,CAAO,CAEjC,GAAIA,IAAK7H,CAAAA,MAAT,EAAmB2H,IAAnB,CACES,SAAUE,CAAAA,GAAV,CAAcT,IAAK5H,CAAAA,MAAnB,CADF,KAEO,CACL,GAAI4H,IAAK5H,CAAAA,MAAT,EAAmB0H,IAAnB,CACE,KAAM,sBAAN;AAGFS,SAAUE,CAAAA,GAAV,CAAcT,IAAK7H,CAAAA,MAAnB,CALK,CAJ0B,CAAnC,CAaA,OAAOoI,UAjBsC,CAoB/CzE,MAAMlF,CAAAA,SAAU8J,CAAAA,YAAhB,CAA+BC,QAAS,EAAG,CACzC,IAAIC,kBAAoB,IAAIJ,GAI5BI,kBAAkBH,CAAAA,GAAlB,CAAsB,IAAtB,CAEA,IAAkB,IAAlB,EAAI,IAAKnD,CAAAA,KAAT,CAEE,IADA,IAAIuD,MAAQ,IAAKvD,CAAAA,KAAMwD,CAAAA,QAAX,EAAZ,CACS3L,EAAI,CAAb,CAAgBA,CAAhB,CAAoB0L,KAAMvH,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,CAAuC,CACrC,IAAA4L,UAAYF,KAAA,CAAM1L,CAAN,CACZ6L,UAAA,CAAWD,SAAUL,CAAAA,YAAV,EACXM,UAASjB,CAAAA,OAAT,CAAiB,QAAS,CAAC1F,IAAD,CAAO,CAC/BuG,iBAAkBH,CAAAA,GAAlB,CAAsBpG,IAAtB,CAD+B,CAAjC,CAHqC,CASzC,MAAOuG,kBAlBkC,CAqB3C9E,MAAMlF,CAAAA,SAAUqK,CAAAA,eAAhB,CAAkCC,QAAS,EAAG,CAC5C,IAAIC,aAAe,CAGnB,IAAkB,IAAlB,EAAI,IAAK7D,CAAAA,KAAT,CACE6D,YAAA,CAAe,CADjB,KAIE,KADA,IAAIN,MAAQ,IAAKvD,CAAAA,KAAMwD,CAAAA,QAAX,EAAZ;AACS3L,EAAI,CAAb,CAAgBA,CAAhB,CAAoB0L,KAAMvH,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,CAAuC,CACrC,IAAA4L,UAAYF,KAAA,CAAM1L,CAAN,CAEZgM,aAAA,EAAgBJ,SAAUE,CAAAA,eAAV,EAHqB,CAOrB,CAApB,EAAIE,YAAJ,GACEA,YADF,CACiB,CADjB,CAGA,OAAOA,aAlBqC,CAqB9CrF,MAAMlF,CAAAA,SAAUwK,CAAAA,gBAAhB,CAAmCC,QAAS,EAAG,CAC7C,GAAI,IAAKjF,CAAAA,aAAT,EAA0BC,OAAQC,CAAAA,SAAlC,CACE,KAAM,eAAN,CAEF,MAAO,KAAKF,CAAAA,aAJiC,CAO/CN,MAAMlF,CAAAA,SAAU0K,CAAAA,iBAAhB,CAAoCC,QAAS,EAAG,CAC9C,GAAkB,IAAlB,EAAI,IAAKjE,CAAAA,KAAT,CACE,MAAO,KAAKlB,CAAAA,aAAZ,EAA6B,IAAKM,CAAAA,IAAKI,CAAAA,KAAvC,CAA+C,IAAKJ,CAAAA,IAAKK,CAAAA,MAAzD,EAAmE,CAEnE,KAAKX,CAAAA,aAAL,CAAqB,IAAKkB,CAAAA,KAAMgE,CAAAA,iBAAX,EACrB,KAAK5E,CAAAA,IAAKI,CAAAA,KAAV,CAAkB,IAAKV,CAAAA,aAGvB,OAFA,KAAKM,CAAAA,IAAKK,CAAAA,MAEV;AAFmB,IAAKX,CAAAA,aANoB,CAYhDN,MAAMlF,CAAAA,SAAU4K,CAAAA,OAAhB,CAA0BC,QAAS,EAAG,CAIhCC,IAAAA,cAAO,CAAC1K,eAAgBe,CAAAA,sBACxB4J,KAAAA,cAAO3K,eAAgBe,CAAAA,sBAC3B6J,cAAA,CAAgB5K,eAAgBgB,CAAAA,cAAhC,CAAiDgF,UAAW6E,CAAAA,UAAX,EAAjD,EAA4EF,aAA5E,CAAmFD,aAAnF,EAA2FA,aAEvFI,cAAAA,CAAO,CAAC9K,eAAgBe,CAAAA,sBAC5B,KAAIgK,KAAO/K,eAAgBe,CAAAA,sBAC3BiK,cAAA,CAAgBhL,eAAgBiB,CAAAA,cAAhC,CAAiD+E,UAAW6E,CAAAA,UAAX,EAAjD,EAA4EE,IAA5E,CAAmFD,aAAnF,EAA2FA,aAE3F,KAAKpF,CAAAA,IAAKE,CAAAA,CAAV;AAAcgF,aACd,KAAKlF,CAAAA,IAAKG,CAAAA,CAAV,CAAcmF,aAbsB,CAgBtClG,MAAMlF,CAAAA,SAAUqL,CAAAA,YAAhB,CAA+BC,QAAS,EAAG,CACzC,GAAuB,IAAvB,EAAI,IAAK9E,CAAAA,QAAL,EAAJ,CACE,KAAM,eAAN,CAEF,GAAyC,CAAzC,EAAI,IAAKA,CAAAA,QAAL,EAAgB0D,CAAAA,QAAhB,EAA2BxH,CAAAA,MAA/B,CAA4C,CAE1C,IAAI6I,WAAa,IAAK/E,CAAAA,QAAL,EACjB+E,WAAWF,CAAAA,YAAX,CAAwB,CAAA,CAAxB,CAEA,KAAKvF,CAAAA,IAAKE,CAAAA,CAAV,CAAcuF,UAAWC,CAAAA,OAAX,EACd,KAAK1F,CAAAA,IAAKG,CAAAA,CAAV,CAAcsF,UAAWE,CAAAA,MAAX,EAEd,KAAK1E,CAAAA,QAAL,CAAcwE,UAAWG,CAAAA,QAAX,EAAd,CAAsCH,UAAWC,CAAAA,OAAX,EAAtC,CACA,KAAKrE,CAAAA,SAAL,CAAeoE,UAAWI,CAAAA,SAAX,EAAf,CAAwCJ,UAAWE,CAAAA,MAAX,EAAxC,CAGA,IAAIrL,eAAgBS,CAAAA,8BAApB,CAAoD,CAElD,IAAIqF,MAAQqF,UAAWG,CAAAA,QAAX,EAARxF,CAAgCqF,UAAWC,CAAAA,OAAX,EAChCrF;UAAAA,CAASoF,UAAWI,CAAAA,SAAX,EAATxF,CAAkCoF,UAAWE,CAAAA,MAAX,EAElC,KAAKG,CAAAA,UAAT,CAAsB1F,KAAtB,GACE,IAAKJ,CAAAA,IAAKE,CAAAA,CACV,GADgB,IAAK4F,CAAAA,UACrB,CADkC1F,KAClC,EAD2C,CAC3C,CAAA,IAAKa,CAAAA,QAAL,CAAc,IAAK6E,CAAAA,UAAnB,CAFF,CAKI,KAAKC,CAAAA,WAAT,CAAuB1F,UAAvB,GACuB,QAArB,EAAI,IAAK2F,CAAAA,QAAT,CACE,IAAKhG,CAAAA,IAAKG,CAAAA,CADZ,GACkB,IAAK4F,CAAAA,WADvB,CACqC1F,UADrC,EAC+C,CAD/C,CAE4B,KAF5B,EAEW,IAAK2F,CAAAA,QAFhB,GAGE,IAAKhG,CAAAA,IAAKG,CAAAA,CAHZ,EAGiB,IAAK4F,CAAAA,WAHtB,CAGoC1F,UAHpC,CAKA,CAAA,IAAKgB,CAAAA,SAAL,CAAe,IAAK0E,CAAAA,WAApB,CANF,CAVkD,CAZV,CAJH,CAsC3C3G,MAAMlF,CAAAA,SAAU+L,CAAAA,qBAAhB,CAAwCC,QAAS,EAAG,CAClD,GAAI,IAAKrG,CAAAA,kBAAT,EAA+BF,OAAQG,CAAAA,SAAvC,CACE,KAAM,eAAN,CAEF,MAAO,KAAKD,CAAAA,kBAJsC,CAOpDT,MAAMlF,CAAAA,SAAUiM,CAAAA,SAAhB;AAA4BC,QAAS,CAACC,KAAD,CAAQ,CAC3C,IAAIC,KAAO,IAAKtG,CAAAA,IAAKE,CAAAA,CAEjBoG,KAAJ,CAAWhM,eAAgBc,CAAAA,cAA3B,CACEkL,IADF,CACShM,eAAgBc,CAAAA,cADzB,CAEWkL,IAFX,CAEkB,CAAChM,eAAgBc,CAAAA,cAFnC,GAGEkL,IAHF,CAGS,CAAChM,eAAgBc,CAAAA,cAH1B,CAMA,KAAImL,IAAM,IAAKvG,CAAAA,IAAKG,CAAAA,CAEhBoG,IAAJ,CAAUjM,eAAgBc,CAAAA,cAA1B,CACEmL,GADF,CACQjM,eAAgBc,CAAAA,cADxB,CAEWmL,GAFX,CAEiB,CAACjM,eAAgBc,CAAAA,cAFlC,GAGEmL,GAHF,CAGQ,CAACjM,eAAgBc,CAAAA,cAHzB,CAMIoL,KAAAA,CAAU,IAAIjG,MAAJ,CAAW+F,IAAX,CAAiBC,GAAjB,CACVE,MAAAA,CAAWJ,KAAMK,CAAAA,qBAAN,CAA4BF,IAA5B,CAEf,KAAK9D,CAAAA,WAAL,CAAiB+D,KAASvG,CAAAA,CAA1B,CAA6BuG,KAAStG,CAAAA,CAAtC,CApB2C,CAuB7Cf,MAAMlF,CAAAA,SAAUwL,CAAAA,OAAhB,CAA0BiB,QAAS,EAAG,CACpC,MAAO,KAAK3G,CAAAA,IAAKE,CAAAA,CADmB,CAItCd;KAAMlF,CAAAA,SAAU0L,CAAAA,QAAhB,CAA2BgB,QAAS,EAAG,CACrC,MAAO,KAAK5G,CAAAA,IAAKE,CAAAA,CAAjB,CAAqB,IAAKF,CAAAA,IAAKI,CAAAA,KADM,CAIvChB,MAAMlF,CAAAA,SAAUyL,CAAAA,MAAhB,CAAyBkB,QAAS,EAAG,CACnC,MAAO,KAAK7G,CAAAA,IAAKG,CAAAA,CADkB,CAIrCf,MAAMlF,CAAAA,SAAU2L,CAAAA,SAAhB,CAA4BiB,QAAS,EAAG,CACtC,MAAO,KAAK9G,CAAAA,IAAKG,CAAAA,CAAjB,CAAqB,IAAKH,CAAAA,IAAKK,CAAAA,MADO,CAIxCjB,MAAMlF,CAAAA,SAAUiE,CAAAA,SAAhB,CAA4B4I,QAAS,EAAG,CACtC,MAAkB,KAAlB,EAAI,IAAKjG,CAAAA,KAAT,CACS,IADT,CAIO,IAAKA,CAAAA,KAAM3C,CAAAA,SAAX,EAL+B,CAQxCrG,OAAOC,CAAAA,OAAP,CAAiBqH,KA3VqC,CA9N5C,CA6jBH,QAAQ,CAACtH,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtDiI,QAASA,OAAM,CAACL,CAAD,CAAIC,CAAJ,CAAO,CACX,IAAT,EAAID,CAAJ,EAAsB,IAAtB,EAAiBC,CAAjB,CAEE,IAAKA,CAAAA,CAFP,CACE,IAAKD,CAAAA,CADP,CACW,CADX,EAIE,IAAKA,CAAAA,CACL,CADSA,CACT,CAAA,IAAKC,CAAAA,CAAL,CAASA,CALX,CADoB,CAUtBI,MAAOrG,CAAAA,SAAU8M,CAAAA,IAAjB,CAAwBC,QAAS,EAAG,CAClC,MAAO,KAAK/G,CAAAA,CADsB,CAIpCK,OAAOrG,CAAAA,SAAUgN,CAAAA,IAAjB;AAAwBC,QAAS,EAAG,CAClC,MAAO,KAAKhH,CAAAA,CADsB,CAIpCI,OAAOrG,CAAAA,SAAUkN,CAAAA,IAAjB,CAAwBC,QAAS,CAACnH,CAAD,CAAI,CACnC,IAAKA,CAAAA,CAAL,CAASA,CAD0B,CAIrCK,OAAOrG,CAAAA,SAAUoN,CAAAA,IAAjB,CAAwBC,QAAS,CAACpH,CAAD,CAAI,CACnC,IAAKA,CAAAA,CAAL,CAASA,CAD0B,CAIrCI,OAAOrG,CAAAA,SAAUsN,CAAAA,aAAjB,CAAiCC,QAAS,CAACC,EAAD,CAAK,CAC7C,MAAO,KAAIC,UAAJ,CAAe,IAAKzH,CAAAA,CAApB,CAAwBwH,EAAGxH,CAAAA,CAA3B,CAA8B,IAAKC,CAAAA,CAAnC,CAAuCuH,EAAGvH,CAAAA,CAA1C,CADsC,CAI/CI,OAAOrG,CAAAA,SAAU0N,CAAAA,OAAjB,CAA2BC,QAAS,EAAG,CACrC,MAAO,KAAItH,MAAJ,CAAW,IAAKL,CAAAA,CAAhB,CAAmB,IAAKC,CAAAA,CAAxB,CAD8B,CAIvCI,OAAOrG,CAAAA,SAAU4N,CAAAA,SAAjB,CAA6BC,QAAS,CAACC,GAAD,CAAM,CAC1C,IAAK9H,CAAAA,CAAL,EAAU8H,GAAI5H,CAAAA,KACd,KAAKD,CAAAA,CAAL,EAAU6H,GAAI3H,CAAAA,MACd,OAAO,KAHmC,CAM5CvI,OAAOC,CAAAA,OAAP,CAAiBwI,MA7CqC,CA7jB5C,CA8mBH,QAAQ,CAACzI,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAetD2P,QAASA,OAAM,CAACC,MAAD,CAASC,IAAT,CAAeC,MAAf,CAAuB,CACpCxM,YAAajD,CAAAA,IAAb,CAAkB,IAAlB,CAAwByP,MAAxB,CACA;IAAK1I,CAAAA,aAAL,CAAqBC,OAAQC,CAAAA,SAC7B,KAAKyI,CAAAA,MAAL,CAAc/N,eAAgBQ,CAAAA,oBAC9B,KAAKiF,CAAAA,KAAL,CAAa,EACb,KAAKoE,CAAAA,KAAL,CAAa,EACb,KAAKmE,CAAAA,WAAL,CAAmB,CAAA,CACnB,KAAKJ,CAAAA,MAAL,CAAcA,MAEF,KAAZ,EAAIC,IAAJ,EAAoBA,IAApB,WAAoCI,cAApC,CACE,IAAK9I,CAAAA,YADP,CACsB0I,IADtB,CAEmB,IAFnB,EAEWA,IAFX,EAE2BA,IAF3B,WAE2CK,OAF3C,GAGE,IAAK/I,CAAAA,YAHP,CAGsB0I,IAAK1I,CAAAA,YAH3B,CAToC,CAVtC,IAAI7D,aAAetD,mBAAA,CAAoB,CAApB,CAAnB,CACIqH,QAAUrH,mBAAA,CAAoB,EAApB,CADd,CAEIgC,gBAAkBhC,mBAAA,CAAoB,CAApB,CAFtB,CAGIiQ,cAAgBjQ,mBAAA,CAAoB,CAApB,CAHpB,CAII8G,MAAQ9G,mBAAA,CAAoB,CAApB,CAJZ,CAKIkD,MAAQlD,mBAAA,CAAoB,CAApB,CALZ,CAMI2H;AAAa3H,mBAAA,CAAoB,EAApB,CANjB,CAOImQ,MAAQnQ,mBAAA,CAAoB,EAApB,CAPZ,CAQIoQ,WAAapQ,mBAAA,CAAoB,EAApB,CAkBjB2P,OAAO/N,CAAAA,SAAP,CAAmBb,MAAO6C,CAAAA,MAAP,CAAcN,YAAa1B,CAAAA,SAA3B,CACnB,KAAKiC,IAAIA,IAAT,GAAiBP,aAAjB,CACEqM,MAAA,CAAO9L,IAAP,CAAA,CAAeP,YAAA,CAAaO,IAAb,CAGjB8L,OAAO/N,CAAAA,SAAUkK,CAAAA,QAAjB,CAA4BuE,QAAS,EAAG,CACtC,MAAO,KAAKxE,CAAAA,KAD0B,CAIxC8D,OAAO/N,CAAAA,SAAUsG,CAAAA,QAAjB,CAA4BoI,QAAS,EAAG,CACtC,MAAO,KAAK7I,CAAAA,KAD0B,CAIxCkI,OAAO/N,CAAAA,SAAU8D,CAAAA,eAAjB,CAAmC6K,QAAS,EAAG,CAC7C,MAAO,KAAKpJ,CAAAA,YADiC,CAI/CwI,OAAO/N,CAAAA,SAAUiE,CAAAA,SAAjB,CAA6B2K,QAAS,EAAG,CACvC,MAAO,KAAKZ,CAAAA,MAD2B,CAIzCD,OAAO/N,CAAAA,SAAUwL,CAAAA,OAAjB,CAA2BqD,QAAS,EAAG,CACrC,MAAO,KAAKzC,CAAAA,IADyB,CAIvC2B,OAAO/N,CAAAA,SAAU0L,CAAAA,QAAjB;AAA4BoD,QAAS,EAAG,CACtC,MAAO,KAAKC,CAAAA,KAD0B,CAIxChB,OAAO/N,CAAAA,SAAUyL,CAAAA,MAAjB,CAA0BuD,QAAS,EAAG,CACpC,MAAO,KAAK3C,CAAAA,GADwB,CAItC0B,OAAO/N,CAAAA,SAAU2L,CAAAA,SAAjB,CAA6BsD,QAAS,EAAG,CACvC,MAAO,KAAKC,CAAAA,MAD2B,CAIzCnB,OAAO/N,CAAAA,SAAUoO,CAAAA,WAAjB,CAA+Be,QAAS,EAAG,CACzC,MAAO,KAAKf,CAAAA,WAD6B,CAI3CL,OAAO/N,CAAAA,SAAU6J,CAAAA,GAAjB,CAAuBuF,QAAS,CAACC,IAAD,CAAOC,UAAP,CAAmBC,UAAnB,CAA+B,CAC7D,GAAkB,IAAlB,EAAID,UAAJ,EAAwC,IAAxC,EAA0BC,UAA1B,CAA8C,CAE5C,GAAyB,IAAzB,EAAI,IAAKhK,CAAAA,YAAT,CACE,KAAM,yBAAN,CAEF,GAAuC,EAAvC,CAAI,IAAK2E,CAAAA,QAAL,EAAgBsF,CAAAA,OAAhB,CAJUH,IAIV,CAAJ,CACE,KAAM,wBAAN,CALYA,IAONzI,CAAAA,KAAR,CAAgB,IAChB,KAAKsD,CAAAA,QAAL,EAAgBb,CAAAA,IAAhB,CARcgG,IAQd,CAT4C,CAA9C,IAYO,CAEL,GAAI,EAAwC,EAAxC,CAAE,IAAKnF,CAAAA,QAAL,EAAgBsF,CAAAA,OAAhB,CAAwBF,UAAxB,CAAF;AAAoF,EAApF,CAA8C,IAAKpF,CAAAA,QAAL,EAAgBsF,CAAAA,OAAhB,CAAwBD,UAAxB,CAA9C,CAAJ,CACE,KAAM,gCAAN,CAGF,GAAMD,UAAW1I,CAAAA,KAAjB,EAA0B2I,UAAW3I,CAAAA,KAArC,EAA8C0I,UAAW1I,CAAAA,KAAzD,EAAkE,IAAlE,CACE,KAAM,iCAAN,CAGF,GAAI0I,UAAW1I,CAAAA,KAAf,EAAwB2I,UAAW3I,CAAAA,KAAnC,CACE,MAAO,KAVKyI,KAcN9N,CAAAA,MAAR,CAAiB+N,UAdHD,KAeN7N,CAAAA,MAAR,CAAiB+N,UAfHF,KAkBN/M,CAAAA,YAAR,CAAuB,CAAA,CAGvB,KAAKgE,CAAAA,QAAL,EAAgB+C,CAAAA,IAAhB,CArBcgG,IAqBd,CAGAC,WAAWzJ,CAAAA,KAAMwD,CAAAA,IAAjB,CAxBcgG,IAwBd,CAEIE,WAAJ,EAAkBD,UAAlB,EACEC,UAAW1J,CAAAA,KAAMwD,CAAAA,IAAjB,CA3BYgG,IA2BZ,CA5BG,CADL,MAVcA,KAF6C,CAgD/DtB,OAAO/N,CAAAA,SAAUyP,CAAAA,MAAjB,CAA0BC,QAAS,CAACC,GAAD,CAAM,CAEvC,GAAIA,GAAJ,WAAmBzK,MAAnB,CAA0B,CACxB,GAAY,IAAZ,EAFSyK,GAET,CACE,KAAM,eAAN;AAEF,GAAoB,IAApB,EALSA,GAKE/I,CAAAA,KAAX,EALS+I,GAKwB/I,CAAAA,KAAjC,EAA0C,IAA1C,CACE,KAAM,yBAAN,CAEF,GAAyB,IAAzB,EAAI,IAAKrB,CAAAA,YAAT,CACE,KAAM,iCAAN,CAMF,IAHA,IAAIqK,iBAZKD,GAYmB9J,CAAAA,KAAMgK,CAAAA,KAAX,EAAvB,CACIzG,IADJ,CAEIjJ,EAAIyP,gBAAiBlN,CAAAA,MAFzB,CAGSnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CACE6K,IAEA,CAFOwG,gBAAA,CAAiBrR,CAAjB,CAEP,CAAI6K,IAAK9G,CAAAA,YAAT,CACE,IAAKiD,CAAAA,YAAakK,CAAAA,MAAlB,CAAyBrG,IAAzB,CADF,CAGEA,IAAK7H,CAAAA,MAAOqF,CAAAA,KAAM6I,CAAAA,MAAlB,CAAyBrG,IAAzB,CAKA0G,IAAAA,CAAQ,IAAK7F,CAAAA,KAAMuF,CAAAA,OAAX,CA1BHG,GA0BG,CACZ,IAAa,EAAb,EAAIG,GAAJ,CACE,KAAM,8BAAN,CAGF,IAAK7F,CAAAA,KAAM8F,CAAAA,MAAX,CAAkBD,GAAlB,CAAyB,CAAzB,CA9BwB,CAA1B,IA+BO,IAAIH,GAAJ,WAAmBrO,MAAnB,CAA0B,CAC3B8H,IAAJ,CAAWuG,GACX,IAAY,IAAZ,EAAIvG,IAAJ,CACE,KAAM,eAAN,CAEF,GAAqB,IAArB;AAAMA,IAAK7H,CAAAA,MAAX,EAA4C,IAA5C,EAA6B6H,IAAK5H,CAAAA,MAAlC,CACE,KAAM,+BAAN,CAEF,GAA2B,IAA3B,EAAM4H,IAAK7H,CAAAA,MAAOqF,CAAAA,KAAlB,EAAwD,IAAxD,EAAmCwC,IAAK5H,CAAAA,MAAOoF,CAAAA,KAA/C,EAAgEwC,IAAK7H,CAAAA,MAAOqF,CAAAA,KAA5E,EAAqF,IAArF,EAA6FwC,IAAK5H,CAAAA,MAAOoF,CAAAA,KAAzG,EAAkH,IAAlH,CACE,KAAM,wCAAN,CAGEoJ,GAAAA,CAAc5G,IAAK7H,CAAAA,MAAOsE,CAAAA,KAAM2J,CAAAA,OAAlB,CAA0BpG,IAA1B,CACd6G,iBAAAA,CAAc7G,IAAK5H,CAAAA,MAAOqE,CAAAA,KAAM2J,CAAAA,OAAlB,CAA0BpG,IAA1B,CAClB,IAAI,EAAgB,EAAhB,CAAE4G,GAAF,EAAoC,EAApC,CAAsBC,gBAAtB,CAAJ,CACE,KAAM,8CAAN,CAGF7G,IAAK7H,CAAAA,MAAOsE,CAAAA,KAAMkK,CAAAA,MAAlB,CAAyBC,GAAzB,CAAsC,CAAtC,CAEI5G,KAAK5H,CAAAA,MAAT,EAAmB4H,IAAK7H,CAAAA,MAAxB,EACE6H,IAAK5H,CAAAA,MAAOqE,CAAAA,KAAMkK,CAAAA,MAAlB,CAAyBE,gBAAzB,CAAsC,CAAtC,CAGEH,IAAJ,CAAY1G,IAAK7H,CAAAA,MAAOqF,CAAAA,KAAMN,CAAAA,QAAlB,EAA6BkJ,CAAAA,OAA7B,CAAqCpG,IAArC,CACZ;GAAa,EAAb,EAAI0G,GAAJ,CACE,KAAM,2BAAN,CAGF1G,IAAK7H,CAAAA,MAAOqF,CAAAA,KAAMN,CAAAA,QAAlB,EAA6ByJ,CAAAA,MAA7B,CAAoCD,GAApC,CAA2C,CAA3C,CA7B+B,CAjCM,CAkEzC/B,OAAO/N,CAAAA,SAAUkQ,CAAAA,aAAjB,CAAiCC,QAAS,EAAG,CAU3C,IATA,IAAI9D,IAAM5G,OAAQG,CAAAA,SAAlB,CACIwG,KAAO3G,OAAQG,CAAAA,SADnB,CAEIwK,OAFJ,CAGIC,QAHJ,CAMIpG,MAAQ,IAAKC,CAAAA,QAAL,EANZ,CAOI/J,EAAI8J,KAAMvH,CAAAA,MAPd,CASSnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CACM+R,QAQJ,CARYrG,KAAA,CAAM1L,CAAN,CAQZ,CAPA6R,OAOA,CAPUE,QAAM7E,CAAAA,MAAN,EAOV,CANA4E,QAMA,CANWC,QAAM9E,CAAAA,OAAN,EAMX,CAJIa,GAIJ,CAJU+D,OAIV,GAHE/D,GAGF,CAHQ+D,OAGR,EAAIhE,IAAJ,CAAWiE,QAAX,GACEjE,IADF,CACSiE,QADT,CAMF,IAAIhE,GAAJ,EAAW5G,OAAQG,CAAAA,SAAnB,CACE,MAAO,KAIPuI,QAAA,CADsCoC,IAAAA,EAAxC,EAAItG,KAAA,CAAM,CAAN,CAAShG,CAAAA,SAAT,EAAqBuM,CAAAA,WAAzB,CACWvG,KAAA,CAAM,CAAN,CAAShG,CAAAA,SAAT,EAAqBuM,CAAAA,WADhC,CAGW,IAAKrC,CAAAA,MAGhB;IAAK/B,CAAAA,IAAL,CAAYA,IAAZ,CAAmB+B,OACnB,KAAK9B,CAAAA,GAAL,CAAWA,GAAX,CAAiB8B,OAGjB,OAAO,KAAII,KAAJ,CAAU,IAAKnC,CAAAA,IAAf,CAAqB,IAAKC,CAAAA,GAA1B,CAvCoC,CA0C7C0B,OAAO/N,CAAAA,SAAUqL,CAAAA,YAAjB,CAAgCoF,QAAS,CAACC,SAAD,CAAY,CAcnD,IAZA,IAAItE,KAAO3G,OAAQG,CAAAA,SAAnB,CACImJ,MAAQ,CAACtJ,OAAQG,CAAAA,SADrB,CAEIyG,IAAM5G,OAAQG,CAAAA,SAFlB,CAGIsJ,OAAS,CAACzJ,OAAQG,CAAAA,SAHtB,CAIIyK,QAJJ,CAKIM,SALJ,CAMIP,OANJ,CAOIQ,UAPJ,CAUI3G,MAAQ,IAAKA,CAAAA,KAVjB,CAWI9J,EAAI8J,KAAMvH,CAAAA,MAXd,CAYSnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CACM+R,UAsBJ,CAtBYrG,KAAA,CAAM1L,CAAN,CAsBZ,CApBImS,SAoBJ,EApBgC,IAoBhC,EApBiBJ,UAAM5J,CAAAA,KAoBvB,EAnBE4J,UAAMjF,CAAAA,YAAN,EAmBF,CAjBAgF,QAiBA,CAjBWC,UAAM9E,CAAAA,OAAN,EAiBX,CAhBAmF,SAgBA,CAhBYL,UAAM5E,CAAAA,QAAN,EAgBZ,CAfA0E,OAeA,CAfUE,UAAM7E,CAAAA,MAAN,EAeV,CAdAmF,UAcA,CAdaN,UAAM3E,CAAAA,SAAN,EAcb;AAZIS,IAYJ,CAZWiE,QAYX,GAXEjE,IAWF,CAXSiE,QAWT,EARItB,KAQJ,CARY4B,SAQZ,GAPE5B,KAOF,CAPU4B,SAOV,EAJItE,GAIJ,CAJU+D,OAIV,GAHE/D,GAGF,CAHQ+D,OAGR,EAAIlB,MAAJ,CAAa0B,UAAb,GACE1B,MADF,CACW0B,UADX,CAKEC,UAAAA,CAAe,IAAI9K,UAAJ,CAAeqG,IAAf,CAAqBC,GAArB,CAA0B0C,KAA1B,CAAkC3C,IAAlC,CAAwC8C,MAAxC,CAAiD7C,GAAjD,CACfD,KAAJ,EAAY3G,OAAQG,CAAAA,SAApB,GACE,IAAKwG,CAAAA,IAGL,CAHY,IAAK4B,CAAAA,MAAOxC,CAAAA,OAAZ,EAGZ,CAFA,IAAKuD,CAAAA,KAEL,CAFa,IAAKf,CAAAA,MAAOtC,CAAAA,QAAZ,EAEb,CADA,IAAKW,CAAAA,GACL,CADW,IAAK2B,CAAAA,MAAOvC,CAAAA,MAAZ,EACX,CAAA,IAAKyD,CAAAA,MAAL,CAAc,IAAKlB,CAAAA,MAAOrC,CAAAA,SAAZ,EAJhB,CAQEwC,KAAA,CADsCoC,IAAAA,EAAxC,EAAItG,KAAA,CAAM,CAAN,CAAShG,CAAAA,SAAT,EAAqBuM,CAAAA,WAAzB,CACWvG,KAAA,CAAM,CAAN,CAAShG,CAAAA,SAAT,EAAqBuM,CAAAA,WADhC,CAGW,IAAKrC,CAAAA,MAGhB,KAAK/B,CAAAA,IAAL,CAAYyE,SAAa7K,CAAAA,CAAzB,CAA6BmI,IAC7B,KAAKY,CAAAA,KAAL,CAAa8B,SAAa7K,CAAAA,CAA1B,CAA8B6K,SAAa3K,CAAAA,KAA3C;AAAmDiI,IACnD,KAAK9B,CAAAA,GAAL,CAAWwE,SAAa5K,CAAAA,CAAxB,CAA4BkI,IAC5B,KAAKe,CAAAA,MAAL,CAAc2B,SAAa5K,CAAAA,CAA3B,CAA+B4K,SAAa1K,CAAAA,MAA5C,CAAqDgI,IA3DF,CA8DrDJ,OAAO+C,CAAAA,eAAP,CAAyBC,QAAS,CAAC9G,KAAD,CAAQ,CAYxC,IAXA,IAAImC,KAAO3G,OAAQG,CAAAA,SAAnB,CACImJ,MAAQ,CAACtJ,OAAQG,CAAAA,SADrB,CAEIyG,IAAM5G,OAAQG,CAAAA,SAFlB,CAGIsJ,OAAS,CAACzJ,OAAQG,CAAAA,SAHtB,CAIIyK,QAJJ,CAKIM,SALJ,CAMIP,OANJ,CAOIQ,UAPJ,CASIzQ,EAAI8J,KAAMvH,CAAAA,MATd,CAWSnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CACM+R,UAkBJ,CAlBYrG,KAAA,CAAM1L,CAAN,CAkBZ,CAjBA8R,QAiBA,CAjBWC,UAAM9E,CAAAA,OAAN,EAiBX,CAhBAmF,SAgBA,CAhBYL,UAAM5E,CAAAA,QAAN,EAgBZ,CAfA0E,OAeA,CAfUE,UAAM7E,CAAAA,MAAN,EAeV,CAdAmF,UAcA,CAdaN,UAAM3E,CAAAA,SAAN,EAcb,CAZIS,IAYJ,CAZWiE,QAYX,GAXEjE,IAWF,CAXSiE,QAWT,EARItB,KAQJ,CARY4B,SAQZ,GAPE5B,KAOF,CAPU4B,SAOV,EAJItE,GAIJ,CAJU+D,OAIV;CAHE/D,GAGF,CAHQ+D,OAGR,EAAIlB,MAAJ,CAAa0B,UAAb,GACE1B,MADF,CACW0B,UADX,CAOF,OAFmBC,KAAI9K,UAAJ8K,CAAezE,IAAfyE,CAAqBxE,GAArBwE,CAA0B9B,KAA1B8B,CAAkCzE,IAAlCyE,CAAwC3B,MAAxC2B,CAAiDxE,GAAjDwE,CApCqB,CAyC1C9C,OAAO/N,CAAAA,SAAU+L,CAAAA,qBAAjB,CAAyCiF,QAAS,EAAG,CACnD,MAAI,KAAJ,EAAY,IAAKzL,CAAAA,YAAaxB,CAAAA,OAAlB,EAAZ,CACS,CADT,CAGS,IAAKiK,CAAAA,MAAOjC,CAAAA,qBAAZ,EAJ0C,CAQrDgC,OAAO/N,CAAAA,SAAUwK,CAAAA,gBAAjB,CAAoCyG,QAAS,EAAG,CAC9C,GAAI,IAAKzL,CAAAA,aAAT,EAA0BC,OAAQC,CAAAA,SAAlC,CACE,KAAM,eAAN,CAEF,MAAO,KAAKF,CAAAA,aAJkC,CAOhDuI,OAAO/N,CAAAA,SAAU0K,CAAAA,iBAAjB,CAAqCwG,QAAS,EAAG,CAK/C,IAJA,IAAI7L,KAAO,CAAX,CACI4E,MAAQ,IAAKA,CAAAA,KADjB,CAEI9J,EAAI8J,KAAMvH,CAAAA,MAFd,CAISnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CAEE8G,IAAA,EADY4E,KAAAqG,CAAM/R,CAAN+R,CACE5F,CAAAA,iBAAN,EASV;MALE,KAAKlF,CAAAA,aAKP,CANY,CAAZ,EAAIH,IAAJ,CACuBjF,eAAgBY,CAAAA,wBADvC,CAGuBqE,IAHvB,CAG8BX,IAAKG,CAAAA,IAAL,CAAU,IAAKoF,CAAAA,KAAMvH,CAAAA,MAArB,CAbiB,CAmBjDqL,OAAO/N,CAAAA,SAAUmR,CAAAA,eAAjB,CAAmCC,QAAS,EAAG,CAC7C,IAAIlI,KAAO,IACX,IAAyB,CAAzB,EAAI,IAAKe,CAAAA,KAAMvH,CAAAA,MAAf,CACE,IAAK0L,CAAAA,WAAL,CAAmB,CAAA,CADrB,KAAA,CAKA,IAAIiD,MAAQ,IAAI7C,UAAhB,CACI8C,QAAU,IAAI1H,GADlB,CAEI2H,YAAc,IAAKtH,CAAAA,KAAL,CAAW,CAAX,CASlB,KANqBsH,WAAYzH,CAAAA,YAAZ0H,EACNrI,CAAAA,OAAf,CAAuB,QAAS,CAAC1F,IAAD,CAAO,CACrC4N,KAAMhI,CAAAA,IAAN,CAAW5F,IAAX,CACA6N,QAAQzH,CAAAA,GAAR,CAAYpG,IAAZ,CAFqC,CAAvC,CAKA,CAAwB,CAAxB,GAAO4N,KAAM3O,CAAAA,MAAb,CAAA,CAA2B,CACzB6O,WAAA,CAAcF,KAAMI,CAAAA,KAAN,EAGd,KAAAC,cAAgBH,WAAYjL,CAAAA,QAAZ,EAEhB,KADA,IAAIjB,KAAOqM,aAAchP,CAAAA,MAAzB,CACSnE,EAAI,CAAb,CAAgBA,CAAhB;AAAoB8G,IAApB,CAA0B9G,CAAA,EAA1B,CAA+B,CAE7B,IAAAoT,gBADmBD,aAAAE,CAAcrT,CAAdqT,CACYlO,CAAAA,kBAAb,CAAgC6N,WAAhC,CAA6C,IAA7C,CAGK,KAAvB,EAAII,eAAJ,EAAgCL,OAAQO,CAAAA,GAAR,CAAYF,eAAZ,CAAhC,EAC2BA,eAAgB7H,CAAAA,YAAhBgI,EAEN3I,CAAAA,OAAnB,CAA2B,QAAS,CAAC1F,IAAD,CAAO,CACzC4N,KAAMhI,CAAAA,IAAN,CAAW5F,IAAX,CACA6N,QAAQzH,CAAAA,GAAR,CAAYpG,IAAZ,CAFyC,CAA3C,CAR2B,CANN,CAsB3B,IAAK2K,CAAAA,WAAL,CAAmB,CAAA,CAEnB,IAAIkD,OAAQjM,CAAAA,IAAZ,EAAoB,IAAK4E,CAAAA,KAAMvH,CAAAA,MAA/B,CAAuC,CACrC,IAAIqP,uBAAyB,CAE7BT,QAAQnI,CAAAA,OAAR,CAAgB,QAAS,CAAC6I,WAAD,CAAc,CACjCA,WAAYpL,CAAAA,KAAhB,EAAyBsC,IAAzB,EACE6I,sBAAA,EAFmC,CAAvC,CAMIA,uBAAJ,EAA8B,IAAK9H,CAAAA,KAAMvH,CAAAA,MAAzC,GACE,IAAK0L,CAAAA,WADP,CACqB,CAAA,CADrB,CATqC,CAxCvC,CAF6C,CAyD/CxQ,OAAOC,CAAAA,OAAP,CAAiBkQ,MAtaqC,CA9mB5C,CAwhCH,QAAQ,CAACnQ,MAAD;AAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAQtDiQ,QAASA,cAAa,CAAC4D,MAAD,CAAS,CAC7BlE,MAAA,CAAS3P,mBAAA,CAAoB,CAApB,CACT,KAAK6T,CAAAA,MAAL,CAAcA,MAEd,KAAKC,CAAAA,MAAL,CAAc,EACd,KAAKrM,CAAAA,KAAL,CAAa,EALgB,CAH/B,IAAIkI,MAAJ,CACIzM,MAAQlD,mBAAA,CAAoB,CAApB,CAUZiQ,cAAcrO,CAAAA,SAAUmS,CAAAA,OAAxB,CAAkCC,QAAS,EAAG,CAC5C,IAAIC,OAAS,IAAKJ,CAAAA,MAAOK,CAAAA,QAAZ,EAAb,CACIC,MAAQ,IAAKN,CAAAA,MAAOO,CAAAA,OAAZ,CAAoB,IAApB,CACRzU,OAAAA,CAAO,IAAK8L,CAAAA,GAAL,CAASwI,MAAT,CAAiBE,KAAjB,CACX,KAAKE,CAAAA,YAAL,CAAkB1U,MAAlB,CACA,OAAO,KAAK2U,CAAAA,SALgC,CAQ9CrE,cAAcrO,CAAAA,SAAU6J,CAAAA,GAAxB,CAA8B8I,QAAS,CAACL,QAAD,CAAWM,UAAX,CAAuBC,OAAvB,CAAgCvD,UAAhC,CAA4CC,UAA5C,CAAwD,CAE7F,GAAe,IAAf,EAAIsD,OAAJ,EAAqC,IAArC,EAAuBvD,UAAvB,EAA2D,IAA3D,EAA6CC,UAA7C,CAAiE,CAC/D,GAAgB,IAAhB;AAAI+C,QAAJ,CACE,KAAM,gBAAN,CAEF,GAAkB,IAAlB,EAAIM,UAAJ,CACE,KAAM,sBAAN,CAEF,GAAoC,EAApC,CAAI,IAAKV,CAAAA,MAAO1C,CAAAA,OAAZ,CAAoB8C,QAApB,CAAJ,CACE,KAAM,kCAAN,CAGF,IAAKJ,CAAAA,MAAO7I,CAAAA,IAAZ,CAAiBiJ,QAAjB,CAEA,IAAuB,IAAvB,EAAIA,QAAStE,CAAAA,MAAb,CACE,KAAM,uBAAN,CAEF,GAAwB,IAAxB,EAAI4E,UAAWlM,CAAAA,KAAf,CACE,KAAM,sBAAN,CAGF4L,QAAStE,CAAAA,MAAT,CAAkB4E,UAGlB,OAFAA,WAAWlM,CAAAA,KAEX,CAFmB4L,QArB4C,CA0B/D/C,UAAA,CAAasD,OACbvD,WAAA,CAAasD,UACbC,QAAA,CAAUP,QACNQ,SAAAA,CAAcxD,UAAWtL,CAAAA,QAAX,EACd+O,WAAAA,CAAcxD,UAAWvL,CAAAA,QAAX,EAElB,IAAqB,IAArB,EAAM8O,QAAN,EAA6BA,QAAYhP,CAAAA,eAAZ,EAA7B;AAA8D,IAA9D,CACE,KAAM,+BAAN,CAEF,GAAqB,IAArB,EAAMiP,UAAN,EAA6BA,UAAYjP,CAAAA,eAAZ,EAA7B,EAA8D,IAA9D,CACE,KAAM,+BAAN,CAGF,GAAIgP,QAAJ,EAAmBC,UAAnB,CAEE,MADAF,QAAQvQ,CAAAA,YACD,CADgB,CAAA,CAChB,CAAAwQ,QAAYjJ,CAAAA,GAAZ,CAAgBgJ,OAAhB,CAAyBvD,UAAzB,CAAqCC,UAArC,CAEPsD,QAAQvQ,CAAAA,YAAR,CAAuB,CAAA,CAGvBuQ,QAAQtR,CAAAA,MAAR,CAAiB+N,UACjBuD,QAAQrR,CAAAA,MAAR,CAAiB+N,UAGjB,IAAkC,EAAlC,CAAI,IAAK1J,CAAAA,KAAM2J,CAAAA,OAAX,CAAmBqD,OAAnB,CAAJ,CACE,KAAM,wCAAN,CAGF,IAAKhN,CAAAA,KAAMwD,CAAAA,IAAX,CAAgBwJ,OAAhB,CAGA,IAAwB,IAAxB,EAAMA,OAAQtR,CAAAA,MAAd,EAAkD,IAAlD,EAAgCsR,OAAQrR,CAAAA,MAAxC,CACE,KAAM,oCAAN;AAGF,GAA+C,EAA/C,EAAMqR,OAAQtR,CAAAA,MAAOsE,CAAAA,KAAM2J,CAAAA,OAArB,CAA6BqD,OAA7B,CAAN,EAA8F,EAA9F,EAAqDA,OAAQrR,CAAAA,MAAOqE,CAAAA,KAAM2J,CAAAA,OAArB,CAA6BqD,OAA7B,CAArD,CACE,KAAM,sDAAN,CAGFA,OAAQtR,CAAAA,MAAOsE,CAAAA,KAAMwD,CAAAA,IAArB,CAA0BwJ,OAA1B,CACAA,QAAQrR,CAAAA,MAAOqE,CAAAA,KAAMwD,CAAAA,IAArB,CAA0BwJ,OAA1B,CAEA,OAAOA,QAtEkF,CA2E/FxE,cAAcrO,CAAAA,SAAUyP,CAAAA,MAAxB,CAAiCuD,QAAS,CAACC,IAAD,CAAO,CAC/C,GAAIA,IAAJ,WAAoBlF,OAApB,CAA4B,CAE1B,GADYkF,IACFnP,CAAAA,eAAN,EAAJ,EAA+B,IAA/B,CACE,KAAM,6BAAN,CAEF,GAJYmP,IAIZ,EAAe,IAAKP,CAAAA,SAApB,GAAiD,IAAjD,EAJYO,IAI2BjF,CAAAA,MAAvC,EAJYiF,IAImDjF,CAAAA,MAAOzI,CAAAA,YAAtE,EAAsF,IAAtF,EACE,KAAM,sBAAN,CAIF,IAAIqK,iBAAmB,EAEvBA;gBAAA,CAAmBA,gBAAiBsD,CAAAA,MAAjB,CAXPD,IAWqC3M,CAAAA,QAAN,EAAxB,CAInB,KAFA,IAAI8C,IAAJ,CACIjJ,EAAIyP,gBAAiBlN,CAAAA,MADzB,CAESnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CACE6K,IACA,CADOwG,gBAAA,CAAiBrR,CAAjB,CACP,CAjBU0U,IAiBJxD,CAAAA,MAAN,CAAarG,IAAb,CAIE+J,KAAAA,CAAmB,EAEvBA,KAAA,CAAmBA,IAAiBD,CAAAA,MAAjB,CAvBPD,IAuBqC/I,CAAAA,QAAN,EAAxB,CAGnB/J,EAAA,CAAIgT,IAAiBzQ,CAAAA,MACrB,KAASnE,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CACEkF,gBACA,CADO0P,IAAA,CAAiB5U,CAAjB,CACP,CA7BU0U,IA6BJxD,CAAAA,MAAN,CAAahM,gBAAb,CA7BUwP,KAiCZ,EAAa,IAAKP,CAAAA,SAAlB,EACE,IAAKD,CAAAA,YAAL,CAAkB,IAAlB,CAIE3C,EAAAA,CAAQ,IAAKoC,CAAAA,MAAO1C,CAAAA,OAAZ,CAtCAyD,IAsCA,CACZ,KAAKf,CAAAA,MAAOnC,CAAAA,MAAZ,CAAmBD,CAAnB,CAA0B,CAA1B,CAvCYmD,KA0CNjF,CAAAA,MAAN,CAAe,IA3CW,CAA5B,IA4CO,IAAIiF,IAAJ,WAAoB3R,MAApB,CAA2B,CAChC8H,IAAA,CAAO6J,IACP,IAAY,IAAZ,EAAI7J,IAAJ,CACE,KAAM,eAAN,CAEF,GAAI,CAACA,IAAK9G,CAAAA,YAAV,CACE,KAAM,0BAAN;AAEF,GAAqB,IAArB,EAAM8G,IAAK7H,CAAAA,MAAX,EAA4C,IAA5C,EAA6B6H,IAAK5H,CAAAA,MAAlC,CACE,KAAM,+BAAN,CAKF,GAAyC,EAAzC,EAAM4H,IAAK7H,CAAAA,MAAOsE,CAAAA,KAAM2J,CAAAA,OAAlB,CAA0BpG,IAA1B,CAAN,EAAkF,EAAlF,EAA+CA,IAAK5H,CAAAA,MAAOqE,CAAAA,KAAM2J,CAAAA,OAAlB,CAA0BpG,IAA1B,CAA/C,CACE,KAAM,8CAAN,CAGE0G,CAAJ,CAAY1G,IAAK7H,CAAAA,MAAOsE,CAAAA,KAAM2J,CAAAA,OAAlB,CAA0BpG,IAA1B,CACZA,KAAK7H,CAAAA,MAAOsE,CAAAA,KAAMkK,CAAAA,MAAlB,CAAyBD,CAAzB,CAAgC,CAAhC,CACAA,EAAA,CAAQ1G,IAAK5H,CAAAA,MAAOqE,CAAAA,KAAM2J,CAAAA,OAAlB,CAA0BpG,IAA1B,CACRA,KAAK5H,CAAAA,MAAOqE,CAAAA,KAAMkK,CAAAA,MAAlB,CAAyBD,CAAzB,CAAgC,CAAhC,CAIA,IAA2B,IAA3B,EAAM1G,IAAK7H,CAAAA,MAAOqF,CAAAA,KAAlB,EAA0E,IAA1E,EAAmCwC,IAAK7H,CAAAA,MAAOqF,CAAAA,KAAM9C,CAAAA,eAAlB,EAAnC,CACE,KAAM,kDAAN,CAEF,GAA+D,EAA/D,EAAIsF,IAAK7H,CAAAA,MAAOqF,CAAAA,KAAM9C,CAAAA,eAAlB,EAAoC+B,CAAAA,KAAM2J,CAAAA,OAA1C,CAAkDpG,IAAlD,CAAJ,CACE,KAAM,yCAAN;AAGE0G,CAAJ,CAAY1G,IAAK7H,CAAAA,MAAOqF,CAAAA,KAAM9C,CAAAA,eAAlB,EAAoC+B,CAAAA,KAAM2J,CAAAA,OAA1C,CAAkDpG,IAAlD,CACZA,KAAK7H,CAAAA,MAAOqF,CAAAA,KAAM9C,CAAAA,eAAlB,EAAoC+B,CAAAA,KAAMkK,CAAAA,MAA1C,CAAiDD,CAAjD,CAAwD,CAAxD,CAjCgC,CA7Ca,CAkFjDzB,cAAcrO,CAAAA,SAAUqL,CAAAA,YAAxB,CAAuC+H,QAAS,EAAG,CACjD,IAAKV,CAAAA,SAAUrH,CAAAA,YAAf,CAA4B,CAAA,CAA5B,CADiD,CAInDgD,cAAcrO,CAAAA,SAAUqT,CAAAA,SAAxB,CAAoCC,QAAS,EAAG,CAC9C,MAAO,KAAKpB,CAAAA,MADkC,CAIhD7D,cAAcrO,CAAAA,SAAUuT,CAAAA,WAAxB,CAAsCC,QAAS,EAAG,CAChD,GAAqB,IAArB,EAAI,IAAKC,CAAAA,QAAT,CAA2B,CAIzB,IAHA,IAAIC,SAAW,EAAf,CACIxB,OAAS,IAAKmB,CAAAA,SAAL,EADb,CAEIlT,EAAI+R,MAAOxP,CAAAA,MAFf,CAGSnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CACEmV,QAAA,CAAWA,QAASR,CAAAA,MAAT,CAAgBhB,MAAA,CAAO3T,CAAP,CAAU2L,CAAAA,QAAV,EAAhB,CAEb,KAAKuJ,CAAAA,QAAL,CAAgBC,QAPS,CAS3B,MAAO,KAAKD,CAAAA,QAVoC,CAalDpF,cAAcrO,CAAAA,SAAU2T,CAAAA,aAAxB;AAAwCC,QAAS,EAAG,CAClD,IAAKH,CAAAA,QAAL,CAAgB,IADkC,CAIpDpF,cAAcrO,CAAAA,SAAU6T,CAAAA,aAAxB,CAAwCC,QAAS,EAAG,CAClD,IAAKC,CAAAA,QAAL,CAAgB,IADkC,CAIpD1F,cAAcrO,CAAAA,SAAUgU,CAAAA,+BAAxB,CAA0DC,QAAS,EAAG,CACpE,IAAKC,CAAAA,0BAAL,CAAkC,IADkC,CAItE7F,cAAcrO,CAAAA,SAAUmU,CAAAA,WAAxB,CAAsCC,QAAS,EAAG,CAChD,GAAqB,IAArB,EAAI,IAAKL,CAAAA,QAAT,CAA2B,CAIzB,IAHA,IAAI9K,SAAW,EAAf,CACIiJ,OAAS,IAAKmB,CAAAA,SAAL,EADb,CAGS9U,EAAI,CAAb,CAAgBA,CAAhB,CAAoB2T,MAAOxP,CAAAA,MAA3B,CAAmCnE,CAAA,EAAnC,CACE0K,QAAA,CAAWA,QAASiK,CAAAA,MAAT,CAAgBhB,MAAA,CAAO3T,CAAP,CAAU+H,CAAAA,QAAV,EAAhB,CAKb,KAAKyN,CAAAA,QAAL,CAFA9K,QAEA,CAFWA,QAASiK,CAAAA,MAAT,CAAgB,IAAKrN,CAAAA,KAArB,CARc,CAY3B,MAAO,KAAKkO,CAAAA,QAboC,CAgBlD1F,cAAcrO,CAAAA,SAAUqU,CAAAA,6BAAxB;AAAwDC,QAAS,EAAG,CAClE,MAAO,KAAKJ,CAAAA,0BADsD,CAIpE7F,cAAcrO,CAAAA,SAAUuU,CAAAA,6BAAxB,CAAwDC,QAAS,CAACd,QAAD,CAAW,CAC1E,GAAuC,IAAvC,EAAI,IAAKQ,CAAAA,0BAAT,CACE,KAAM,eAAN,CAGF,IAAKA,CAAAA,0BAAL,CAAkCR,QALwC,CAQ5ErF,cAAcrO,CAAAA,SAAU+D,CAAAA,OAAxB,CAAkC0Q,QAAS,EAAG,CAC5C,MAAO,KAAK/B,CAAAA,SADgC,CAI9CrE,cAAcrO,CAAAA,SAAUyS,CAAAA,YAAxB,CAAuCiC,QAAS,CAAC9Q,KAAD,CAAQ,CACtD,GAAIA,KAAME,CAAAA,eAAN,EAAJ,EAA+B,IAA/B,CACE,KAAM,6BAAN,CAGF,IAAK4O,CAAAA,SAAL,CAAiB9O,KAEG,KAApB,EAAIA,KAAMoK,CAAAA,MAAV,GACEpK,KAAMoK,CAAAA,MADR,CACiB,IAAKiE,CAAAA,MAAOO,CAAAA,OAAZ,CAAoB,WAApB,CADjB,CAPsD,CAYxDnE;aAAcrO,CAAAA,SAAU2U,CAAAA,SAAxB,CAAoCC,QAAS,EAAG,CAC9C,MAAO,KAAK3C,CAAAA,MADkC,CAIhD5D,cAAcrO,CAAAA,SAAU6U,CAAAA,oBAAxB,CAA+CC,QAAS,CAACC,SAAD,CAAYC,UAAZ,CAAwB,CAC9E,GAAmB,IAAnB,EAAMD,SAAN,EAAyC,IAAzC,EAA2BC,UAA3B,CACE,KAAM,eAAN,CAGF,GAAID,SAAJ,EAAiBC,UAAjB,CACE,MAAO,CAAA,CAGT,KAAIC,WAAaF,SAAU/Q,CAAAA,QAAV,EAGjB,GAAG,CACD4O,UAAA,CAAaqC,UAAWhR,CAAAA,SAAX,EAEb,IAAkB,IAAlB,EAAI2O,UAAJ,CACE,KAGF,IAAIA,UAAJ,EAAkBoC,UAAlB,CACE,MAAO,CAAA,CAGTC,WAAA,CAAarC,UAAW5O,CAAAA,QAAX,EACb,IAAkB,IAAlB,EAAIiR,UAAJ,CACE,KAbD,CAAH,MAeS,CAfT,CAiBAA,WAAA,CAAaD,UAAWhR,CAAAA,QAAX,EAEb,GAAG,CACD4O,UAAA,CAAaqC,UAAWhR,CAAAA,SAAX,EAEb;GAAkB,IAAlB,EAAI2O,UAAJ,CACE,KAGF,IAAIA,UAAJ,EAAkBmC,SAAlB,CACE,MAAO,CAAA,CAGTE,WAAA,CAAarC,UAAW5O,CAAAA,QAAX,EACb,IAAkB,IAAlB,EAAIiR,UAAJ,CACE,KAbD,CAAH,MAeS,CAfT,CAiBA,OAAO,CAAA,CAhDuE,CAmDhF5G,cAAcrO,CAAAA,SAAUkV,CAAAA,yBAAxB,CAAoDC,QAAS,EAAG,CAS9D,IARA,IAAI/L,IAAJ,CACIkG,UADJ,CAEIC,UAFJ,CAII6F,mBAJJ,CAMIvP,MAAQ,IAAKsO,CAAAA,WAAL,EANZ,CAOIhU,EAAI0F,KAAMnD,CAAAA,MAPd,CAQSnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CASE,GARA6K,IAQI,CARGvD,KAAA,CAAMtH,CAAN,CAQH,CANJ+Q,UAMI,CANSlG,IAAK7H,CAAAA,MAMd,CALJgO,UAKI,CALSnG,IAAK5H,CAAAA,MAKd,CAJJ4H,IAAKpG,CAAAA,GAID,CAJO,IAIP,CAHJoG,IAAKjG,CAAAA,WAGD,CAHemM,UAGf,CAFJlG,IAAK9F,CAAAA,WAED,CAFeiM,UAEf,CAAAD,UAAA,EAAcC,UAAlB,CACEnG,IAAKpG,CAAAA,GAAL,CAAWsM,UAAWtL,CAAAA,QAAX,EADb,KAAA,CAOA,IAFAqR,UAEA;AAFsB/F,UAAWtL,CAAAA,QAAX,EAEtB,CAAmB,IAAnB,EAAOoF,IAAKpG,CAAAA,GAAZ,CAAA,CAAyB,CACvBoG,IAAK9F,CAAAA,WAAL,CAAmBiM,UAGnB,KAFA6F,mBAEA,CAFsB7F,UAAWvL,CAAAA,QAAX,EAEtB,CAAmB,IAAnB,EAAOoF,IAAKpG,CAAAA,GAAZ,CAAA,CAAyB,CACvB,GAAIoS,mBAAJ,EAA2BC,UAA3B,CAAgD,CAC9CjM,IAAKpG,CAAAA,GAAL,CAAWoS,mBACX,MAF8C,CAKhD,GAAIA,mBAAJ,EAA2B,IAAK1C,CAAAA,SAAhC,CACE,KAGF,IAAgB,IAAhB,EAAItJ,IAAKpG,CAAAA,GAAT,CACE,KAAM,eAAN,CAEFoG,IAAK9F,CAAAA,WAAL,CAAmB8R,mBAAoBnR,CAAAA,SAApB,EACnBmR,oBAAA,CAAsBhM,IAAK9F,CAAAA,WAAYU,CAAAA,QAAjB,EAdC,CAiBzB,GAAIqR,UAAJ,EAA2B,IAAK3C,CAAAA,SAAhC,CACE,KAGc,KAAhB,EAAItJ,IAAKpG,CAAAA,GAAT,GACEoG,IAAKjG,CAAAA,WACL,CADmBkS,UAAoBpR,CAAAA,SAApB,EACnB,CAAAoR,UAAA,CAAsBjM,IAAKjG,CAAAA,WAAYa,CAAAA,QAAjB,EAFxB,CAzBuB,CA+BzB,GAAgB,IAAhB;AAAIoF,IAAKpG,CAAAA,GAAT,CACE,KAAM,eAAN,CAvCF,CAlB4D,CA8DhEqL,cAAcrO,CAAAA,SAAUsV,CAAAA,wBAAxB,CAAmDC,QAAS,CAACR,SAAD,CAAYC,UAAZ,CAAwB,CAClF,GAAID,SAAJ,EAAiBC,UAAjB,CACE,MAAOD,UAAU/Q,CAAAA,QAAV,EAELwR,UAAAA,CAAkBT,SAAU/Q,CAAAA,QAAV,EAEtB,GAAG,CACD,GAAuB,IAAvB,EAAIwR,SAAJ,CACE,KAEF,KAAIC,iBAAmBT,UAAWhR,CAAAA,QAAX,EAEvB,GAAG,CACD,GAAwB,IAAxB,EAAIyR,gBAAJ,CACE,KAGF,IAAIA,gBAAJ,EAAwBD,SAAxB,CACE,MAAOC,iBAETA,iBAAA,CAAmBA,gBAAiBxR,CAAAA,SAAjB,EAA6BD,CAAAA,QAA7B,EARlB,CAAH,MASS,CATT,CAWAwR,UAAA,CAAkBA,SAAgBvR,CAAAA,SAAhB,EAA4BD,CAAAA,QAA5B,EAjBjB,CAAH,MAkBS,CAlBT,CAoBA,OAAOwR,UA1B2E,CA6BpFnH,cAAcrO,CAAAA,SAAU0V,CAAAA,uBAAxB;AAAkDC,QAAS,CAAC/R,KAAD,CAAQgS,KAAR,CAAe,CAC3D,IAAb,EAAIhS,KAAJ,EAA8B,IAA9B,EAAqBgS,KAArB,GACEhS,KACA,CADQ,IAAK8O,CAAAA,SACb,CAAAkD,KAAA,CAAQ,CAFV,CAQA,KAFA,IAAI3L,MAAQrG,KAAMsG,CAAAA,QAAN,EAAZ,CACI/J,EAAI8J,KAAMvH,CAAAA,MADd,CAESnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CACEkF,KAGA,CAHOwG,KAAA,CAAM1L,CAAN,CAGP,CAFAkF,KAAKkC,CAAAA,kBAEL,CAF0BiQ,KAE1B,CAAkB,IAAlB,EAAInS,KAAKiD,CAAAA,KAAT,EACE,IAAKgP,CAAAA,uBAAL,CAA6BjS,KAAKiD,CAAAA,KAAlC,CAAyCkP,KAAzC,CAAiD,CAAjD,CAdoE,CAmB1EvH,cAAcrO,CAAAA,SAAU6V,CAAAA,mBAAxB,CAA8CC,QAAS,EAAG,CAIxD,IAHA,IAAI1M,IAAJ,CAEIjJ,EAAI,IAAK0F,CAAAA,KAAMnD,CAAAA,MAFnB,CAGSnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CAGE,GAFA6K,IAEI,CAFG,IAAKvD,CAAAA,KAAL,CAAWtH,CAAX,CAEH,CAAA,IAAKsW,CAAAA,oBAAL,CAA0BzL,IAAK7H,CAAAA,MAA/B,CAAuC6H,IAAK5H,CAAAA,MAA5C,CAAJ,CACE,MAAO,CAAA,CAGX,OAAO,CAAA,CAXiD,CAc1D5D,OAAOC,CAAAA,OAAP,CAAiBwQ,aArbqC,CAxhC5C,CAi9CH,QAAQ,CAACzQ,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAOtD2X,QAASA,kBAAiB,EAAG;AAFzB3V,OAAAA,CAAkBhC,mBAAA,CAAoB,CAApB,CAKtB,KAAK6D,IAAIA,IAAT,GAAiB7B,QAAjB,CACE2V,iBAAA,CAAkB9T,IAAlB,CAAA,CAA0B7B,OAAA,CAAgB6B,IAAhB,CAG5B8T,kBAAkBC,CAAAA,cAAlB,CAAmC,IAEnCD,kBAAkBE,CAAAA,mBAAlB,CAAwC,EACxCF,kBAAkBG,CAAAA,uBAAlB,CAA4C,GAC5CH,kBAAkBI,CAAAA,0BAAlB,CAA+C,IAC/CJ,kBAAkBK,CAAAA,wBAAlB,CAA6C,EAC7CL,kBAAkBM,CAAAA,iCAAlB,CAAsD,CACtDN,kBAAkBO,CAAAA,4BAAlB,CAAiD,GACjDP,kBAAkBQ,CAAAA,qCAAlB,CAA0D,GAC1DR,kBAAkBS,CAAAA,+CAAlB;AAAoE,CAAA,CACpET,kBAAkBU,CAAAA,6CAAlB,CAAkE,CAAA,CAClEV,kBAAkBW,CAAAA,kCAAlB,CAAuD,EACvDX,kBAAkBY,CAAAA,yBAAlB,CAA8C,GAC9CZ,kBAAkBa,CAAAA,2BAAlB,CAAgD,GAChDb,kBAAkBc,CAAAA,2BAAlB,CAAgD,GAChDd,kBAAkBe,CAAAA,iCAAlB,CAAsD,GACtDf,kBAAkBgB,CAAAA,qBAAlB,CAAgG,CAAhG,CAA0ChB,iBAAkBe,CAAAA,iCAC5Df,kBAAkBiB,CAAAA,kBAAlB,CAAuCjB,iBAAkBE,CAAAA,mBAAzD,CAA+E,EAC/EF;iBAAkBkB,CAAAA,wBAAlB,CAA6C,GAC7ClB,kBAAkBmB,CAAAA,kCAAlB,CAAuD,EACvDnB,kBAAkB9U,CAAAA,eAAlB,CAAoC,CACpC8U,kBAAkBoB,CAAAA,6BAAlB,CAAkD,EAElDvZ,OAAOC,CAAAA,OAAP,CAAiBkY,iBArCqC,CAj9C5C,CA0/CH,QAAQ,CAACnY,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CActD0D,QAASA,UAAS,EAAG,EAFrB,IAAIyM,MAAQnQ,mBAAA,CAAoB,EAApB,CAWZ0D,UAAUsV,CAAAA,oBAAV,CAAiCC,QAAS,CAACC,KAAD,CAAQC,KAAR,CAAeC,aAAf,CAA8BC,gBAA9B,CAAgD,CACxF,GAAI,CAACH,KAAMI,CAAAA,UAAN,CAAiBH,KAAjB,CAAL,CACE,KAAM,eAAN,CAGF,IAAII,WAAiBtT,KAAJ,CAAU,CAAV,CAEjB,KAAKuT,CAAAA,mCAAL,CAAyCN,KAAzC;AAAgDC,KAAhD,CAAuDI,UAAvD,CAEAH,cAAA,CAAc,CAAd,CAAA,CAAmB9S,IAAKmT,CAAAA,GAAL,CAASP,KAAM5L,CAAAA,QAAN,EAAT,CAA2B6L,KAAM7L,CAAAA,QAAN,EAA3B,CAAnB,CAAkEhH,IAAKoT,CAAAA,GAAL,CAASR,KAAMtR,CAAAA,CAAf,CAAkBuR,KAAMvR,CAAAA,CAAxB,CAClEwR,cAAA,CAAc,CAAd,CAAA,CAAmB9S,IAAKmT,CAAAA,GAAL,CAASP,KAAM3L,CAAAA,SAAN,EAAT,CAA4B4L,KAAM5L,CAAAA,SAAN,EAA5B,CAAnB,CAAoEjH,IAAKoT,CAAAA,GAAL,CAASR,KAAMrR,CAAAA,CAAf,CAAkBsR,KAAMtR,CAAAA,CAAxB,CAGhEqR,MAAMxK,CAAAA,IAAN,EAAJ,EAAoByK,KAAMzK,CAAAA,IAAN,EAApB,EAAoCwK,KAAM5L,CAAAA,QAAN,EAApC,EAAwD6L,KAAM7L,CAAAA,QAAN,EAAxD,CAYE8L,aAAA,CAAc,CAAd,CAZF,EAYsB9S,IAAKmT,CAAAA,GAAL,CAASN,KAAMzK,CAAAA,IAAN,EAAT,CAAwBwK,KAAMxK,CAAAA,IAAN,EAAxB,CAAsCwK,KAAM5L,CAAAA,QAAN,EAAtC,CAAyD6L,KAAM7L,CAAAA,QAAN,EAAzD,CAZtB,CAaW6L,KAAMzK,CAAAA,IAAN,EAbX,EAa2BwK,KAAMxK,CAAAA,IAAN,EAb3B,EAa2CyK,KAAM7L,CAAAA,QAAN,EAb3C,EAa+D4L,KAAM5L,CAAAA,QAAN,EAb/D,GAyBE8L,aAAA,CAAc,CAAd,CAzBF,EAyBsB9S,IAAKmT,CAAAA,GAAL,CAASP,KAAMxK,CAAAA,IAAN,EAAT,CAAwByK,KAAMzK,CAAAA,IAAN,EAAxB,CAAsCyK,KAAM7L,CAAAA,QAAN,EAAtC,CAAyD4L,KAAM5L,CAAAA,QAAN,EAAzD,CAzBtB,CA2BI4L,MAAMtK,CAAAA,IAAN,EAAJ;AAAoBuK,KAAMvK,CAAAA,IAAN,EAApB,EAAoCsK,KAAM3L,CAAAA,SAAN,EAApC,EAAyD4L,KAAM5L,CAAAA,SAAN,EAAzD,CAcE6L,aAAA,CAAc,CAAd,CAdF,EAcsB9S,IAAKmT,CAAAA,GAAL,CAASN,KAAMvK,CAAAA,IAAN,EAAT,CAAwBsK,KAAMtK,CAAAA,IAAN,EAAxB,CAAsCsK,KAAM3L,CAAAA,SAAN,EAAtC,CAA0D4L,KAAM5L,CAAAA,SAAN,EAA1D,CAdtB,CAeW4L,KAAMvK,CAAAA,IAAN,EAfX,EAe2BsK,KAAMtK,CAAAA,IAAN,EAf3B,EAe2CuK,KAAM5L,CAAAA,SAAN,EAf3C,EAegE2L,KAAM3L,CAAAA,SAAN,EAfhE,GA6BE6L,aAAA,CAAc,CAAd,CA7BF,EA6BsB9S,IAAKmT,CAAAA,GAAL,CAASP,KAAMtK,CAAAA,IAAN,EAAT,CAAwBuK,KAAMvK,CAAAA,IAAN,EAAxB,CAAsCuK,KAAM5L,CAAAA,SAAN,EAAtC,CAA0D2L,KAAM3L,CAAAA,SAAN,EAA1D,CA7BtB,CAiCA,KAAIoM,MAAQrT,IAAKC,CAAAA,GAAL,EAAU4S,KAAMtS,CAAAA,UAAN,EAAV,CAA+BqS,KAAMrS,CAAAA,UAAN,EAA/B,GAAsDsS,KAAMvS,CAAAA,UAAN,EAAtD,CAA2EsS,KAAMtS,CAAAA,UAAN,EAA3E,EAERuS,MAAMtS,CAAAA,UAAN,EAAJ,GAA2BqS,KAAMrS,CAAAA,UAAN,EAA3B,EAAiDsS,KAAMvS,CAAAA,UAAN,EAAjD,GAAwEsS,KAAMtS,CAAAA,UAAN,EAAxE,GAEE+S,KAFF,CAEU,CAFV,CAKIC,MAAAA,CAAUD,KAAVC;AAAkBR,aAAA,CAAc,CAAd,CAClBS,MAAAA,CAAUT,aAAA,CAAc,CAAd,CAAVS,CAA6BF,KAC7BP,cAAA,CAAc,CAAd,CAAJ,CAAuBS,KAAvB,CACEA,KADF,CACYT,aAAA,CAAc,CAAd,CADZ,CAGEQ,KAHF,CAGYR,aAAA,CAAc,CAAd,CAIZA,cAAA,CAAc,CAAd,CAAA,CAAmB,EAAnB,CAAwBG,UAAA,CAAW,CAAX,CAAxB,EAAyCM,KAAzC,CAAmD,CAAnD,CAAuDR,gBAAvD,CACAD,cAAA,CAAc,CAAd,CAAA,CAAmB,EAAnB,CAAwBG,UAAA,CAAW,CAAX,CAAxB,EAAyCK,KAAzC,CAAmD,CAAnD,CAAuDP,gBAAvD,CA1FwF,CAqG1F3V,UAAU8V,CAAAA,mCAAV,CAAgDM,QAAS,CAACZ,KAAD,CAAQC,KAAR,CAAeI,UAAf,CAA2B,CAC9EL,KAAMtS,CAAAA,UAAN,EAAJ,CAAyBuS,KAAMvS,CAAAA,UAAN,EAAzB,CACE2S,UAAA,CAAW,CAAX,CADF,CACkB,EADlB,CAGEA,UAAA,CAAW,CAAX,CAHF,CAGkB,CAGdL,MAAMrS,CAAAA,UAAN,EAAJ,CAAyBsS,KAAMtS,CAAAA,UAAN,EAAzB,CACE0S,UAAA,CAAW,CAAX,CADF,CACkB,EADlB,CAGEA,UAAA,CAAW,CAAX,CAHF,CAGkB,CAVgE,CAoBpF7V,UAAUqW,CAAAA,gBAAV,CAA6BC,QAAS,CAACd,KAAD;AAAQC,KAAR,CAAec,MAAf,CAAuB,CAE3D,IAAIC,IAAMhB,KAAMtS,CAAAA,UAAN,EAAV,CACIuT,IAAMjB,KAAMrS,CAAAA,UAAN,EADV,CAEIuT,IAAMjB,KAAMvS,CAAAA,UAAN,EAFV,CAGIyT,IAAMlB,KAAMtS,CAAAA,UAAN,EAGV,IAAIqS,KAAMI,CAAAA,UAAN,CAAiBH,KAAjB,CAAJ,CAKE,MAJAc,OAAA,CAAO,CAAP,CAIO,CAJKC,GAIL,CAHPD,MAAA,CAAO,CAAP,CAGO,CAHKE,GAGL,CAFPF,MAAA,CAAO,CAAP,CAEO,CAFKG,GAEL,CADPH,MAAA,CAAO,CAAP,CACO,CADKI,GACL,CAAA,CAAA,CAGT,KAAIC,UAAYpB,KAAMxK,CAAAA,IAAN,EAAhB,CACI6L,UAAYrB,KAAMtK,CAAAA,IAAN,EADhB,CAEI4L,WAAatB,KAAM5L,CAAAA,QAAN,EAFjB,CAGImN,aAAevB,KAAMxK,CAAAA,IAAN,EAHnB,CAIIgM,aAAexB,KAAM3L,CAAAA,SAAN,EAJnB,CAKIoN,cAAgBzB,KAAM5L,CAAAA,QAAN,EALpB,CAMIsN,WAAa1B,KAAM2B,CAAAA,YAAN,EANjB,CAOIC,YAAc5B,KAAM6B,CAAAA,aAAN,EAPlB,CASIC,UAAY7B,KAAMzK,CAAAA,IAAN,EAThB,CAUIuM,UAAY9B,KAAMvK,CAAAA,IAAN,EAVhB,CAWIsM,WAAa/B,KAAM7L,CAAAA,QAAN,EAXjB;AAYI6N,aAAehC,KAAMzK,CAAAA,IAAN,EAZnB,CAaI0M,aAAejC,KAAM5L,CAAAA,SAAN,EAbnB,CAcI8N,cAAgBlC,KAAM7L,CAAAA,QAAN,EAdpB,CAeIgO,WAAanC,KAAM0B,CAAAA,YAAN,EAfjB,CAgBIU,YAAcpC,KAAM4B,CAAAA,aAAN,EAhBlB,CAmBIS,gBAAkB,CAAA,CAnBtB,CAoBIC,gBAAkB,CAAA,CAGtB,IAAIvB,GAAJ,GAAYE,GAAZ,CACMD,GAAJ,CAAUE,GAAV,EACEJ,MAAA,CAAO,CAAP,CAGA,CAHYC,GAGZ,CAFAD,MAAA,CAAO,CAAP,CAEA,CAFYM,SAEZ,CADAN,MAAA,CAAO,CAAP,CACA,CADYG,GACZ,CAAAH,MAAA,CAAO,CAAP,CAAA,CAAYmB,YAJd,EAMWjB,GANX,CAMiBE,GANjB,GAOEJ,MAAA,CAAO,CAAP,CAGA,CAHYC,GAGZ,CAFAD,MAAA,CAAO,CAAP,CAEA,CAFYS,YAEZ,CADAT,MAAA,CAAO,CAAP,CACA,CADYG,GACZ,CAAAH,MAAA,CAAO,CAAP,CAAA,CAAYgB,SAVd,CADF,KAkBK,IAAId,GAAJ,GAAYE,GAAZ,CACGH,GAAJ,CAAUE,GAAV,EACEH,MAAA,CAAO,CAAP,CAGA,CAHYK,SAGZ,CAFAL,MAAA,CAAO,CAAP,CAEA,CAFYE,GAEZ,CADAF,MAAA,CAAO,CAAP,CACA,CADYiB,UACZ,CAAAjB,MAAA,CAAO,CAAP,CAAA,CAAYI,GAJd,EAMWH,GANX,CAMiBE,GANjB,GAOEH,MAAA,CAAO,CAAP,CAGA,CAHYO,UAGZ,CAFAP,MAAA,CAAO,CAAP,CAEA;AAFYE,GAEZ,CADAF,MAAA,CAAO,CAAP,CACA,CADYe,SACZ,CAAAf,MAAA,CAAO,CAAP,CAAA,CAAYI,GAVd,CADC,KAgBI,CAEDqB,KAAAA,CAASxC,KAAMnR,CAAAA,MAAf2T,CAAwBxC,KAAMpR,CAAAA,KAClC,KAAI6T,OAASxC,KAAMpR,CAAAA,MAAf4T,CAAwBxC,KAAMrR,CAAAA,KAG9B8T,MAAAA,EAAcvB,GAAduB,CAAoBzB,GAApByB,GAA4BxB,GAA5BwB,CAAkC1B,GAAlC0B,CASA,EAACF,KAAL,GAAgBE,KAAhB,EACM1B,GAAJ,CAAUE,GAAV,EACEH,MAAA,CAAO,CAAP,CACA,CADYQ,YACZ,CAAAR,MAAA,CAAO,CAAP,CAAA,CAAYS,YAFd,GAKET,MAAA,CAAO,CAAP,CACA,CADYO,UACZ,CAAAP,MAAA,CAAO,CAAP,CAAA,CAAYM,SANd,CAGE,CAAAiB,eAAA,CAAkB,CAAA,CAJtB,EAUWE,KAVX,GAUsBE,KAVtB,GAWM1B,GAAJ,CAAUE,GAAV,EACEH,MAAA,CAAO,CAAP,CACA,CADYK,SACZ,CAAAL,MAAA,CAAO,CAAP,CAAA,CAAYM,SAFd,GAKEN,MAAA,CAAO,CAAP,CACA,CADYU,aACZ,CAAAV,MAAA,CAAO,CAAP,CAAA,CAAYS,YANd,CAGE,CAAAc,eAAA,CAAkB,CAAA,CAdtB,CAuBI,EAACG,MAAL,GAAgBC,KAAhB,EACMxB,GAAJ,CAAUF,GAAV,EACED,MAAA,CAAO,CAAP,CACA,CADYkB,YACZ,CAAAlB,MAAA,CAAO,CAAP,CAAA,CAAYmB,YAFd,GAKEnB,MAAA,CAAO,CAAP,CACA,CADYiB,UACZ;AAAAjB,MAAA,CAAO,CAAP,CAAA,CAAYgB,SANd,CAGE,CAAAQ,eAAA,CAAkB,CAAA,CAJtB,EAUWE,MAVX,GAUsBC,KAVtB,GAWMxB,GAAJ,CAAUF,GAAV,EACED,MAAA,CAAO,CAAP,CACA,CADYe,SACZ,CAAAf,MAAA,CAAO,CAAP,CAAA,CAAYgB,SAFd,GAKEhB,MAAA,CAAO,CAAP,CACA,CADYoB,aACZ,CAAApB,MAAA,CAAO,CAAP,CAAA,CAAYmB,YANd,CAGE,CAAAK,eAAA,CAAkB,CAAA,CAdtB,CAuBA,IAAID,eAAJ,EAAuBC,eAAvB,CACE,MAAO,CAAA,CAILvB,IAAJ,CAAUE,GAAV,CACMD,GAAJ,CAAUE,GAAV,EACEwB,SACA,CADqB,IAAKC,CAAAA,oBAAL,CAA0BJ,KAA1B,CAAkCE,KAAlC,CAA8C,CAA9C,CACrB,CAAAG,UAAA,CAAqB,IAAKD,CAAAA,oBAAL,CAA0BH,MAA1B,CAAkCC,KAAlC,CAA8C,CAA9C,CAFvB,GAIEC,SACA,CADqB,IAAKC,CAAAA,oBAAL,CAA0B,CAACJ,KAA3B,CAAmCE,KAAnC,CAA+C,CAA/C,CACrB,CAAAG,UAAA,CAAqB,IAAKD,CAAAA,oBAAL,CAA0B,CAACH,MAA3B,CAAmCC,KAAnC,CAA+C,CAA/C,CALvB,CADF,CASMzB,GAAJ,CAAUE,GAAV,EACEwB,SACA,CADqB,IAAKC,CAAAA,oBAAL,CAA0B,CAACJ,KAA3B;AAAmCE,KAAnC,CAA+C,CAA/C,CACrB,CAAAG,UAAA,CAAqB,IAAKD,CAAAA,oBAAL,CAA0B,CAACH,MAA3B,CAAmCC,KAAnC,CAA+C,CAA/C,CAFvB,GAIEC,SACA,CADqB,IAAKC,CAAAA,oBAAL,CAA0BJ,KAA1B,CAAkCE,KAAlC,CAA8C,CAA9C,CACrB,CAAAG,UAAA,CAAqB,IAAKD,CAAAA,oBAAL,CAA0BH,MAA1B,CAAkCC,KAAlC,CAA8C,CAA9C,CALvB,CASF,IAAI,CAACJ,eAAL,CACE,OAAQK,SAAR,EACE,KAAK,CAAL,CAGE5B,MAAA,CAAO,CAAP,CAAA,CADcC,GACd,CADoB,CAACY,WACrB,CADmCc,KAEnC3B,OAAA,CAAO,CAAP,CAAA,CAHcM,SAId,MACF,MAAK,CAAL,CAGEN,MAAA,CAAO,CAAP,CAAA,CAFcU,aAGdV,OAAA,CAAO,CAAP,CAAA,CAFcE,GAEd,CAFoBS,UAEpB,CAFiCgB,KAGjC,MACF,MAAK,CAAL,CAGE3B,MAAA,CAAO,CAAP,CAAA,CADcC,GACd,CADoBY,WACpB,CADkCc,KAElC3B,OAAA,CAAO,CAAP,CAAA,CAHcS,YAId,MACF,MAAK,CAAL,CAGET,MAAA,CAAO,CAAP,CACA,CAHcQ,YAGd,CAAAR,MAAA,CAAO,CAAP,CAAA,CAFcE,GAEd,CAFoB,CAACS,UAErB,CAFkCgB,KArBtC,CA2BF,GAAI,CAACH,eAAL,CACE,OAAQM,UAAR,EACE,KAAK,CAAL,CAGE9B,MAAA,CAAO,CAAP,CAAA;AADcG,GACd,CADoB,CAACmB,WACrB,CADmCK,KAEnC3B,OAAA,CAAO,CAAP,CAAA,CAHcgB,SAId,MACF,MAAK,CAAL,CAGEhB,MAAA,CAAO,CAAP,CAAA,CAFcoB,aAGdpB,OAAA,CAAO,CAAP,CAAA,CAFcI,GAEd,CAFoBiB,UAEpB,CAFiCM,KAGjC,MACF,MAAK,CAAL,CAGE3B,MAAA,CAAO,CAAP,CAAA,CADcG,GACd,CADoBmB,WACpB,CADkCK,KAElC3B,OAAA,CAAO,CAAP,CAAA,CAHcmB,YAId,MACF,MAAK,CAAL,CAGEnB,MAAA,CAAO,CAAP,CACA,CAHckB,YAGd,CAAAlB,MAAA,CAAO,CAAP,CAAA,CAFcI,GAEd,CAFoB,CAACiB,UAErB,CAFkCM,KArBtC,CAjHG,CA6IT,MAAO,CAAA,CAtNoD,CAgO7DlY,UAAUoY,CAAAA,oBAAV,CAAiCE,QAAS,CAACrC,KAAD,CAAQiC,UAAR,CAAoBK,IAApB,CAA0B,CAClE,MAAItC,MAAJ,CAAYiC,UAAZ,CACSK,IADT,CAGS,CAHT,CAGaA,IAHb,CAGoB,CAJ8C,CAYpEvY,UAAUwC,CAAAA,eAAV,CAA4BgW,QAAS,CAACC,EAAD,CAAKC,EAAL,CAASC,EAAT,CAAaC,EAAb,CAAiB,CACpD,GAAU,IAAV,EAAIA,EAAJ,CACE,MAAO,KAAKvC,CAAAA,gBAAL,CAAsBoC,EAAtB,CAA0BC,EAA1B,CAA8BC,EAA9B,CAGT,KAAIE,GAAKJ,EAAGvU,CAAAA,CAAZ,CACI4U,GAAKL,EAAGtU,CAAAA,CADZ,CAEI4U,GAAKL,EAAGxU,CAAAA,CAFZ,CAGI8U,GAAKN,EAAGvU,CAAAA,CACR8U,GAAAA,CAAKN,EAAGzU,CAAAA,CACRgV;EAAAA,CAAKP,EAAGxU,CAAAA,CACZ,KAAIgV,GAAKP,EAAG1U,CAAAA,CAAZ,CACIkV,GAAKR,EAAGzU,CAAAA,CAWZkV,GAAA,CAAKL,EAAL,CAAUF,EACVQ,GAAA,CAAKT,EAAL,CAAUE,EACVQ,GAAA,CAAKR,EAAL,CAAUD,EAAV,CAAeD,EAAf,CAAoBG,EAEpBQ,GAAA,CAAKJ,EAAL,CAAUF,EACVO,GAAA,CAAKR,EAAL,CAAUE,EACVO,GAAA,CAAKP,EAAL,CAAUD,EAAV,CAAeD,EAAf,CAAoBG,EAEpBO,GAAA,CAAQN,EAAR,CAAaI,EAAb,CAAkBD,EAAlB,CAAuBF,EAEvB,OAAc,EAAd,GAAIK,EAAJ,CACS,IADT,CAOO,IAAIlN,KAAJ,EAHF6M,EAGE,CAHGI,EAGH,CAHQD,EAGR,CAHaF,EAGb,EAHmBI,EAGnB,EAFFH,EAEE,CAFGD,EAEH,CAFQF,EAER,CAFaK,EAEb,EAFmBC,EAEnB,CAxC6C,CA+CtD3Z,UAAU4Z,CAAAA,aAAV,CAA0BC,QAAS,CAACC,EAAD,CAAKC,EAAL,CAASC,EAAT,CAAaC,EAAb,CAAiB,CAGlD,GAAIH,EAAJ,GAAWE,EAAX,CAAe,CACb,IAAAE,QAAUtX,IAAKuX,CAAAA,IAAL,EAAWF,EAAX,CAAgBF,EAAhB,GAAuBC,EAAvB,CAA4BF,EAA5B,EAENE,GAAJ,CAASF,EAAT,CACEI,OADF,EACatX,IAAKwX,CAAAA,EADlB,CAEWH,EAFX,CAEgBF,EAFhB,GAGEG,OAHF,EAGa,IAAKG,CAAAA,MAHlB,CAHa,CAAf,IASEH,QAAA,CADSD,EAAJ,CAASF,EAAT,CACK,IAAKO,CAAAA,eADV,CAGK,IAAKC,CAAAA,OAGjB,OAAOL,QAjB2C,CAyBpDla,UAAUwa,CAAAA,WAAV,CAAwBC,QAAS,CAACC,EAAD,CAAKC,EAAL,CAASC,EAAT,CAAaC,EAAb,CAAiB,CAChD,IAAIC,EAAIJ,EAAGxW,CAAAA,CACP6W,GAAAA,CAAIL,EAAGvW,CAAAA,CACX,KAAItH,EAAI8d,EAAGzW,CAAAA,CACPlH,GAAAA,CAAI2d,EAAGxW,CAAAA,CACX,KAAI/F,EAAIwc,EAAG1W,CAAAA,CAAX,CACI8W,EAAIJ,EAAGzW,CAAAA,CACP8W,GAAAA,CAAIJ,EAAG3W,CAAAA,CACP7F;EAAAA,CAAIwc,EAAG1W,CAAAA,CACX,KAAI+W,KAAOre,CAAPqe,CAAWJ,CAAXI,GAAiB7c,EAAjB6c,CAAqBF,CAArBE,GAA2BD,EAA3BC,CAA+B9c,CAA/B8c,GAAqCle,EAArCke,CAAyCH,EAAzCG,CAEJ,IAAY,CAAZ,GAAIA,GAAJ,CACE,MAAO,CAAA,CAEHC,EAAAA,GAAW9c,EAAX8c,CAAeH,CAAfG,GAAqBF,EAArBE,CAAyBL,CAAzBK,GAA+B/c,CAA/B+c,CAAmCF,EAAnCE,GAAyC9c,EAAzC8c,CAA6CJ,EAA7CI,GAAmDD,GACnDE,EAAAA,GAAUL,EAAVK,CAAcpe,EAAdoe,GAAoBH,EAApBG,CAAwBN,CAAxBM,GAA8Bve,CAA9Bue,CAAkCN,CAAlCM,GAAwC/c,EAAxC+c,CAA4CL,EAA5CK,GAAkDF,GACtD,OAAO,EAAP,CAAWC,CAAX,EAA8B,CAA9B,CAAqBA,CAArB,EAAmC,CAAnC,CAAuCC,CAAvC,EAAwD,CAAxD,CAAgDA,CAhBF,CA0BlDpb,UAAUua,CAAAA,OAAV,CAAoB,EAApB,CAA0B3X,IAAKwX,CAAAA,EAC/Bpa,UAAUsa,CAAAA,eAAV,CAA4B,GAA5B,CAAkC1X,IAAKwX,CAAAA,EACvCpa,UAAUqa,CAAAA,MAAV,CAAmB,CAAnB,CAAyBzX,IAAKwX,CAAAA,EAC9Bpa,UAAUqb,CAAAA,QAAV,CAAqB,CAArB,CAA2BzY,IAAKwX,CAAAA,EAEhCte,OAAOC,CAAAA,OAAP,CAAiBiE,SAneqC,CA1/C5C,CAi+DH,QAAQ,CAAClE,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtD2D,QAASA,MAAK,EAAG,EAKjBA,KAAM6C,CAAAA,IAAN,CAAawY,QAAS,CAACve,KAAD,CAAQ,CAC5B,MAAY,EAAZ,CAAIA,KAAJ,CACS,CADT,CAEmB,CAAZ,CAAIA,KAAJ,CACE,EADF,CAGE,CANmB,CAU9BkD,MAAMsb,CAAAA,KAAN,CAAcC,QAAS,CAACze,KAAD,CAAQ,CAC7B,MAAe,EAAR,CAAAA,KAAA,CAAY6F,IAAK6Y,CAAAA,IAAL,CAAU1e,KAAV,CAAZ,CAA+B6F,IAAK2Y,CAAAA,KAAL,CAAWxe,KAAX,CADT,CAI/BkD;KAAMwb,CAAAA,IAAN,CAAaC,QAAS,CAAC3e,KAAD,CAAQ,CAC5B,MAAe,EAAR,CAAAA,KAAA,CAAY6F,IAAK2Y,CAAAA,KAAL,CAAWxe,KAAX,CAAZ,CAAgC6F,IAAK6Y,CAAAA,IAAL,CAAU1e,KAAV,CADX,CAI9BjB,OAAOC,CAAAA,OAAP,CAAiBkE,KA5BqC,CAj+D5C,CAigEH,QAAQ,CAACnE,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtDqH,QAASA,QAAO,EAAG,EAEnBA,OAAQG,CAAAA,SAAR,CAAoB,UACpBH,QAAQC,CAAAA,SAAR,CAAoB,WAEpB9H,OAAOC,CAAAA,OAAP,CAAiB4H,OAVqC,CAjgE5C,CA+gEH,QAAQ,CAAC7H,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtD,IAAIqf,aAAe,QAAS,EAAG,CAAEC,QAASA,iBAAgB,CAAClc,MAAD,CAASmc,KAAT,CAAgB,CAAE,IAAK,IAAIpf,EAAI,CAAb,CAAgBA,CAAhB,CAAoBof,KAAMjb,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,CAAuC,CAAE,IAAIqf,WAAaD,KAAA,CAAMpf,CAAN,CAAUqf,WAAWte,CAAAA,UAAX,CAAwBse,UAAWte,CAAAA,UAAnC,EAAiD,CAAA,CAAOse,WAAWve,CAAAA,YAAX,CAA0B,CAAA,CAAU,QAAJ;AAAeue,UAAf,GAA2BA,UAAWC,CAAAA,QAAtC,CAAiD,CAAA,CAAjD,CAAuD1e,OAAOC,CAAAA,cAAP,CAAsBoC,MAAtB,CAA8Boc,UAAWE,CAAAA,GAAzC,CAA8CF,UAA9C,CAA5K,CAAzC,CAAoR,MAAO,SAAS,CAACG,WAAD,CAAcC,UAAd,CAA0BC,WAA1B,CAAuC,CAAMD,UAAJ,EAAgBN,gBAAA,CAAiBK,WAAY/d,CAAAA,SAA7B,CAAwCge,UAAxC,CAAyDC,YAAJ,EAAiBP,gBAAA,CAAiBK,WAAjB,CAA8BE,WAA9B,CAA4C,OAAOF,YAA3I,CAAtX,CAAZ,EAAnB,CAIIG,SAAWA,QAAiB,CAACrf,KAAD,CAAQ,CACtC,MAAO,CAASA,KAAT,CAAgBsf,KAAM,IAAtB,CAA4BC,KAAM,IAAlC,CAD+B,CAJxC,CAQIvU,IAAMA,QAAY,CAACuU,IAAD,CAAO3a,IAAP,CAAa0a,IAAb,CAAmBE,IAAnB,CAAyB,CAChC,IAAb,GAAID,IAAJ,CACEA,IAAKD,CAAAA,IADP,CACc1a,IADd,CAGE4a,IAAKC,CAAAA,IAHP,CAGc7a,IAGD,KAAb,GAAI0a,IAAJ,CACEA,IAAKC,CAAAA,IADP,CACc3a,IADd,CAGE4a,IAAKE,CAAAA,IAHP,CAGc9a,IAGdA,KAAK2a,CAAAA,IAAL,CAAYA,IACZ3a,KAAK0a,CAAAA,IAAL,CAAYA,IAEZE,KAAK3b,CAAAA,MAAL,EAEA;MAAOe,KAlBsC,CAR/C,CA6BI+a,QAAUA,QAAgB,CAAC/a,IAAD,CAAO4a,IAAP,CAAa,CAAA,IACrCD,KAAO3a,IAAK2a,CAAAA,IADyB,CAErCD,KAAO1a,IAAK0a,CAAAA,IAGH,KAAb,GAAIC,IAAJ,CACEA,IAAKD,CAAAA,IADP,CACcA,IADd,CAGEE,IAAKC,CAAAA,IAHP,CAGcH,IAGD,KAAb,GAAIA,IAAJ,CACEA,IAAKC,CAAAA,IADP,CACcA,IADd,CAGEC,IAAKE,CAAAA,IAHP,CAGcH,IAGd3a,KAAK2a,CAAAA,IAAL,CAAY3a,IAAK0a,CAAAA,IAAjB,CAAwB,IAExBE,KAAK3b,CAAAA,MAAL,EAEA,OAAOe,KArBkC,CAwBvC+K,QAAAA,CAAa,QAAS,EAAG,CAC3BA,QAASA,WAAU,CAACiQ,IAAD,CAAO,CACxB,IAAIC,MAAQ,IArDkC,IAAI,EAuDlCC,IAvDkC,WAuD5BnQ,WAvD4B,CAAJ,CAA0C,KAAM,KAAIoQ,SAAJ,CAAc,mCAAd,CAAN,CAyDxF,IAAKlc,CAAAA,MAAL,CAAc,CAEd,KAAK6b,CAAAA,IAAL,CADA,IAAKD,CAAAA,IACL,CADY,IAGA,KAAZ,EAAIG,IAAJ,EACEA,IAAKtV,CAAAA,OAAL,CAAa,QAAS,CAAC0V,CAAD,CAAI,CACxB,MAAOH,MAAMrV,CAAAA,IAAN,CAAWwV,CAAX,CADiB,CAA1B,CAVsB,CAgB1BpB,YAAA,CAAajP,UAAb,CAAyB,CAAC,CACxBsP,IAAK,MADmB,CAExBjf,MAAOwG,QAAa,EAAG,CACrB,MAAO,KAAK3C,CAAAA,MADS,CAFC,CAAD;AAKtB,CACDob,IAAK,cADJ,CAEDjf,MAAOigB,QAAqB,CAACC,GAAD,CAAMC,SAAN,CAAiB,CAC3C,MAAOnV,IAAA,CAAImV,SAAUZ,CAAAA,IAAd,CAAoBF,QAAA,CAASa,GAAT,CAApB,CAAmCC,SAAnC,CAA8C,IAA9C,CADoC,CAF5C,CALsB,CAUtB,CACDlB,IAAK,aADJ,CAEDjf,MAAOogB,QAAoB,CAACF,GAAD,CAAMC,SAAN,CAAiB,CAC1C,MAAOnV,IAAA,CAAImV,SAAJ,CAAed,QAAA,CAASa,GAAT,CAAf,CAA8BC,SAAUb,CAAAA,IAAxC,CAA8C,IAA9C,CADmC,CAF3C,CAVsB,CAetB,CACDL,IAAK,kBADJ,CAEDjf,MAAOqgB,QAAyB,CAAC1M,OAAD,CAAUwM,SAAV,CAAqB,CACnD,MAAOnV,IAAA,CAAImV,SAAUZ,CAAAA,IAAd,CAAoB5L,OAApB,CAA6BwM,SAA7B,CAAwC,IAAxC,CAD4C,CAFpD,CAfsB,CAoBtB,CACDlB,IAAK,iBADJ,CAEDjf,MAAOsgB,QAAwB,CAAC3M,OAAD,CAAUwM,SAAV,CAAqB,CAClD,MAAOnV,IAAA,CAAImV,SAAJ,CAAexM,OAAf,CAAwBwM,SAAUb,CAAAA,IAAlC,CAAwC,IAAxC,CAD2C,CAFnD,CApBsB,CAyBtB,CACDL,IAAK,MADJ,CAEDjf,MAAOwK,QAAa,CAAC0V,GAAD,CAAM,CACxB,MAAOlV,IAAA,CAAI,IAAK0U,CAAAA,IAAT,CAAeL,QAAA,CAASa,GAAT,CAAf;AAA8B,IAA9B,CAAoC,IAApC,CADiB,CAFzB,CAzBsB,CA8BtB,CACDjB,IAAK,SADJ,CAEDjf,MAAOugB,QAAgB,CAACL,GAAD,CAAM,CAC3B,MAAOlV,IAAA,CAAI,IAAJ,CAAUqU,QAAA,CAASa,GAAT,CAAV,CAAyB,IAAKT,CAAAA,IAA9B,CAAoC,IAApC,CADoB,CAF5B,CA9BsB,CAmCtB,CACDR,IAAK,QADJ,CAEDjf,MAAO4Q,QAAe,CAAChM,IAAD,CAAO,CAC3B,MAAO+a,QAAA,CAAQ/a,IAAR,CAAc,IAAd,CADoB,CAF5B,CAnCsB,CAwCtB,CACDqa,IAAK,KADJ,CAEDjf,MAAOwgB,QAAY,EAAG,CACpB,MAAOb,QAAA,CAAQ,IAAKD,CAAAA,IAAb,CAAmB,IAAnB,CAAyB1f,CAAAA,KADZ,CAFrB,CAxCsB,CA6CtB,CACDif,IAAK,SADJ,CAEDjf,MAAOygB,QAAgB,EAAG,CACxB,MAAOd,QAAA,CAAQ,IAAKD,CAAAA,IAAb,CAAmB,IAAnB,CADiB,CAFzB,CA7CsB,CAkDtB,CACDT,IAAK,OADJ,CAEDjf,MAAO4S,QAAc,EAAG,CACtB,MAAO+M,QAAA,CAAQ,IAAKF,CAAAA,IAAb,CAAmB,IAAnB,CAAyBzf,CAAAA,KADV,CAFvB,CAlDsB,CAuDtB,CACDif,IAAK,WADJ,CAEDjf,MAAO0gB,QAAkB,EAAG,CAC1B,MAAOf,QAAA,CAAQ,IAAKF,CAAAA,IAAb,CAAmB,IAAnB,CADmB,CAF3B,CAvDsB,CA4DtB,CACDR,IAAK,eADJ,CAEDjf,MAAO2gB,QAAsB,CAAC1P,KAAD,CAAQ,CACnC,GAAIA,KAAJ,EAAa,IAAKpN,CAAAA,MAAL,EAAb,CAA4B,CAG1B,IAFA,IAAInE;AAAI,CAAR,CACIkhB,QAAU,IAAKnB,CAAAA,IACnB,CAAO/f,CAAP,CAAWuR,KAAX,CAAA,CACE2P,OACA,CADUA,OAAQtB,CAAAA,IAClB,CAAA5f,CAAA,EAEF,OAAOkhB,QAAQ5gB,CAAAA,KAPW,CADO,CAFpC,CA5DsB,CAyEtB,CACDif,IAAK,eADJ,CAEDjf,MAAO6gB,QAAsB,CAAC5P,KAAD,CAAQjR,KAAR,CAAe,CAC1C,GAAIiR,KAAJ,EAAa,IAAKpN,CAAAA,MAAL,EAAb,CAA4B,CAG1B,IAFA,IAAInE,EAAI,CAAR,CACIkhB,QAAU,IAAKnB,CAAAA,IACnB,CAAO/f,CAAP,CAAWuR,KAAX,CAAA,CACE2P,OACA,CADUA,OAAQtB,CAAAA,IAClB,CAAA5f,CAAA,EAEFkhB,QAAQ5gB,CAAAA,KAAR,CAAgBA,KAPU,CADc,CAF3C,CAzEsB,CAAzB,CAwFA,OAAO2P,WAzGoB,CAAZ,EA4GjB5Q,OAAOC,CAAAA,OAAP,CAAiB2Q,OAtKqC,CA/gE5C,CAyrEH,QAAQ,CAAC5Q,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAQtDmQ,QAASA,MAAK,CAACvI,CAAD,CAAIC,CAAJ,CAAO/F,CAAP,CAAU,CAEtB,IAAK+F,CAAAA,CAAL,CADA,IAAKD,CAAAA,CACL,CADS,IAEA,KAAT,EAAIA,CAAJ,EAAsB,IAAtB,EAAiBC,CAAjB,EAAmC,IAAnC,EAA8B/F,CAA9B,CAEE,IAAK+F,CAAAA,CAFP,CACE,IAAKD,CAAAA,CADP,CACW,CADX,CAGuB,QAAhB,EAAI,MAAOA,EAAX,EAAwC,QAAxC,EAA4B,MAAOC,EAAnC,EAAyD,IAAzD,EAAoD/F,CAApD,EACL,IAAK8F,CAAAA,CACL,CADSA,CACT,CAAA,IAAKC,CAAAA,CAAL,CAASA,CAFJ,EAG0B,OAH1B,EAGID,CAAE2Z,CAAAA,WAAY3gB,CAAAA,IAHlB;AAG0C,IAH1C,EAGqCiH,CAHrC,EAGuD,IAHvD,EAGkD/F,CAHlD,GAILA,CAEA,CAFI8F,CAEJ,CADA,IAAKA,CAAAA,CACL,CADS9F,CAAE8F,CAAAA,CACX,CAAA,IAAKC,CAAAA,CAAL,CAAS/F,CAAE+F,CAAAA,CANN,CANe,CAgBxBsI,KAAMvO,CAAAA,SAAU8M,CAAAA,IAAhB,CAAuB8S,QAAS,EAAG,CACjC,MAAO,KAAK5Z,CAAAA,CADqB,CAInCuI,MAAMvO,CAAAA,SAAUgN,CAAAA,IAAhB,CAAuB6S,QAAS,EAAG,CACjC,MAAO,KAAK5Z,CAAAA,CADqB,CAInCsI,MAAMvO,CAAAA,SAAUyH,CAAAA,WAAhB,CAA8BqY,QAAS,EAAG,CACxC,MAAO,KAAIvR,KAAJ,CAAU,IAAKvI,CAAAA,CAAf,CAAkB,IAAKC,CAAAA,CAAvB,CADiC,CAI1CsI,MAAMvO,CAAAA,SAAUwI,CAAAA,WAAhB,CAA8BuX,QAAS,CAAC/Z,CAAD,CAAIC,CAAJ,CAAO/F,CAAP,CAAU,CACrB,OAA1B,EAAI8F,CAAE2Z,CAAAA,WAAY3gB,CAAAA,IAAlB,EAA0C,IAA1C,EAAqCiH,CAArC,EAAuD,IAAvD,EAAkD/F,CAAlD,EACEA,CACA,CADI8F,CACJ,CAAA,IAAKwC,CAAAA,WAAL,CAAiBtI,CAAE8F,CAAAA,CAAnB,CAAsB9F,CAAE+F,CAAAA,CAAxB,CAFF,EAGuB,QAHvB,EAGW,MAAOD,EAHlB,EAG+C,QAH/C,EAGmC,MAAOC,EAH1C,EAGgE,IAHhE,EAG2D/F,CAH3D,GAKM8f,QAAA,CAASha,CAAT,CAAJ,EAAmBA,CAAnB,EAAwBga,QAAA,CAAS/Z,CAAT,CAAxB,EAAuCA,CAAvC,CACE,IAAKga,CAAAA,IAAL,CAAUja,CAAV,CAAaC,CAAb,CADF,EAGE,IAAKD,CAAAA,CACL,CADStB,IAAK2Y,CAAAA,KAAL,CAAWrX,CAAX,CAAe,EAAf,CACT,CAAA,IAAKC,CAAAA,CAAL,CAASvB,IAAK2Y,CAAAA,KAAL,CAAWpX,CAAX,CAAe,EAAf,CAJX,CALF,CAD+C,CAejDsI,MAAMvO,CAAAA,SAAUigB,CAAAA,IAAhB;AAAuBC,QAAS,CAACla,CAAD,CAAIC,CAAJ,CAAO,CACrC,IAAKD,CAAAA,CAAL,CAASA,CACT,KAAKC,CAAAA,CAAL,CAASA,CAF4B,CAKvCsI,MAAMvO,CAAAA,SAAU4N,CAAAA,SAAhB,CAA4BuS,QAAS,CAACvX,EAAD,CAAKC,EAAL,CAAS,CAC5C,IAAK7C,CAAAA,CAAL,EAAU4C,EACV,KAAK3C,CAAAA,CAAL,EAAU4C,EAFkC,CAK9C0F,MAAMvO,CAAAA,SAAUogB,CAAAA,MAAhB,CAAyBC,QAAS,CAAC1Q,GAAD,CAAM,CACtC,MAA4B,OAA5B,EAAIA,GAAIgQ,CAAAA,WAAY3gB,CAAAA,IAApB,CAES,IAAKgH,CAAAA,CAFd,EACW2J,GACW3J,CAAAA,CAFtB,EAE2B,IAAKC,CAAAA,CAFhC,EACW0J,GAC6B1J,CAAAA,CAFxC,CAIO,IAJP,EAIe0J,GALuB,CAQxCpB,MAAMvO,CAAAA,SAAUsgB,CAAAA,QAAhB,CAA2BC,QAAS,EAAG,CACrC,MAAmBZ,CAAZ,IAAIpR,KAAQoR,EAAAA,WAAY3gB,CAAAA,IAA/B,CAAsC,QAAtC,CAA8C,IAAKgH,CAAAA,CAAnD,CAAuD,QAAvD,CAA+D,IAAKC,CAAAA,CAApE,CAAwE,GADnC,CAIvCrI,OAAOC,CAAAA,OAAP,CAAiB0Q,KAzEqC,CAzrE5C,CAswEH,QAAQ,CAAC3Q,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtD2H,QAASA,WAAU,CAACC,CAAD,CAAIC,CAAJ,CAAOC,KAAP,CAAcC,MAAd,CAAsB,CAIvC,IAAKA,CAAAA,MAAL,CADA,IAAKD,CAAAA,KACL,CAFA,IAAKD,CAAAA,CAEL,CAHA,IAAKD,CAAAA,CAGL,CAHS,CAKA,KAAT,EAAIA,CAAJ,EAAsB,IAAtB,EAAiBC,CAAjB,EAAuC,IAAvC,EAA8BC,KAA9B,EAAyD,IAAzD,EAA+CC,MAA/C;CACE,IAAKH,CAAAA,CAGL,CAHSA,CAGT,CAFA,IAAKC,CAAAA,CAEL,CAFSA,CAET,CADA,IAAKC,CAAAA,KACL,CADaA,KACb,CAAA,IAAKC,CAAAA,MAAL,CAAcA,MAJhB,CANuC,CAczCJ,UAAW/F,CAAAA,SAAU8M,CAAAA,IAArB,CAA4B0T,QAAS,EAAG,CACtC,MAAO,KAAKxa,CAAAA,CAD0B,CAIxCD,WAAW/F,CAAAA,SAAUkN,CAAAA,IAArB,CAA4BuT,QAAS,CAACza,CAAD,CAAI,CACvC,IAAKA,CAAAA,CAAL,CAASA,CAD8B,CAIzCD,WAAW/F,CAAAA,SAAUgN,CAAAA,IAArB,CAA4B0T,QAAS,EAAG,CACtC,MAAO,KAAKza,CAAAA,CAD0B,CAIxCF,WAAW/F,CAAAA,SAAUoN,CAAAA,IAArB,CAA4BuT,QAAS,CAAC1a,CAAD,CAAI,CACvC,IAAKA,CAAAA,CAAL,CAASA,CAD8B,CAIzCF,WAAW/F,CAAAA,SAAU6G,CAAAA,QAArB,CAAgC+Z,QAAS,EAAG,CAC1C,MAAO,KAAK1a,CAAAA,KAD8B,CAI5CH,WAAW/F,CAAAA,SAAU+G,CAAAA,QAArB,CAAgC8Z,QAAS,CAAC3a,KAAD,CAAQ,CAC/C,IAAKA,CAAAA,KAAL,CAAaA,KADkC,CAIjDH,WAAW/F,CAAAA,SAAUiH,CAAAA,SAArB,CAAiC6Z,QAAS,EAAG,CAC3C,MAAO,KAAK3a,CAAAA,MAD+B,CAI7CJ,WAAW/F,CAAAA,SAAUmH,CAAAA,SAArB,CAAiC4Z,QAAS,CAAC5a,MAAD,CAAS,CACjD,IAAKA,CAAAA,MAAL;AAAcA,MADmC,CAInDJ,WAAW/F,CAAAA,SAAU0L,CAAAA,QAArB,CAAgCsV,QAAS,EAAG,CAC1C,MAAO,KAAKhb,CAAAA,CAAZ,CAAgB,IAAKE,CAAAA,KADqB,CAI5CH,WAAW/F,CAAAA,SAAU2L,CAAAA,SAArB,CAAiCsV,QAAS,EAAG,CAC3C,MAAO,KAAKhb,CAAAA,CAAZ,CAAgB,IAAKE,CAAAA,MADsB,CAI7CJ,WAAW/F,CAAAA,SAAU0X,CAAAA,UAArB,CAAkCwJ,QAAS,CAACtE,CAAD,CAAI,CAa7C,MAZI,KAAKlR,CAAAA,QAAL,EAYJ,CAZsBkR,CAAE5W,CAAAA,CAYxB,EARI,IAAK2F,CAAAA,SAAL,EAQJ,CARuBiR,CAAE3W,CAAAA,CAQzB,EAJI2W,CAAElR,CAAAA,QAAF,EAIJ,CAJmB,IAAK1F,CAAAA,CAIxB,EAAI4W,CAAEjR,CAAAA,SAAF,EAAJ,CAAoB,IAAK1F,CAAAA,CAAzB,CACS,CAAA,CADT,CAIO,CAAA,CAjBsC,CAoB/CF,WAAW/F,CAAAA,SAAUgF,CAAAA,UAArB,CAAkCmc,QAAS,EAAG,CAC5C,MAAO,KAAKnb,CAAAA,CAAZ,CAAgB,IAAKE,CAAAA,KAArB,CAA6B,CADe,CAI9CH,WAAW/F,CAAAA,SAAUohB,CAAAA,OAArB,CAA+BC,QAAS,EAAG,CACzC,MAAO,KAAKvU,CAAAA,IAAL,EADkC,CAI3C/G,WAAW/F,CAAAA,SAAUshB,CAAAA,OAArB,CAA+BC,QAAS,EAAG,CACzC,MAAO,KAAKzU,CAAAA,IAAL,EAAP,CAAqB,IAAK5G,CAAAA,KADe,CAI3CH,WAAW/F,CAAAA,SAAUiF,CAAAA,UAArB;AAAkCuc,QAAS,EAAG,CAC5C,MAAO,KAAKvb,CAAAA,CAAZ,CAAgB,IAAKE,CAAAA,MAArB,CAA8B,CADc,CAI9CJ,WAAW/F,CAAAA,SAAUyhB,CAAAA,OAArB,CAA+BC,QAAS,EAAG,CACzC,MAAO,KAAK1U,CAAAA,IAAL,EADkC,CAI3CjH,WAAW/F,CAAAA,SAAU2hB,CAAAA,OAArB,CAA+BC,QAAS,EAAG,CACzC,MAAO,KAAK5U,CAAAA,IAAL,EAAP,CAAqB,IAAK7G,CAAAA,MADe,CAI3CJ,WAAW/F,CAAAA,SAAUiZ,CAAAA,YAArB,CAAoC4I,QAAS,EAAG,CAC9C,MAAO,KAAK3b,CAAAA,KAAZ,CAAoB,CAD0B,CAIhDH,WAAW/F,CAAAA,SAAUmZ,CAAAA,aAArB,CAAqC2I,QAAS,EAAG,CAC/C,MAAO,KAAK3b,CAAAA,MAAZ,CAAqB,CAD0B,CAIjDvI,OAAOC,CAAAA,OAAP,CAAiBkI,UA/GqC,CAtwE5C,CAy3EH,QAAQ,CAACnI,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAOtD2jB,QAASA,kBAAiB,EAAG,EAF7B,IAAIC,QAA4B,UAAlB,GAAA,MAAOC,OAAP,EAA2D,QAA3D,GAAgC,MAAOA,OAAOC,CAAAA,QAA9C,CAAsE,QAAS,CAACvS,GAAD,CAAM,CAAE,MAAO,OAAOA,IAAhB,CAArF;AAA8G,QAAS,CAACA,GAAD,CAAM,CAAE,MAAOA,IAAA,EAAyB,UAAzB,GAAO,MAAOsS,OAAd,EAAuCtS,GAAIgQ,CAAAA,WAA3C,GAA2DsC,MAA3D,EAAqEtS,GAArE,GAA6EsS,MAAOjiB,CAAAA,SAApF,CAAgG,QAAhG,CAA2G,MAAO2P,IAA3H,CAI3IoS,kBAAkBI,CAAAA,MAAlB,CAA2B,CAE3BJ,kBAAkBK,CAAAA,QAAlB,CAA6BC,QAAS,CAAC1S,GAAD,CAAM,CAC1C,GAAIoS,iBAAkBO,CAAAA,WAAlB,CAA8B3S,GAA9B,CAAJ,CACE,MAAOA,IAET,IAAoB,IAApB,EAAIA,GAAI4S,CAAAA,QAAR,CACE,MAAO5S,IAAI4S,CAAAA,QAEb5S,IAAI4S,CAAAA,QAAJ,CAAeR,iBAAkBS,CAAAA,SAAlB,EACfT,kBAAkBI,CAAAA,MAAlB,EACA,OAAOxS,IAAI4S,CAAAA,QAT+B,CAY5CR,kBAAkBS,CAAAA,SAAlB,CAA8BC,QAAS,CAACC,EAAD,CAAK,CAChC,IAAV,EAAIA,EAAJ,GAAgBA,EAAhB,CAAqBX,iBAAkBI,CAAAA,MAAvC,CACA,OAAO,SAAP,CAAmBO,EAFuB,CAK5CX,kBAAkBO,CAAAA,WAAlB;AAAgCK,QAAS,CAACC,GAAD,CAAM,CAC7C,IAAIC,KAAsB,WAAf,GAAA,MAAOD,IAAP,CAA6B,WAA7B,CAA2CZ,OAAA,CAAQY,GAAR,CACtD,OAAc,KAAd,EAAOA,GAAP,EAA8B,QAA9B,EAAsBC,IAAtB,EAAkD,UAAlD,EAA0CA,IAFG,CAK/CjlB,OAAOC,CAAAA,OAAP,CAAiBkkB,iBAjCqC,CAz3E5C,CA85EH,QAAQ,CAACnkB,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtD0kB,QAASA,mBAAkB,CAACC,GAAD,CAAM,CAAE,GAAI1e,KAAM2e,CAAAA,OAAN,CAAcD,GAAd,CAAJ,CAAwB,CAAE,IAAF,IAAWxkB,EAAI,CAAf,CAAkB0kB,KAAO5e,KAAA,CAAM0e,GAAIrgB,CAAAA,MAAV,CAAvB,CAA0CnE,CAA1C,CAA8CwkB,GAAIrgB,CAAAA,MAAlD,CAA0DnE,CAAA,EAA1D,CAAiE0kB,IAAA,CAAK1kB,CAAL,CAAA,CAAUwkB,GAAA,CAAIxkB,CAAJ,CAAU,OAAO0kB,KAA9F,CAA6G,MAAO5e,MAAM6e,CAAAA,IAAN,CAAWH,GAAX,CAA9I,CAWjCzU,QAASA,OAAM,CAAC6U,WAAD,CAAc,CAC3BC,OAAQ3kB,CAAAA,IAAR,CAAa,IAAb,CAGA,KAAK4kB,CAAAA,aAAL,CAAqBjjB,eAAgBC,CAAAA,OAErC,KAAKijB,CAAAA,mBAAL,CAA2BljB,eAAgBE,CAAAA,8BAE3C;IAAKijB,CAAAA,WAAL,CAAmBnjB,eAAgBG,CAAAA,mBAEnC,KAAKijB,CAAAA,iBAAL,CAAyBpjB,eAAgBI,CAAAA,2BAEzC,KAAKijB,CAAAA,qBAAL,CAA6BrjB,eAAgBK,CAAAA,+BAE7C,KAAKijB,CAAAA,eAAL,CAAuBtjB,eAAgBM,CAAAA,wBAOvC,KAAKijB,CAAAA,oBAAL,CAA4BvjB,eAAgBO,CAAAA,+BAK5C,KAAKijB,CAAAA,gBAAL,CAAwB,IAAIC,GAC5B,KAAKte,CAAAA,YAAL,CAAoB,IAAI8I,aAAJ,CAAkB,IAAlB,CAGpB,KAAK8U,CAAAA,WAAL,CADA,IAAKW,CAAAA,WACL,CAFA,IAAKC,CAAAA,gBAEL,CAFwB,CAAA,CAIL,KAAnB,EAAIZ,WAAJ,GACE,IAAKA,CAAAA,WADP,CACqBA,WADrB,CAhC2B;AAT7B,IAAI/iB,gBAAkBhC,mBAAA,CAAoB,CAApB,CAAtB,CACIiQ,cAAgBjQ,mBAAA,CAAoB,CAApB,CADpB,CAEI8G,MAAQ9G,mBAAA,CAAoB,CAApB,CAFZ,CAGIkD,MAAQlD,mBAAA,CAAoB,CAApB,CAHZ,CAII2P,OAAS3P,mBAAA,CAAoB,CAApB,CAJb,CAKIiI,OAASjI,mBAAA,CAAoB,CAApB,CALb,CAMI4lB,UAAY5lB,mBAAA,CAAoB,EAApB,CANhB,CAOIglB,QAAUhlB,mBAAA,CAAoB,EAApB,CAuCdkQ,OAAO2V,CAAAA,WAAP,CAAqB,CAErB3V,OAAOtO,CAAAA,SAAP,CAAmBb,MAAO6C,CAAAA,MAAP,CAAcohB,OAAQpjB,CAAAA,SAAtB,CAEnBsO,OAAOtO,CAAAA,SAAU8D,CAAAA,eAAjB,CAAmCogB,QAAS,EAAG,CAC7C,MAAO,KAAK3e,CAAAA,YADiC,CAI/C+I,OAAOtO,CAAAA,SAAUuT,CAAAA,WAAjB,CAA+B4Q,QAAS,EAAG,CACzC,MAAO,KAAK5e,CAAAA,YAAagO,CAAAA,WAAlB,EADkC,CAI3CjF,OAAOtO,CAAAA,SAAUmU,CAAAA,WAAjB;AAA+BiQ,QAAS,EAAG,CACzC,MAAO,KAAK7e,CAAAA,YAAa4O,CAAAA,WAAlB,EADkC,CAI3C7F,OAAOtO,CAAAA,SAAUqU,CAAAA,6BAAjB,CAAiDgQ,QAAS,EAAG,CAC3D,MAAO,KAAK9e,CAAAA,YAAa8O,CAAAA,6BAAlB,EADoD,CAI7D/F,OAAOtO,CAAAA,SAAUskB,CAAAA,eAAjB,CAAmCC,QAAS,EAAG,CAC7C,IAAIpf,GAAK,IAAIkJ,aAAJ,CAAkB,IAAlB,CAET,OADA,KAAK9I,CAAAA,YACL,CADoBJ,EAFyB,CAM/CmJ,OAAOtO,CAAAA,SAAUsS,CAAAA,QAAjB,CAA4BkS,QAAS,CAACtW,MAAD,CAAS,CAC5C,MAAO,KAAIH,MAAJ,CAAW,IAAX,CAAiB,IAAKxI,CAAAA,YAAtB,CAAoC2I,MAApC,CADqC,CAI9CI,OAAOtO,CAAAA,SAAUwS,CAAAA,OAAjB,CAA2BiS,QAAS,CAACnf,KAAD,CAAQ,CAC1C,MAAO,KAAIJ,KAAJ,CAAU,IAAKK,CAAAA,YAAf,CAA6BD,KAA7B,CADmC,CAI5CgJ,OAAOtO,CAAAA,SAAU6S,CAAAA,OAAjB,CAA2B6R,QAAS,CAACjjB,KAAD,CAAQ,CAC1C,MAAO,KAAIH,KAAJ,CAAU,IAAV;AAAgB,IAAhB,CAAsBG,KAAtB,CADmC,CAI5C6M,OAAOtO,CAAAA,SAAU2kB,CAAAA,kBAAjB,CAAsCC,QAAS,EAAG,CAChD,MAAsC,KAAtC,EAAO,IAAKrf,CAAAA,YAAaxB,CAAAA,OAAlB,EAAP,EAA+F,CAA/F,EAA8C,IAAKwB,CAAAA,YAAaxB,CAAAA,OAAlB,EAA4BmG,CAAAA,QAA5B,EAAuCxH,CAAAA,MAArF,EAAoG,IAAK6C,CAAAA,YAAasQ,CAAAA,mBAAlB,EADpD,CAIlDvH,OAAOtO,CAAAA,SAAU6kB,CAAAA,SAAjB,CAA6BC,QAAS,EAAG,CACvC,IAAKf,CAAAA,gBAAL,CAAwB,CAAA,CAEpB,KAAKgB,CAAAA,eAAT,EACE,IAAKA,CAAAA,eAAL,EAGF,KAAKC,CAAAA,cAAL,EAIE,KAAAC,oBADE,IAAKN,CAAAA,kBAAL,EAAJ,CACwB,CAAA,CADxB,CAGwB,IAAK1S,CAAAA,MAAL,EAGxB,IAAgC,QAAhC,GAAI7R,eAAgB8kB,CAAAA,OAApB,CAGE,MAAO,CAAA,CAGLD,oBAAJ,GACO,IAAKnB,CAAAA,WADZ,EAEI,IAAKqB,CAAAA,YAAL,EAFJ,CAMI,KAAKC,CAAAA,gBAAT;AACE,IAAKA,CAAAA,gBAAL,EAGF,KAAKrB,CAAAA,gBAAL,CAAwB,CAAA,CAExB,OAAOkB,oBAlCgC,CAwCzC3W,OAAOtO,CAAAA,SAAUmlB,CAAAA,YAAjB,CAAgCE,QAAS,EAAG,CAGrC,IAAK9B,CAAAA,WAAV,EACE,IAAKtX,CAAAA,SAAL,EAEF,KAAKqZ,CAAAA,MAAL,EAN0C,CAa5ChX,OAAOtO,CAAAA,SAAUulB,CAAAA,OAAjB,CAA2BC,QAAS,EAAG,CAEjC,IAAKlC,CAAAA,mBAAT,GACE,IAAKmC,CAAAA,8BAAL,EAGA,CAAA,IAAKlgB,CAAAA,YAAasO,CAAAA,aAAlB,EAJF,CASA,IAAI,CAAC,IAAKsP,CAAAA,WAAV,CAAuB,CAIrB,IADA,IAAIpP,SAAW,IAAKxO,CAAAA,YAAa4O,CAAAA,WAAlB,EAAf,CACS5V,EAAI,CAAb,CAAgBA,CAAhB,CAAoBwV,QAASrR,CAAAA,MAA7B,CAAqCnE,CAAA,EAArC,EAOI0L,QAAAA,CAAQ,IAAK1E,CAAAA,YAAaxB,CAAAA,OAAlB,EAA4BmG,CAAAA,QAA5B,EACZ,KAAS3L,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoB0L,QAAMvH,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,EAMA,IAAK+mB,CAAAA,MAAL,CAAY,IAAK/f,CAAAA,YAAaxB,CAAAA,OAAlB,EAAZ,CAlBqB,CAXc,CAiCvCuK;MAAOtO,CAAAA,SAAUslB,CAAAA,MAAjB,CAA0BI,QAAS,CAAC/V,GAAD,CAAM,CACvC,GAAW,IAAX,EAAIA,GAAJ,CACE,IAAK4V,CAAAA,OAAL,EADF,KAEO,IAAI5V,GAAJ,WAAmBzK,MAAnB,CAA0B,CAE/B,GAAuB,IAAvB,EADWyK,GACFnJ,CAAAA,QAAL,EAAJ,CAGE,IADA,IAAIyD,MAHK0F,GAGQnJ,CAAAA,QAAL,EAAgB0D,CAAAA,QAAhB,EAAZ,CACS3L,EAAI,CAAb,CAAgBA,CAAhB,CAAoB0L,KAAMvH,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,CACE+mB,MAAA,CAAOrb,KAAA,CAAM1L,CAAN,CAAP,CAOqB,KAAzB,EAZWoR,GAYF/N,CAAAA,YAAT,EAZW+N,GAcQ/N,CAAAA,YAGX0jB,CAAAA,MAAN,CAjBS3V,GAiBT,CAlB6B,CAA1B,IAoBIA,IAAJ,WAAmBrO,MAAnB,CAMoB,IANpB,EACMqO,GAKF/N,CAAAA,YANJ,EACM+N,GAOQ/N,CAAAA,YAGX0jB,CAAAA,MAAN,CAVS3V,GAUT,CAXG,CAaIA,GAbJ,WAamB5B,OAbnB,EAmBqB,IAnBrB,EAcO4B,GAKF/N,CAAAA,YAnBL,EAcO+N,GAOS/N,CAAAA,YAGZ0jB,CAAAA,MAAP,CAVU3V,GAUV,CA/CmC,CAwDzCrB,OAAOtO,CAAAA,SAAUglB,CAAAA,cAAjB,CAAkCW,QAAS,EAAG,CACvC,IAAK7B,CAAAA,WAAV,GACE,IAAKT,CAAAA,aAML,CANqBjjB,eAAgBC,CAAAA,OAMrC;AALA,IAAKojB,CAAAA,qBAKL,CAL6BrjB,eAAgBK,CAAAA,+BAK7C,CAJA,IAAKijB,CAAAA,eAIL,CAJuBtjB,eAAgBM,CAAAA,wBAIvC,CAHA,IAAK8iB,CAAAA,iBAGL,CAHyBpjB,eAAgBI,CAAAA,2BAGzC,CAFA,IAAK+iB,CAAAA,WAEL,CAFmBnjB,eAAgBG,CAAAA,mBAEnC,CADA,IAAK+iB,CAAAA,mBACL,CAD2BljB,eAAgBE,CAAAA,8BAC3C,CAAA,IAAKqjB,CAAAA,oBAAL,CAA4BvjB,eAAgBO,CAAAA,+BAP9C,CAUI,KAAK8iB,CAAAA,qBAAT,GACE,IAAKD,CAAAA,iBADP,CAC2B,CAAA,CAD3B,CAX4C,CAgB9ClV,OAAOtO,CAAAA,SAAUiM,CAAAA,SAAjB,CAA6B2Z,QAAS,CAACC,UAAD,CAAa,CACjD,GAAkBtV,IAAAA,EAAlB;AAAIsV,UAAJ,CACE,IAAK5Z,CAAAA,SAAL,CAAe,IAAI5F,MAAJ,CAAW,CAAX,CAAc,CAAd,CAAf,CADF,KAEO,CAML,IAAI8F,MAAQ,IAAI6X,SAAhB,CACI1X,QAAU,IAAK/G,CAAAA,YAAaxB,CAAAA,OAAlB,EAA4BmM,CAAAA,aAA5B,EAEd,IAAe,IAAf,EAAI5D,OAAJ,CAAqB,CACnBH,KAAM2Z,CAAAA,YAAN,CAAmBD,UAAW7f,CAAAA,CAA9B,CACAmG,MAAM4Z,CAAAA,YAAN,CAAmBF,UAAW5f,CAAAA,CAA9B,CAEAkG,MAAM6Z,CAAAA,aAAN,CAAoB1Z,OAAQtG,CAAAA,CAA5B,CACAmG,MAAM8Z,CAAAA,aAAN,CAAoB3Z,OAAQrG,CAAAA,CAA5B,CAEIgE,WAAAA,CAAQ,IAAKsJ,CAAAA,WAAL,EAGZ,KAAK,IAAIhV,EAAI,CAAb,CAAgBA,CAAhB,CAAoB0L,UAAMvH,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,CACEkF,OACA,CADOwG,UAAA,CAAM1L,CAAN,CACP,CAAAkF,OAAKwI,CAAAA,SAAL,CAAeE,KAAf,CAZiB,CAThB,CAH0C,CA8BnDmC,OAAOtO,CAAAA,SAAUkmB,CAAAA,qBAAjB,CAAyCC,QAAS,CAACviB,KAAD,CAAQ,CAExD,GAAa2M,IAAAA,EAAb,EAAI3M,KAAJ,CAEE,IAAKsiB,CAAAA,qBAAL,CAA2B,IAAKpiB,CAAAA,eAAL,EAAuBC,CAAAA,OAAvB,EAA3B,CACA;AAAA,IAAKD,CAAAA,eAAL,EAAuBC,CAAAA,OAAvB,EAAiCsH,CAAAA,YAAjC,CAA8C,CAAA,CAA9C,CAHF,KASE,KAHA,IAAIE,UAAJ,CAEItB,MAAQrG,KAAMsG,CAAAA,QAAN,EAFZ,CAGS3L,EAAI,CAAb,CAAgBA,CAAhB,CAAoB0L,KAAMvH,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,CACE+R,KAGA,CAHQrG,KAAA,CAAM1L,CAAN,CAGR,CAFAgN,UAEA,CAFa+E,KAAM9J,CAAAA,QAAN,EAEb,CAAkB,IAAlB,EAAI+E,UAAJ,CACE+E,KAAM1F,CAAAA,OAAN,EADF,CAE2C,CAApC,EAAIW,UAAWrB,CAAAA,QAAX,EAAsBxH,CAAAA,MAA1B,CACL4N,KAAM1F,CAAAA,OAAN,EADK,EAGL,IAAKsb,CAAAA,qBAAL,CAA2B3a,UAA3B,CACA,CAAA+E,KAAMjF,CAAAA,YAAN,EAJK,CAjB6C,CAiC1DiD,OAAOtO,CAAAA,SAAUomB,CAAAA,aAAjB,CAAiCC,QAAS,EAAG,CAW3C,IAVA,IAAIC,WAAa,EAAjB,CACIC,SAAW,CAAA,CADf,CAKI9S,SAAW,IAAKlO,CAAAA,YAAaxB,CAAAA,OAAlB,EAA4BmG,CAAAA,QAA5B,EALf,CAQIsc,OAAS,CAAA,CARb,CAUSjoB,EAAI,CAAb,CAAgBA,CAAhB,CAAoBkV,QAAS/Q,CAAAA,MAA7B,CAAqCnE,CAAA,EAArC,CACgC,IAA9B,EAAIkV,QAAA,CAASlV,CAAT,CAAYiI,CAAAA,QAAZ,EAAJ,GACEggB,MADF;AACW,CAAA,CADX,CAMF,IAAI,CAACA,MAAL,CACE,MAAOF,WAKT,KAAIhV,QAAU,IAAI1H,GACd6c,OAAAA,CAAc,EAClB,KAAIC,QAAU,IAAI7C,GAAlB,CACI8C,iBAAmB,EAQvB,KANAA,gBAMA,CANmBA,gBAAiBzT,CAAAA,MAAjB,CAAwBO,QAAxB,CAMnB,CAAiC,CAAjC,CAAOkT,gBAAiBjkB,CAAAA,MAAxB,EAAsC6jB,QAAtC,CAAA,CAAgD,CAK9C,IAJAE,MAAYpd,CAAAA,IAAZ,CAAiBsd,gBAAA,CAAiB,CAAjB,CAAjB,CAIA,CAA4B,CAA5B,CAAOF,MAAY/jB,CAAAA,MAAnB,EAAiC6jB,QAAjC,CAAA,CAA2C,CAErChV,QAAAA,CAAckV,MAAA,CAAY,CAAZ,CAClBA,OAAY1W,CAAAA,MAAZ,CAAmB,CAAnB,CAAsB,CAAtB,CACAuB,QAAQzH,CAAAA,GAAR,CAAY0H,QAAZ,CAGA,KAAIG,cAAgBH,QAAYjL,CAAAA,QAAZ,EAEpB,KAAS/H,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoBmT,aAAchP,CAAAA,MAAlC,CAA0CnE,CAAA,EAA1C,CAA+C,CAC7C,IAAIoT,gBAAkBD,aAAA,CAAcnT,CAAd,CAAiBgF,CAAAA,WAAjB,CAA6BgO,QAA7B,CAGtB,IAAImV,OAAQnnB,CAAAA,GAAR,CAAYgS,QAAZ,CAAJ,EAAgCI,eAAhC,CAEE,GAAKL,OAAQO,CAAAA,GAAR,CAAYF,eAAZ,CAAL,CAQK,CACD4U,QAAA;AAAW,CAAA,CACX,MAFC,CARL,IACEE,OAAYpd,CAAAA,IAAZ,CAAiBsI,eAAjB,CACA,CAAA+U,OAAQE,CAAAA,GAAR,CAAYjV,eAAZ,CAA6BJ,QAA7B,CARyC,CATN,CAiC3C,GAAKgV,QAAL,CAMK,CACGM,OAAAA,CAAO,EAAG3T,CAAAA,MAAH,CAAU4P,kBAAA,CAAmBxR,OAAnB,CAAV,CACXgV,WAAWjd,CAAAA,IAAX,CAAgBwd,OAAhB,CAGA,KAAStoB,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoBsoB,OAAKnkB,CAAAA,MAAzB,CAAiCnE,CAAA,EAAjC,CAEMuR,OACJ,CADY6W,gBAAiBnX,CAAAA,OAAjB,CADAqX,OAAAhoB,CAAKN,CAALM,CACA,CACZ,CAAY,EAAZ,CAAIiR,OAAJ,EACE6W,gBAAiB5W,CAAAA,MAAjB,CAAwBD,OAAxB,CAA+B,CAA/B,CAGJwB,QAAA,CAAU,IAAI1H,GACd8c,QAAA,CAAU,IAAI7C,GAbb,CANL,IACEyC,WAAA,CAAa,EAvC+B,CA6DhD,MAAOA,WAhGoC,CAwG7ChY,OAAOtO,CAAAA,SAAU8mB,CAAAA,6BAAjB,CAAiDC,QAAS,CAAC3d,IAAD,CAAO,CAM/D,IALA,IAAI4d,WAAa,EAAjB,CACI5I,KAAOhV,IAAK7H,CAAAA,MADhB,CAGIqC,MAAQ,IAAK2B,CAAAA,YAAa+P,CAAAA,wBAAlB,CAA2ClM,IAAK7H,CAAAA,MAAhD;AAAwD6H,IAAK5H,CAAAA,MAA7D,CAHZ,CAKSjD,EAAI,CAAb,CAAgBA,CAAhB,CAAoB6K,IAAKvH,CAAAA,UAAWa,CAAAA,MAApC,CAA4CnE,CAAA,EAA5C,CAAiD,CAE/C,IAAI0oB,UAAY,IAAKzU,CAAAA,OAAL,CAAa,IAAb,CAChByU,UAAUjf,CAAAA,OAAV,CAAkB,IAAIuG,KAAJ,CAAU,CAAV,CAAa,CAAb,CAAlB,CAAmC,IAAI2Y,SAAJ,CAAc,CAAd,CAAiB,CAAjB,CAAnC,CAEAtjB,MAAMiG,CAAAA,GAAN,CAAUod,SAAV,CAGA,KAAIE,UAAY,IAAKtU,CAAAA,OAAL,CAAa,IAAb,CAChB,KAAKtN,CAAAA,YAAasE,CAAAA,GAAlB,CAAsBsd,SAAtB,CAAiC/I,IAAjC,CAAuC6I,SAAvC,CAEAD,WAAWnd,CAAAA,GAAX,CAAeod,SAAf,CACA7I,KAAA,CAAO6I,SAZwC,CAe7CE,SAAJ,CAAgB,IAAKtU,CAAAA,OAAL,CAAa,IAAb,CAChB,KAAKtN,CAAAA,YAAasE,CAAAA,GAAlB,CAAsBsd,SAAtB,CAAiC/I,IAAjC,CAAuChV,IAAK5H,CAAAA,MAA5C,CAEA,KAAKoiB,CAAAA,gBAAiBgD,CAAAA,GAAtB,CAA0Bxd,IAA1B,CAAgC4d,UAAhC,CAGI5d,KAAK9G,CAAAA,YAAL,EAAJ,CACE,IAAKiD,CAAAA,YAAakK,CAAAA,MAAlB,CAAyBrG,IAAzB,CADF,CAKIxF,KAAM6L,CAAAA,MAAN,CAAarG,IAAb,CAGJ,OAAO4d,WAnCwD,CA0CjE1Y,OAAOtO,CAAAA,SAAUylB,CAAAA,8BAAjB;AAAkD2B,QAAS,EAAG,CAC5D,IAAIvhB,MAAQ,EACZA,MAAA,CAAQA,KAAMqN,CAAAA,MAAN,CAAa,IAAK3N,CAAAA,YAAa4O,CAAAA,WAAlB,EAAb,CACRtO,MAAA,CAAQ,EAAGqN,CAAAA,MAAH,CAAU4P,kBAAA,CAAmB,IAAKc,CAAAA,gBAAiByD,CAAAA,IAAtB,EAAnB,CAAV,CAA4DnU,CAAAA,MAA5D,CAAmErN,KAAnE,CAER,KAAK,IAAIyhB,EAAI,CAAb,CAAgBA,CAAhB,CAAoBzhB,KAAMnD,CAAAA,MAA1B,CAAkC4kB,CAAA,EAAlC,CAAuC,CACrC,IAAIC,MAAQ1hB,KAAA,CAAMyhB,CAAN,CAEZ,IAA8B,CAA9B,CAAIC,KAAM1lB,CAAAA,UAAWa,CAAAA,MAArB,CAAiC,CAG/B,IAFA,IAAI8kB,KAAO,IAAK5D,CAAAA,gBAAiBrkB,CAAAA,GAAtB,CAA0BgoB,KAA1B,CAAX,CAEShpB,EAAI,CAAb,CAAgBA,CAAhB,CAAoBipB,IAAK9kB,CAAAA,MAAzB,CAAiCnE,CAAA,EAAjC,CAAsC,CACpC,IAAI0oB,UAAYO,IAAA,CAAKjpB,CAAL,CAAhB,CACI2B,EAAI,IAAImG,MAAJ,CAAW4gB,SAAUjiB,CAAAA,UAAV,EAAX,CAAmCiiB,SAAUhiB,CAAAA,UAAV,EAAnC,CADR,CAIIwiB,IAAMF,KAAM1lB,CAAAA,UAAWtC,CAAAA,GAAjB,CAAqBhB,CAArB,CACVkpB,IAAIzhB,CAAAA,CAAJ,CAAQ9F,CAAE8F,CAAAA,CACVyhB,IAAIxhB,CAAAA,CAAJ,CAAQ/F,CAAE+F,CAAAA,CAIVghB,UAAUjjB,CAAAA,QAAV,EAAqByL,CAAAA,MAArB,CAA4BwX,SAA5B,CAXoC,CAetC,IAAK1hB,CAAAA,YAAasE,CAAAA,GAAlB,CAAsB0d,KAAtB;AAA6BA,KAAMhmB,CAAAA,MAAnC,CAA2CgmB,KAAM/lB,CAAAA,MAAjD,CAlB+B,CAHI,CALqB,CA+B9D8M,OAAOrC,CAAAA,SAAP,CAAmByb,QAAS,CAACC,WAAD,CAAcC,YAAd,CAA4BC,MAA5B,CAAoCC,MAApC,CAA4C,CACtE,GAAcvX,IAAAA,EAAd,EAAIsX,MAAJ,EAAqCtX,IAAAA,EAArC,EAA2BuX,MAA3B,CAAgD,CAC9C,IAAIjpB,MAAQ+oB,YAUZ,OARmB,GAAnB/oB,EAAI8oB,WAAJ9oB,CAEEA,KAFFA,EAEY+oB,YAFZ/oB,CACiB+oB,YADjB/oB,CACgCgpB,MADhChpB,EAEuC,EAFvCA,EAE6C,EAF7CA,CAEkD8oB,WAFlD9oB,EAKEA,KALFA,EAIiB+oB,YAJjB/oB,CAIgCipB,MAJhCjpB,CAKuB+oB,YALvB/oB,EAKuC,EALvCA,EAK6C8oB,WAL7C9oB,CAK2D,EAL3DA,CAH8C,CAe3B,EAAnB,EAAI8oB,WAAJ,EACE/K,MACI,CADA,CACA,CADMgL,YACN,CADqB,GACrB,CAAAA,YAAA,EAAe,EAFrB,GAIEhL,MACA,CADI,CACJ,CADUgL,YACV,CADyB,EACzB,CAAA/K,YAAA,EAAI,EALN,CAQA,OAAOD,OAAP,CAAW+K,WAAX,CAAyB9K,YAxB2C,CAgCxEvO,OAAOyZ,CAAAA,gBAAP,CAA0BC,QAAS,CAAC/d,KAAD,CAAQ,CACzC,IAAIoU,KAAO,EACXA,KAAA;AAAOA,IAAKnL,CAAAA,MAAL,CAAYjJ,KAAZ,CAEP,KAAIge,aAAe,EAAnB,CACIC,iBAAmB,IAAIrE,GACvBsE,MAAAA,CAAc,CAAA,CAClB,KAAIC,WAAa,IAEjB,IAAmB,CAAnB,EAAI/J,IAAK3b,CAAAA,MAAT,EAAuC,CAAvC,EAAwB2b,IAAK3b,CAAAA,MAA7B,CACEylB,KACA,CADc,CAAA,CACd,CAAAC,UAAA,CAAa/J,IAAA,CAAK,CAAL,CAGf,KAAK,IAAI9f,EAAI,CAAb,CAAgBA,CAAhB,CAAoB8f,IAAK3b,CAAAA,MAAzB,CAAiCnE,CAAA,EAAjC,CAAsC,CACpC,IAAIkF,KAAO4a,IAAA,CAAK9f,CAAL,CAAX,CACI8pB,OAAS5kB,IAAKgG,CAAAA,gBAAL,EAAwBpE,CAAAA,IACrC6iB,iBAAiBtB,CAAAA,GAAjB,CAAqBnjB,IAArB,CAA2BA,IAAKgG,CAAAA,gBAAL,EAAwBpE,CAAAA,IAAnD,CAEc,EAAd,EAAIgjB,MAAJ,EACEJ,YAAa5e,CAAAA,IAAb,CAAkB5F,IAAlB,CANkC,CAUtC,IAAI6kB,SAAW,EAGf,KAFAA,QAEA,CAFWA,QAASpV,CAAAA,MAAT,CAAgB+U,YAAhB,CAEX,CAAO,CAACE,KAAR,CAAA,CAAqB,CACfI,CAAAA,CAAY,EAChBA,EAAA,CAAYA,CAAUrV,CAAAA,MAAV,CAAiBoV,QAAjB,CACZA,SAAA,CAAW,EAEX,KAAS/pB,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoB8f,IAAK3b,CAAAA,MAAzB,CAAiCnE,CAAA,EAAjC,CACMkF,IASJ,CATW4a,IAAA,CAAK9f,CAAL,CASX,CAPIuR,MAOJ,CAPYuO,IAAK7O,CAAAA,OAAL,CAAa/L,IAAb,CAOZ;AANa,CAMb,EANIqM,MAMJ,EALEuO,IAAKtO,CAAAA,MAAL,CAAYD,MAAZ,CAAmB,CAAnB,CAKF,CAFiBrM,IAAKgG,CAAAA,gBAAL+e,EAENrf,CAAAA,OAAX,CAAmB,QAAS,CAACsf,SAAD,CAAY,CACtC,GAAsC,CAAtC,CAAIR,YAAazY,CAAAA,OAAb,CAAqBiZ,SAArB,CAAJ,CAAyC,CAEvC,IAAIC,UADcR,gBAAiB3oB,CAAAA,GAAjBopB,CAAqBF,SAArBE,CACdD,CAA0B,CAEb,EAAjB,EAAIA,SAAJ,EACEJ,QAASjf,CAAAA,IAAT,CAAcof,SAAd,CAGFP,iBAAiBtB,CAAAA,GAAjB,CAAqB6B,SAArB,CAAgCC,SAAhC,CARuC,CADH,CAAxC,CAcFT,aAAA,CAAeA,YAAa/U,CAAAA,MAAb,CAAoBoV,QAApB,CAEf,IAAmB,CAAnB,EAAIjK,IAAK3b,CAAAA,MAAT,EAAuC,CAAvC,EAAwB2b,IAAK3b,CAAAA,MAA7B,CACEylB,KACA,CADc,CAAA,CACd,CAAAC,UAAA,CAAa/J,IAAA,CAAK,CAAL,CAjCI,CAqCrB,MAAO+J,WAhEkC,CAuE3C9Z,OAAOtO,CAAAA,SAAU4oB,CAAAA,eAAjB,CAAmCC,QAAS,CAAC1jB,EAAD,CAAK,CAC/C,IAAKI,CAAAA,YAAL,CAAoBJ,EAD2B,CAIjDvH,OAAOC,CAAAA,OAAP,CAAiByQ,MAxlBqC,CA95E5C,CA0/FH,QAAQ,CAAC1Q,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtDgI,QAASA,WAAU,EAAG;AAEtBA,UAAW0iB,CAAAA,IAAX,CAAkB,CAClB1iB,WAAWJ,CAAAA,CAAX,CAAe,CAEfI,WAAW6E,CAAAA,UAAX,CAAwB8d,QAAS,EAAG,CAClC3iB,UAAWJ,CAAAA,CAAX,CAA6C,GAA7C,CAAetB,IAAKskB,CAAAA,GAAL,CAAS5iB,UAAW0iB,CAAAA,IAAX,EAAT,CACf,OAAO1iB,WAAWJ,CAAAA,CAAlB,CAAsBtB,IAAK2Y,CAAAA,KAAL,CAAWjX,UAAWJ,CAAAA,CAAtB,CAFY,CAKpCpI,OAAOC,CAAAA,OAAP,CAAiBuI,UAfqC,CA1/F5C,CA6gGH,QAAQ,CAACxI,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAOtD4lB,QAASA,UAAS,CAAChe,CAAD,CAAIC,CAAJ,CAAO,CAIvB,IAAKgjB,CAAAA,WAAL,CADA,IAAKC,CAAAA,WACL,CAFA,IAAKC,CAAAA,UAEL,CAHA,IAAKC,CAAAA,UAGL,CAHkB,CAOlB,KAAKC,CAAAA,WAAL,CADA,IAAKC,CAAAA,WACL,CAFA,IAAKC,CAAAA,UAEL,CAHA,IAAKC,CAAAA,UAGL,CAHkB,CALK,CAFzB,IAAInjB,OAASjI,mBAAA,CAAoB,CAApB,CAab4lB,UAAUhkB,CAAAA,SAAUypB,CAAAA,YAApB,CAAmCC,QAAS,EAAG,CAC7C,MAAO,KAAKN,CAAAA,UADiC,CAI/CpF,UAAUhkB,CAAAA,SAAU8lB,CAAAA,YAApB;AAAmC6D,QAAS,CAACC,GAAD,CAAM,CAChD,IAAKR,CAAAA,UAAL,CAAkBQ,GAD8B,CAIlD5F,UAAUhkB,CAAAA,SAAU6pB,CAAAA,YAApB,CAAmCC,QAAS,EAAG,CAC7C,MAAO,KAAKX,CAAAA,UADiC,CAI/CnF,UAAUhkB,CAAAA,SAAU+lB,CAAAA,YAApB,CAAmCgE,QAAS,CAACC,GAAD,CAAM,CAChD,IAAKb,CAAAA,UAAL,CAAkBa,GAD8B,CAIlDhG,UAAUhkB,CAAAA,SAAUiqB,CAAAA,YAApB,CAAmCC,QAAS,EAAG,CAC7C,MAAO,KAAKV,CAAAA,UADiC,CAI/CxF,UAAUhkB,CAAAA,SAAUmqB,CAAAA,YAApB,CAAmCC,QAAS,CAACC,GAAD,CAAM,CAChD,IAAKb,CAAAA,UAAL,CAAkBa,GAD8B,CAIlDrG,UAAUhkB,CAAAA,SAAUsqB,CAAAA,YAApB,CAAmCC,QAAS,EAAG,CAC7C,MAAO,KAAKhB,CAAAA,UADiC,CAI/CvF,UAAUhkB,CAAAA,SAAUwqB,CAAAA,YAApB,CAAmCC,QAAS,CAACC,GAAD,CAAM,CAChD,IAAKnB,CAAAA,UAAL,CAAkBmB,GAD8B,CAMlD1G,UAAUhkB,CAAAA,SAAU2qB,CAAAA,aAApB,CAAoCC,QAAS,EAAG,CAC9C,MAAO,KAAK1B,CAAAA,WADkC,CAIhDlF;SAAUhkB,CAAAA,SAAUgmB,CAAAA,aAApB,CAAoC6E,QAAS,CAACC,GAAD,CAAM,CACjD,IAAK5B,CAAAA,WAAL,CAAmB4B,GAD8B,CAInD9G,UAAUhkB,CAAAA,SAAU+qB,CAAAA,aAApB,CAAoCC,QAAS,EAAG,CAC9C,MAAO,KAAK/B,CAAAA,WADkC,CAIhDjF,UAAUhkB,CAAAA,SAAUimB,CAAAA,aAApB,CAAoCgF,QAAS,CAACC,GAAD,CAAM,CACjD,IAAKjC,CAAAA,WAAL,CAAmBiC,GAD8B,CAInDlH,UAAUhkB,CAAAA,SAAUmrB,CAAAA,aAApB,CAAoCC,QAAS,EAAG,CAC9C,MAAO,KAAK9B,CAAAA,WADkC,CAIhDtF,UAAUhkB,CAAAA,SAAUqrB,CAAAA,aAApB,CAAoCC,QAAS,CAACC,GAAD,CAAM,CACjD,IAAKjC,CAAAA,WAAL,CAAmBiC,GAD8B,CAInDvH,UAAUhkB,CAAAA,SAAUwrB,CAAAA,aAApB,CAAoCC,QAAS,EAAG,CAC9C,MAAO,KAAKpC,CAAAA,WADkC,CAIhDrF,UAAUhkB,CAAAA,SAAU0rB,CAAAA,aAApB,CAAoCC,QAAS,CAACC,GAAD,CAAM,CACjD,IAAKvC,CAAAA,WAAL,CAAmBuC,GAD8B,CAInD5H,UAAUhkB,CAAAA,SAAU6rB,CAAAA,UAApB;AAAiCC,QAAS,CAAC9lB,CAAD,CAAI,CAC5C,IAAI+lB,QAAU,CAAd,CACIC,UAAY,IAAKxC,CAAAA,UACJ,EAAjB,EAAIwC,SAAJ,GACED,OADF,CACY,IAAK7C,CAAAA,WADjB,EACgCljB,CADhC,CACoC,IAAKojB,CAAAA,UADzC,EACuD,IAAKE,CAAAA,WAD5D,CAC0E0C,SAD1E,CAIA,OAAOD,QAPqC,CAU9C/H,UAAUhkB,CAAAA,SAAUisB,CAAAA,UAApB,CAAiCC,QAAS,CAACjmB,CAAD,CAAI,CAC5C,IAAIkmB,QAAU,CAAd,CACIC,UAAY,IAAK7C,CAAAA,UACJ,EAAjB,EAAI6C,SAAJ,GACED,OADF,CACY,IAAKlD,CAAAA,WADjB,EACgChjB,CADhC,CACoC,IAAKkjB,CAAAA,UADzC,EACuD,IAAKE,CAAAA,WAD5D,CAC0E+C,SAD1E,CAIA,OAAOD,QAPqC,CAU9CnI,UAAUhkB,CAAAA,SAAUqsB,CAAAA,iBAApB,CAAwCC,QAAS,CAACtmB,CAAD,CAAI,CACnD,IAAIumB,OAAS,CAAb,CACIC,WAAa,IAAKlD,CAAAA,WACJ,EAAlB,EAAIkD,UAAJ,GACED,MADF,CACW,IAAKnD,CAAAA,UADhB,EAC8BpjB,CAD9B,CACkC,IAAKkjB,CAAAA,WADvC,EACsD,IAAKM,CAAAA,UAD3D;AACwEgD,UADxE,CAIA,OAAOD,OAP4C,CAUrDvI,UAAUhkB,CAAAA,SAAUysB,CAAAA,iBAApB,CAAwCC,QAAS,CAACzmB,CAAD,CAAI,CACnD,IAAI0mB,OAAS,CAAb,CACIC,WAAa,IAAKvD,CAAAA,WACJ,EAAlB,EAAIuD,UAAJ,GACED,MADF,CACW,IAAKxD,CAAAA,UADhB,EAC8BljB,CAD9B,CACkC,IAAKgjB,CAAAA,WADvC,EACsD,IAAKM,CAAAA,UAD3D,CACwEqD,UADxE,CAGA,OAAOD,OAN4C,CASrD3I,UAAUhkB,CAAAA,SAAUwM,CAAAA,qBAApB,CAA4CqgB,QAAS,CAACC,OAAD,CAAU,CAE7D,MADeC,KAAI1mB,MAAJ0mB,CAAW,IAAKV,CAAAA,iBAAL,CAAuBS,OAAQ9mB,CAAAA,CAA/B,CAAX+mB,CAA8C,IAAKN,CAAAA,iBAAL,CAAuBK,OAAQ7mB,CAAAA,CAA/B,CAA9C8mB,CAD8C,CAK/DnvB,OAAOC,CAAAA,OAAP,CAAiBmmB,SAhIqC,CA7gG5C,CAipGH,QAAQ,CAACpmB,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAatD4uB,QAASA,SAAQ,EAAG,CAClB1e,MAAO7P,CAAAA,IAAP,CAAY,IAAZ,CAEA,KAAKwuB,CAAAA,kCAAL;AAA0ClX,iBAAkBS,CAAAA,+CAC5D,KAAK0W,CAAAA,eAAL,CAAuBnX,iBAAkBE,CAAAA,mBACzC,KAAKkX,CAAAA,cAAL,CAAsBpX,iBAAkBG,CAAAA,uBACxC,KAAKkX,CAAAA,iBAAL,CAAyBrX,iBAAkBI,CAAAA,0BAC3C,KAAKkX,CAAAA,eAAL,CAAuBtX,iBAAkBK,CAAAA,wBACzC,KAAKkX,CAAAA,uBAAL,CAA+BvX,iBAAkBM,CAAAA,iCACjD,KAAKkX,CAAAA,kBAAL,CAA0BxX,iBAAkBO,CAAAA,4BAC5C,KAAKkX,CAAAA,0BAAL;AAAkCzX,iBAAkBQ,CAAAA,qCACpD,KAAKkX,CAAAA,4BAAL,CAAoC,CAApC,CAA0C1X,iBAAkBE,CAAAA,mBAA5D,CAAkF,GAElF,KAAKyX,CAAAA,oBAAL,CADA,IAAKC,CAAAA,aACL,CADqB5X,iBAAkBW,CAAAA,kCAGvC,KAAKkX,CAAAA,oBAAL,CADA,IAAKC,CAAAA,iBACL,CADyB,CAEzB,KAAKC,CAAAA,aAAL,CAAqB/X,iBAAkBC,CAAAA,cAhBrB,CANpB,IAAI1H,OAASlQ,mBAAA,CAAoB,EAApB,CAAb,CACI2X,kBAAoB3X,mBAAA,CAAoB,CAApB,CADxB,CAEIgC,gBAAkBhC,mBAAA,CAAoB,CAApB,CAFtB,CAGI0D,UAAY1D,mBAAA,CAAoB,CAApB,CAHhB,CAII2D,MAAQ3D,mBAAA,CAAoB,CAApB,CAqBZ4uB;QAAShtB,CAAAA,SAAT,CAAqBb,MAAO6C,CAAAA,MAAP,CAAcsM,MAAOtO,CAAAA,SAArB,CAErB,KAAKiC,IAAIA,IAAT,GAAiBqM,OAAjB,CACE0e,QAAA,CAAS/qB,IAAT,CAAA,CAAiBqM,MAAA,CAAOrM,IAAP,CAGnB+qB,SAAShtB,CAAAA,SAAUglB,CAAAA,cAAnB,CAAoC+I,QAAS,EAAG,CAC9Czf,MAAOtO,CAAAA,SAAUglB,CAAAA,cAAevmB,CAAAA,IAAhC,CAAqC,IAArC,CAA2CuvB,SAA3C,CAGA,KAAKC,CAAAA,qBAAL,CADA,IAAKC,CAAAA,eACL,CADuB,CAGvB,KAAKC,CAAAA,gBAAL,CAAwBpY,iBAAkBU,CAAAA,6CAE1C,KAAK2X,CAAAA,IAAL,CAAY,EARkC,CAWhDpB,SAAShtB,CAAAA,SAAUquB,CAAAA,oBAAnB,CAA0CC,QAAS,EAAG,CASpD,IARA,IAAIllB,IAAJ,CACImlB,QADJ,CAEIhtB,MAFJ,CAGIC,MAHJ,CAKIgtB,iBALJ,CAOIza,SAAW,IAAKjQ,CAAAA,eAAL,EAAuBqQ,CAAAA,WAAvB,EAPf;AAQS5V,EAAI,CAAb,CAAgBA,CAAhB,CAAoBwV,QAASrR,CAAAA,MAA7B,CAAqCnE,CAAA,EAArC,CACE6K,IAIA,CAJO2K,QAAA,CAASxV,CAAT,CAIP,CAFA6K,IAAKqlB,CAAAA,WAEL,CAFmB,IAAKvB,CAAAA,eAExB,CAAI9jB,IAAK9G,CAAAA,YAAT,GACEf,MAYA,CAZS6H,IAAKlH,CAAAA,SAAL,EAYT,CAXAV,MAWA,CAXS4H,IAAKhH,CAAAA,SAAL,EAWT,CATAssB,QASA,CAToBtlB,IAAKnG,CAAAA,cAAL,EAAsBuH,CAAAA,gBAAtB,EASpB,CARAgkB,iBAQA,CARoBplB,IAAKhG,CAAAA,cAAL,EAAsBoH,CAAAA,gBAAtB,EAQpB,CANI,IAAKyiB,CAAAA,kCAMT,GALE7jB,IAAKqlB,CAAAA,WAKP,EALsBC,QAKtB,CAL0CF,iBAK1C,CAL8D,CAK9D,CALkEpuB,eAAgBU,CAAAA,gBAKlF,EAFAytB,QAEA,CAFWnlB,IAAKtG,CAAAA,MAAL,EAAciJ,CAAAA,qBAAd,EAEX,CAAA3C,IAAKqlB,CAAAA,WAAL,EAAoB1Y,iBAAkBE,CAAAA,mBAAtC,CAA4DF,iBAAkBmB,CAAAA,kCAA9E;CAAoH3V,MAAOwK,CAAAA,qBAAP,EAApH,CAAqJvK,MAAOuK,CAAAA,qBAAP,EAArJ,CAAsL,CAAtL,CAA0LwiB,QAA1L,CAbF,CAdkD,CAgCtDvB,SAAShtB,CAAAA,SAAU2uB,CAAAA,kBAAnB,CAAwCC,QAAS,EAAG,CAElD,IAAIzuB,EAAI,IAAKoT,CAAAA,WAAL,EAAmB7Q,CAAAA,MACvB,KAAK6gB,CAAAA,WAAT,EACMpjB,CAGJ,CAHQ4V,iBAAkBa,CAAAA,2BAG1B,GAFE,IAAK+W,CAAAA,aAEP,CAFuBjpB,IAAKoT,CAAAA,GAAL,CAAS,IAAK6V,CAAAA,aAAd,CAA8B5X,iBAAkBY,CAAAA,yBAAhD,CAA2E,IAAKgX,CAAAA,aAAhF,EAAiGxtB,CAAjG,CAAqG4V,iBAAkBa,CAAAA,2BAAvH,GAAuJb,iBAAkBc,CAAAA,2BAAzK,CAAuMd,iBAAkBa,CAAAA,2BAAzN,EAAwP,IAAK+W,CAAAA,aAA7P,EAA8Q,CAA9Q;AAAkR5X,iBAAkBY,CAAAA,yBAApS,EAEvB,EAAA,IAAKkY,CAAAA,mBAAL,CAA2B9Y,iBAAkBe,CAAAA,iCAJ/C,GAWE,IAAK4W,CAAAA,oBACL,CALE,IAAKC,CAAAA,aAKP,CANIxtB,CAAJ,CAAQ4V,iBAAkBa,CAAAA,2BAA1B,CACuBlS,IAAKoT,CAAAA,GAAL,CAAS/B,iBAAkBY,CAAAA,yBAA3B,CAAsD,CAAtD,EAA6DxW,CAA7D,CAAiE4V,iBAAkBa,CAAAA,2BAAnF,GAAmHb,iBAAkBc,CAAAA,2BAArI,CAAmKd,iBAAkBa,CAAAA,2BAArL,GAAqN,CAArN,CAAyNb,iBAAkBY,CAAAA,yBAA3O,EADvB,CAGuB,CAGvB,CAAA,IAAKkY,CAAAA,mBAAL,CAA2B9Y,iBAAkBgB,CAAAA,qBAZ/C,CAeA;IAAK+W,CAAAA,aAAL,CAAqBppB,IAAKoT,CAAAA,GAAL,CAAqC,CAArC,CAAS,IAAKvE,CAAAA,WAAL,EAAmB7Q,CAAAA,MAA5B,CAAwC,IAAKorB,CAAAA,aAA7C,CAErB,KAAKgB,CAAAA,0BAAL,CAAkC,IAAKrB,CAAAA,4BAAvC,CAAsE,IAAKla,CAAAA,WAAL,EAAmB7Q,CAAAA,MAEzF,KAAKqsB,CAAAA,cAAL,CAAsB,IAAKC,CAAAA,kBAAL,EAtB4B,CAyBpDhC,SAAShtB,CAAAA,SAAUivB,CAAAA,gBAAnB,CAAsCC,QAAS,EAAG,CAIhD,IAHA,IAAIC,OAAS,IAAKhb,CAAAA,WAAL,EAAb,CACI/K,IADJ,CAGS7K,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4wB,MAAOzsB,CAAAA,MAA3B,CAAmCnE,CAAA,EAAnC,CACE6K,IAEA,CAFO+lB,MAAA,CAAO5wB,CAAP,CAEP,CAAA,IAAK6wB,CAAAA,eAAL,CAAqBhmB,IAArB,CAA2BA,IAAKqlB,CAAAA,WAAhC,CAP8C,CAWlDzB,SAAShtB,CAAAA,SAAUqvB,CAAAA,mBAAnB,CAAyCC,QAAS,EAAG,CACnD,IAAIC,kBAAuC,CAAnB,CAAAvB,SAAUtrB,CAAAA,MAAV,EAAyC6N,IAAAA,EAAzC,GAAwByd,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD;AAAoE,CAAA,CAA5F,CACIwB,6BAAkD,CAAnB,CAAAxB,SAAUtrB,CAAAA,MAAV,EAAyC6N,IAAAA,EAAzC,GAAwByd,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,CAAA,CADvG,CAGIzvB,CAHJ,CAKIkxB,OAAS,IAAKlc,CAAAA,WAAL,EAGb,IAAI,IAAK4a,CAAAA,gBAAT,CAA2B,CACqD,CAA9E,EAAI,IAAKD,CAAAA,eAAT,CAA2BnY,iBAAkBoB,CAAAA,6BAA7C,EAAmFoY,iBAAnF,EACE,IAAKG,CAAAA,UAAL,EAGF,KAAAC,iBAAmB,IAAI/lB,GAGvB,KAAKrL,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBkxB,MAAO/sB,CAAAA,MAAvB,CAA+BnE,CAAA,EAA/B,CAAoC,CAClC,IAAAqxB,MAAQH,MAAA,CAAOlxB,CAAP,CACR,KAAKsxB,CAAAA,8BAAL,CAAoCD,KAApC,CAA2CD,gBAA3C,CAA6DJ,iBAA7D,CAAgFC,4BAAhF,CACAG,iBAAiB9lB,CAAAA,GAAjB,CAAqB+lB,KAArB,CAHkC,CARX,CAA3B,IAcE,KAAKrxB,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBkxB,MAAO/sB,CAAAA,MAAvB,CAA+BnE,CAAA,EAA/B,CAGE,IAFAqxB,KAEK;AAFGH,MAAA,CAAOlxB,CAAP,CAEH,CAAAuxB,iBAAA,CAAIvxB,CAAJ,CAAQ,CAAb,CAAgBuxB,iBAAhB,CAAoBL,MAAO/sB,CAAAA,MAA3B,CAAmCotB,iBAAA,EAAnC,CACEC,4BAGA,CAHQN,MAAA,CAAOK,iBAAP,CAGR,CAAIF,KAAM5rB,CAAAA,QAAN,EAAJ,EAAwB+rB,4BAAM/rB,CAAAA,QAAN,EAAxB,EAIA,IAAKgsB,CAAAA,kBAAL,CAAwBJ,KAAxB,CAA+BG,4BAA/B,CAlC6C,CAwCrD/C,SAAShtB,CAAAA,SAAUiwB,CAAAA,uBAAnB,CAA6CC,QAAS,EAAG,CAIvD,IAHA,IAAIzsB,IAAJ,CACIgsB,OAAS,IAAKpb,CAAAA,6BAAL,EADb,CAGS9V,EAAI,CAAb,CAAgBA,CAAhB,CAAoBkxB,MAAO/sB,CAAAA,MAA3B,CAAmCnE,CAAA,EAAnC,CACEkF,IACA,CADOgsB,MAAA,CAAOlxB,CAAP,CACP,CAAA,IAAK4xB,CAAAA,sBAAL,CAA4B1sB,IAA5B,CANqD,CAUzDupB,SAAShtB,CAAAA,SAAUowB,CAAAA,SAAnB,CAA+BC,QAAS,EAAG,CAIzC,IAHA,IAAIZ,OAAS,IAAKlc,CAAAA,WAAL,EAAb;AACI9P,IADJ,CAGSlF,EAAI,CAAb,CAAgBA,CAAhB,CAAoBkxB,MAAO/sB,CAAAA,MAA3B,CAAmCnE,CAAA,EAAnC,CACEkF,IACA,CADOgsB,MAAA,CAAOlxB,CAAP,CACP,CAAAkF,IAAKwc,CAAAA,IAAL,EANuC,CAU3C+M,SAAShtB,CAAAA,SAAUovB,CAAAA,eAAnB,CAAqCkB,QAAS,CAAClnB,IAAD,CAAOqlB,WAAP,CAAoB,CAChE,IAAInf,WAAalG,IAAKlH,CAAAA,SAAL,EAAjB,CACIqN,WAAanG,IAAKhH,CAAAA,SAAL,EAQjB,IAAI,IAAKuhB,CAAAA,oBAAT,EAA0D,IAA1D,EAAiCrU,UAAW9I,CAAAA,QAAX,EAAjC,EAA2F,IAA3F,EAAkE+I,UAAW/I,CAAAA,QAAX,EAAlE,CACE4C,IAAKtE,CAAAA,kBAAL,EADF,KAKE,IAFAsE,IAAKlF,CAAAA,YAAL,EAESvC,CAALyH,IAAKzH,CAAAA,2BAAT,CACE,MAIJ,KAAAe,OAAS0G,IAAK5G,CAAAA,SAAL,EAET,IAAc,CAAd,EAAIE,MAAJ,CAAA,CAGA,IAAA6tB,YAAc,IAAKpD,CAAAA,cAAnBoD,EAAqC7tB,MAArC6tB,CAA8C9B,WAA9C8B,CAGAC,YAAA,CAA8BpnB,IAAK5E,CAAAA,OAAnC,CAA6C9B,MAA7C,CAAe6tB,WACfE;IAAA,CAA8BrnB,IAAK3E,CAAAA,OAAnC,CAA6C/B,MAA7C,CAAe6tB,WAGfjhB,WAAWkhB,CAAAA,YAAX,EAA2BA,WAC3BlhB,WAAWmhB,CAAAA,YAAX,EAA2BA,IAC3BlhB,WAAWihB,CAAAA,YAAX,EAA2BA,WAC3BjhB,WAAWkhB,CAAAA,YAAX,EAA2BA,IAb3B,CAtBgE,CAsClEzD,SAAShtB,CAAAA,SAAUgwB,CAAAA,kBAAnB,CAAwCU,QAAS,CAACd,KAAD,CAAQG,KAAR,CAAe,CAC9D,IAAIzY,MAAQsY,KAAMrrB,CAAAA,OAAN,EAAZ,CACIgT,MAAQwY,KAAMxrB,CAAAA,OAAN,EADZ,CAEIiT,cAAoBnT,KAAJ,CAAU,CAAV,CAFpB,CAGIssB,WAAiBtsB,KAAJ,CAAU,CAAV,CASjB,IAAIiT,KAAMI,CAAAA,UAAN,CAAiBH,KAAjB,CAAJ,CACE,CAEEzV,SAAUsV,CAAAA,oBAAV,CAA+BE,KAA/B,CAAsCC,KAAtC,CAA6CC,aAA7C,CAA4DzB,iBAAkBE,CAAAA,mBAA9E,CAAoG,CAApG,CAEA,KAAA2a,UAAkB,CAAlBA,CAAsBpZ,aAAA,CAAc,CAAd,CACtBqZ,MAAA,CAAkB,CAAlB,CAAsBrZ,aAAA,CAAc,CAAd,CAElBsZ;KAAAA,CAAmBlB,KAAMrlB,CAAAA,YAAzBumB,CAAwCf,KAAMxlB,CAAAA,YAA9CumB,EAA8DlB,KAAMrlB,CAAAA,YAApEumB,CAAmFf,KAAMxlB,CAAAA,YAAzFumB,CAGJlB,MAAMgB,CAAAA,eAAN,EAAyBE,KAAzB,CAA4CF,SAC5ChB,MAAMiB,CAAAA,eAAN,EAAyBC,KAAzB,CAA4CD,KAC5Cd,MAAMa,CAAAA,eAAN,EAAyBE,KAAzB,CAA4CF,SAC5Cb,MAAMc,CAAAA,eAAN,EAAyBC,KAAzB,CAA4CD,KAb9C,CADF,IAmBQ,KAAKlN,CAAAA,oBAAT,EAAqD,IAArD,EAAiCiM,KAAMppB,CAAAA,QAAN,EAAjC,EAAiF,IAAjF,EAA6DupB,KAAMvpB,CAAAA,QAAN,EAA7D,EAEIuqB,SACA,CADYxZ,KAAMvS,CAAAA,UAAN,EACZ,CADiCsS,KAAMtS,CAAAA,UAAN,EACjC,CAAAgsB,KAAA,CAAYzZ,KAAMtS,CAAAA,UAAN,EAAZ,CAAiCqS,KAAMrS,CAAAA,UAAN,EAHrC,GAMInD,SAAUwC,CAAAA,eAAV,CAA0BgT,KAA1B,CAAiCC,KAAjC,CAAwCoZ,UAAxC,CAGA,CADAI,SACA,CADYJ,UAAA,CAAW,CAAX,CACZ,CAD4BA,UAAA,CAAW,CAAX,CAC5B,CAAAK,KAAA,CAAYL,UAAA,CAAW,CAAX,CAAZ;AAA4BA,UAAA,CAAW,CAAX,CAThC,CAkCA,CArBIjsB,IAAKC,CAAAA,GAAL,CAASosB,SAAT,CAqBJ,CArB0Bhb,iBAAkBiB,CAAAA,kBAqB5C,GApBE+Z,SAoBF,CApBchvB,KAAM6C,CAAAA,IAAN,CAAWmsB,SAAX,CAoBd,CApBsChb,iBAAkBiB,CAAAA,kBAoBxD,EAjBItS,IAAKC,CAAAA,GAAL,CAASqsB,KAAT,CAiBJ,CAjB0Bjb,iBAAkBiB,CAAAA,kBAiB5C,GAhBEga,KAgBF,CAhBcjvB,KAAM6C,CAAAA,IAAN,CAAWosB,KAAX,CAgBd,CAhBsCjb,iBAAkBiB,CAAAA,kBAgBxD,EAbAia,aAaA,CAbkBF,SAalB,CAb8BA,SAa9B,CAb0CC,KAa1C,CAbsDA,KAatD,CAZAE,KAYA,CAZWxsB,IAAKG,CAAAA,IAAL,CAAUosB,aAAV,CAYX,CAVAE,aAUA,CAViB,IAAK/D,CAAAA,iBAUtB,CAV0CwC,KAAMrlB,CAAAA,YAUhD,CAV+DwlB,KAAMxlB,CAAAA,YAUrE,CAVoF0mB,aAUpF,CAPAL,SAOA,CAPkBO,aAOlB,CAPmCJ,SAOnC,CAP+CG,KAO/C,CANAL,KAMA,CANkBM,aAMlB,CANmCH,KAMnC,CAN+CE,KAM/C,CAHAtB,KAAMgB,CAAAA,eAGN;AAHyBA,SAGzB,CAFAhB,KAAMiB,CAAAA,eAEN,EAFyBA,KAEzB,CADAd,KAAMa,CAAAA,eACN,EADyBA,SACzB,CAAAb,KAAMc,CAAAA,eAAN,EAAyBA,KAlEiC,CAsEhE7D,SAAShtB,CAAAA,SAAUmwB,CAAAA,sBAAnB,CAA4CiB,QAAS,CAAC3tB,IAAD,CAAO,CAS1D,IAAAwR,WAAaxR,IAAKO,CAAAA,QAAL,EAEb,KAAAqtB,cAAgBpc,UAAWvJ,CAAAA,QAAX,EAAhB2lB,CAAwCpc,UAAWzJ,CAAAA,OAAX,EAAxC6lB,EAAgE,CAChE,KAAAC,cAAgBrc,UAAWxJ,CAAAA,MAAX,EAAhB6lB,CAAsCrc,UAAWtJ,CAAAA,SAAX,EAAtC2lB,EAAgE,CAChEP,aAAA,CAAYttB,IAAKuB,CAAAA,UAAL,EAAZ,CAAgCqsB,YAChCL,aAAA,CAAYvtB,IAAKwB,CAAAA,UAAL,EAAZ,CAAgCqsB,YAChC,KAAAC,aAAe7sB,IAAKC,CAAAA,GAAL,CAASosB,YAAT,CAAfQ,CAAqC9tB,IAAKoD,CAAAA,QAAL,EAArC0qB,CAAuD,CACvD,KAAAC,aAAe9sB,IAAKC,CAAAA,GAAL,CAASqsB,YAAT,CAAfQ;AAAqC/tB,IAAKwD,CAAAA,SAAL,EAArCuqB,CAAwD,CAExD,IAAI/tB,IAAKO,CAAAA,QAAL,EAAJ,EAAuB,IAAKuB,CAAAA,YAAaxB,CAAAA,OAAlB,EAAvB,CAII,IAFAyB,UAEI,CAFYyP,UAAWzK,CAAAA,gBAAX,EAEZ,CAF4C,IAAK+iB,CAAAA,kBAEjD,CAAAgE,YAAA,CAAe/rB,UAAf,EAAgCgsB,YAAhC,CAA+ChsB,UAAnD,CACE/B,IAAKguB,CAAAA,iBACL,CADyB,CAAC,IAAKpE,CAAAA,eAC/B,CADiD0D,YACjD,CAAAttB,IAAKiuB,CAAAA,iBAAL,CAAyB,CAAC,IAAKrE,CAAAA,eAA/B,CAAiD2D,YAFnD,CAJJ,IAYI,IAFAxrB,UAEI,CAFYyP,UAAWzK,CAAAA,gBAAX,EAEZ,CAF4C,IAAKgjB,CAAAA,0BAEjD,CAAA+D,YAAA,CAAe/rB,UAAf,EAAgCgsB,YAAhC,CAA+ChsB,UAAnD,CACE/B,IAAKguB,CAAAA,iBACL,CADyB,CAAC,IAAKpE,CAAAA,eAC/B,CADiD0D,YACjD,CAD6D,IAAKzD,CAAAA,uBAClE;AAAA7pB,IAAKiuB,CAAAA,iBAAL,CAAyB,CAAC,IAAKrE,CAAAA,eAA/B,CAAiD2D,YAAjD,CAA6D,IAAK1D,CAAAA,uBAhCd,CAqC5DN,SAAShtB,CAAAA,SAAU2xB,CAAAA,WAAnB,CAAiCC,QAAS,EAAG,CAC3C,IACIC,WAAa,CAAA,CAEb,KAAK3D,CAAAA,eAAT,CAA2B,IAAKJ,CAAAA,aAAhC,CAAgD,CAAhD,GACE+D,UADF,CAC8E,CAD9E,CACentB,IAAKC,CAAAA,GAAL,CAAS,IAAKkpB,CAAAA,iBAAd,CAAkC,IAAKD,CAAAA,oBAAvC,CADf,CAIA,KAAAkE,UAAY,IAAKjE,CAAAA,iBAAjBiE,CAAqC,IAAKhD,CAAAA,0BAE1C,KAAKlB,CAAAA,oBAAL,CAA4B,IAAKC,CAAAA,iBAEjC,OAAOiE,UAAP,EAAoBD,UAZuB,CAe7C7E,SAAShtB,CAAAA,SAAU+xB,CAAAA,OAAnB,CAA6BC,QAAS,EAAG,CACnC,IAAKvO,CAAAA,qBAAT,EAAkC,CAAC,IAAKK,CAAAA,WAAxC,GACM,IAAKmK,CAAAA,qBAAT;AAAkC,IAAKvK,CAAAA,eAAvC,EACE,IAAK4B,CAAAA,MAAL,EACA,CAAA,IAAK2I,CAAAA,qBAAL,CAA6B,CAF/B,EAIE,IAAKA,CAAAA,qBAAL,EALJ,CADuC,CAYzCjB,SAAShtB,CAAAA,SAAUiyB,CAAAA,2BAAnB,CAAiDC,QAAS,EAAG,CAI3D,IAHA,IAAIzuB,IAAJ,CACIgQ,SAAW,IAAKlO,CAAAA,YAAagO,CAAAA,WAAlB,EADf,CAGShV,EAAI,CAAb,CAAgBA,CAAhB,CAAoBkV,QAAS/Q,CAAAA,MAA7B,CAAqCnE,CAAA,EAArC,CACEkF,IACA,CADOgQ,QAAA,CAASlV,CAAT,CACP,CAAAkF,IAAK8G,CAAAA,YAAL,CAAoB9G,IAAK4G,CAAAA,eAAL,EANqC,CAc7D2iB,SAAShtB,CAAAA,SAAUmyB,CAAAA,QAAnB,CAA8BC,QAAS,CAACxuB,KAAD,CAAQ,CAK7C,IAAAyuB,MAAQrS,QAAA,CAAStb,IAAK6Y,CAAAA,IAAL,EAAW3Z,KAAM8H,CAAAA,QAAN,EAAX,CAA8B9H,KAAM4H,CAAAA,OAAN,EAA9B,EAAiD,IAAKujB,CAAAA,cAAtD,CAAT,CACRuD,MAAA,CAAQtS,QAAA,CAAStb,IAAK6Y,CAAAA,IAAL,EAAW3Z,KAAM+H,CAAAA,SAAN,EAAX,CAA+B/H,KAAM6H,CAAAA,MAAN,EAA/B,EAAiD,IAAKsjB,CAAAA,cAAtD,CAAT,CAIR;IAFA,IAAIX,KAAW/pB,KAAJ,CAAUguB,KAAV,CAAX,CAES9zB,EAAI,CAAb,CAAgBA,CAAhB,CAAoB8zB,KAApB,CAA2B9zB,CAAA,EAA3B,CACE6vB,IAAA,CAAK7vB,CAAL,CAAA,CAAc8F,KAAJ,CAAUiuB,KAAV,CAGZ,KAAS/zB,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoB8zB,KAApB,CAA2B9zB,CAAA,EAA3B,CACE,IAAK,IAAIuxB,EAAI,CAAb,CAAgBA,CAAhB,CAAoBwC,KAApB,CAA2BxC,CAAA,EAA3B,CACE1B,IAAA,CAAK7vB,CAAL,CAAA,CAAQuxB,CAAR,CAAA,CAAa,EAIjB,OAAO1B,KApBsC,CAuB/CpB,SAAShtB,CAAAA,SAAUuyB,CAAAA,aAAnB,CAAmCC,QAAS,CAAC3T,CAAD,CAAIzS,IAAJ,CAAUC,GAAV,CAAe,CAOzD,IAAAomB,OAASzS,QAAA,CAAStb,IAAK2Y,CAAAA,KAAL,EAAYwB,CAAEta,CAAAA,OAAF,EAAYyB,CAAAA,CAAxB,CAA4BoG,IAA5B,EAAoC,IAAK2iB,CAAAA,cAAzC,CAAT,CACT2D,KAAA,CAAU1S,QAAA,CAAStb,IAAK2Y,CAAAA,KAAL,EAAYwB,CAAEta,CAAAA,OAAF,EAAY2B,CAAAA,KAAxB,CAAgC2Y,CAAEta,CAAAA,OAAF,EAAYyB,CAAAA,CAA5C,CAAgDoG,IAAhD,EAAwD,IAAK2iB,CAAAA,cAA7D,CAAT,CACV,KAAA4D,OAAS3S,QAAA,CAAStb,IAAK2Y,CAAAA,KAAL,EAAYwB,CAAEta,CAAAA,OAAF,EAAY0B,CAAAA,CAAxB,CAA4BoG,GAA5B,EAAmC,IAAK0iB,CAAAA,cAAxC,CAAT,CACT6D,IAAA,CAAU5S,QAAA,CAAStb,IAAK2Y,CAAAA,KAAL,EAAYwB,CAAEta,CAAAA,OAAF,EAAY4B,CAAAA,MAAxB,CAAiC0Y,CAAEta,CAAAA,OAAF,EAAY0B,CAAAA,CAA7C,CAAiDoG,GAAjD,EAAwD,IAAK0iB,CAAAA,cAA7D,CAAT,CAEV;IAAK,IAAIxwB,EAAIk0B,MAAb,CAAqBl0B,CAArB,EAA0Bm0B,IAA1B,CAAmCn0B,CAAA,EAAnC,CACE,IAAK,IAAIuxB,EAAI6C,MAAb,CAAqB7C,CAArB,EAA0B8C,GAA1B,CAAmC9C,CAAA,EAAnC,CACE,IAAK1B,CAAAA,IAAL,CAAU7vB,CAAV,CAAA,CAAauxB,CAAb,CAAgBzmB,CAAAA,IAAhB,CAAqBwV,CAArB,CACA,CAAAA,CAAEgU,CAAAA,kBAAF,CAAqBJ,MAArB,CAA6BC,IAA7B,CAAsCC,MAAtC,CAA8CC,GAA9C,CAfqD,CAoB3D5F,SAAShtB,CAAAA,SAAU0vB,CAAAA,UAAnB,CAAgCoD,QAAS,EAAG,CAC1C,IAAIv0B,CAAJ,CAEIkxB,OAAS,IAAKlc,CAAAA,WAAL,EAEb,KAAK6a,CAAAA,IAAL,CAAY,IAAK+D,CAAAA,QAAL,CAAc,IAAK5sB,CAAAA,YAAaxB,CAAAA,OAAlB,EAAd,CAGZ,KAAKxF,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBkxB,MAAO/sB,CAAAA,MAAvB,CAA+BnE,CAAA,EAA/B,CAAoC,CAClC,IAAAqxB,MAAQH,MAAA,CAAOlxB,CAAP,CACR,KAAKg0B,CAAAA,aAAL,CAAmB3C,KAAnB,CAA0B,IAAKrqB,CAAAA,YAAaxB,CAAAA,OAAlB,EAA4ByH,CAAAA,OAA5B,EAA1B,CAAiE,IAAKjG,CAAAA,YAAaxB,CAAAA,OAAlB,EAA4B0H,CAAAA,MAA5B,EAAjE,CAFkC,CARM,CAc5CuhB,SAAShtB,CAAAA,SAAU6vB,CAAAA,8BAAnB,CAAoDkD,QAAS,CAACnD,KAAD,CAAQD,gBAAR,CAA0BJ,iBAA1B;AAA6CC,4BAA7C,CAA2E,CAEtI,GAA8E,CAA9E,EAAI,IAAKtB,CAAAA,eAAT,CAA2BnY,iBAAkBoB,CAAAA,6BAA7C,EAAmFoY,iBAAnF,EAAwGC,4BAAxG,CAAsI,CAChIwD,iBAAAA,CAAc,IAAIppB,GACtBgmB,MAAMoD,CAAAA,WAAN,CAAoB,EAIpB,KAFA,IAAI5E,KAAO,IAAKA,CAAAA,IAAhB,CAES7vB,EAAIqxB,KAAM6C,CAAAA,MAAVl0B,CAAmB,CAA5B,CAA+BA,CAA/B,CAAmCqxB,KAAM8C,CAAAA,OAAzC,CAAmD,CAAnD,CAAsDn0B,CAAA,EAAtD,CACE,IAAK,IAAIuxB,EAAIF,KAAM+C,CAAAA,MAAV7C,CAAmB,CAA5B,CAA+BA,CAA/B,CAAmCF,KAAMgD,CAAAA,OAAzC,CAAmD,CAAnD,CAAsD9C,CAAA,EAAtD,CACE,GAAI,EAAM,CAAN,CAAEvxB,CAAF,EAAe,CAAf,CAAWuxB,CAAX,EAAoBvxB,CAApB,EAAyB6vB,IAAK1rB,CAAAA,MAA9B,EAAwCotB,CAAxC,EAA6C1B,IAAA,CAAK,CAAL,CAAQ1rB,CAAAA,MAArD,CAAJ,CACE,IAAK,IAAI4kB,EAAI,CAAb,CAAgBA,CAAhB,CAAoB8G,IAAA,CAAK7vB,CAAL,CAAA,CAAQuxB,CAAR,CAAWptB,CAAAA,MAA/B,CAAuC4kB,CAAA,EAAvC,CAKE,GAJAyI,4BAUI,CAVI3B,IAAA,CAAK7vB,CAAL,CAAA,CAAQuxB,CAAR,CAAA,CAAWxI,CAAX,CAUJ,CANAsI,KAAM5rB,CAAAA,QAAN,EAMA,EANoB+rB,4BAAM/rB,CAAAA,QAAN,EAMpB;AANwC4rB,KAMxC,EANiDG,4BAMjD,EAAA,CAACJ,gBAAiB9d,CAAAA,GAAjB,CAAqBke,4BAArB,CAAD,EAAgC,CAACiD,iBAAYnhB,CAAAA,GAAZ,CAAgBke,4BAAhB,CANrC,CAM6D,CAC3D,IAAIgB,UAAYrsB,IAAKC,CAAAA,GAAL,CAASirB,KAAM5qB,CAAAA,UAAN,EAAT,CAA8B+qB,4BAAM/qB,CAAAA,UAAN,EAA9B,CAAZ+rB,EAAiEnB,KAAM/oB,CAAAA,QAAN,EAAjEkqB,CAAoF,CAApFA,CAAwFhB,4BAAMlpB,CAAAA,QAAN,EAAxFkqB,CAA2G,CAA3GA,CAAJ,CACIC,UAAYtsB,IAAKC,CAAAA,GAAL,CAASirB,KAAM3qB,CAAAA,UAAN,EAAT,CAA8B8qB,4BAAM9qB,CAAAA,UAAN,EAA9B,CAAZ+rB,EAAiEpB,KAAM3oB,CAAAA,SAAN,EAAjE+pB,CAAqF,CAArFA,CAAyFjB,4BAAM9oB,CAAAA,SAAN,EAAzF+pB,CAA6G,CAA7GA,CAIAD,UAAJ,EAAiB,IAAKhC,CAAAA,cAAtB,EAAwCiC,SAAxC,EAAqD,IAAKjC,CAAAA,cAA1D;AAEEiE,iBAAYnpB,CAAAA,GAAZ,CAAgBkmB,4BAAhB,CARyD,CAgBjD,gBAAA,CAAA,EAAG7c,6BAAAA,CAAH,gBAAGA,CAAAA,MArcQ,IAAI7O,KAAM2e,CAAAA,OAAN,CAqccgQ,iBArcd,CAAJ,CAAwB,CAAWz0B,IAAAA,CAAI,CAAb,KAAgB0kB,CAAhB,CAAuB5e,KAAA,CAqc/B2uB,iBArcyCtwB,CAAAA,MAAV,CAAvB,CAA0CnE,IAA1C,CAqcRy0B,iBArc0DtwB,CAAAA,MAAlD,CAA0DnE,IAAA,EAA1D,CAAiE0kB,CAAA,CAAK1kB,IAAL,CAAA,CAqczEy0B,iBArcmF,CAAIz0B,IAAJ,CAAU,kBAAA,CAAO0kB,CAA9F,CAAxB,IAAqI,kBAAA,CAAO5e,KAAM6e,CAAAA,IAAN,CAqc1H8P,iBArc0H,CAqc3KpD,MAAMoD,CAAAA,WAAN,CAAuB9f,4BAAH,CAAA,IAAA,CAAA,gBAAA,CAAU,iBAAV,CApCgH,CAsCtI,IAAK3U,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBqxB,KAAMoD,CAAAA,WAAYtwB,CAAAA,MAAlC,CAA0CnE,CAAA,EAA1C,CACE,IAAKyxB,CAAAA,kBAAL,CAAwBJ,KAAxB;AAA+BA,KAAMoD,CAAAA,WAAN,CAAkBz0B,CAAlB,CAA/B,CAzCoI,CA6CxIyuB,SAAShtB,CAAAA,SAAUgvB,CAAAA,kBAAnB,CAAwCiE,QAAS,EAAG,CAClD,MAAO,EAD2C,CAIpDr1B,OAAOC,CAAAA,OAAP,CAAiBmvB,QArdqC,CAjpG5C,CA0mHH,QAAQ,CAACpvB,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAQtD80B,QAASA,aAAY,CAAC3xB,MAAD,CAASC,MAAT,CAAiBC,KAAjB,CAAwB,CAC3CH,KAAM7C,CAAAA,IAAN,CAAW,IAAX,CAAiB8C,MAAjB,CAAyBC,MAAzB,CAAiCC,KAAjC,CACA,KAAKgtB,CAAAA,WAAL,CAAmB1Y,iBAAkBE,CAAAA,mBAFM,CAH7C,IAAI3U,MAAQlD,mBAAA,CAAoB,CAApB,CAAZ,CACI2X,kBAAoB3X,mBAAA,CAAoB,CAApB,CAOxB80B,aAAalzB,CAAAA,SAAb,CAAyBb,MAAO6C,CAAAA,MAAP,CAAcV,KAAMtB,CAAAA,SAApB,CAEzB,KAAKiC,IAAIA,IAAT,GAAiBX,MAAjB,CACE4xB,YAAA,CAAajxB,IAAb,CAAA,CAAqBX,KAAA,CAAMW,IAAN,CAGvBrE,OAAOC,CAAAA,OAAP,CAAiBq1B,YAnBqC,CA1mH5C,CAioHH,QAAQ,CAACt1B,MAAD;AAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAOtD+0B,QAASA,aAAY,CAAChuB,EAAD,CAAKC,GAAL,CAAUC,IAAV,CAAgBC,KAAhB,CAAuB,CAE1CJ,KAAMzG,CAAAA,IAAN,CAAW,IAAX,CAAiB0G,EAAjB,CAAqBC,GAArB,CAA0BC,IAA1B,CAAgCC,KAAhC,CAgBA,KAAKstB,CAAAA,OAAL,CADA,IAAKD,CAAAA,MACL,CAFA,IAAKD,CAAAA,OAEL,CAHA,IAAKD,CAAAA,MAGL,CANA,IAAKW,CAAAA,aAML,CAPA,IAAKC,CAAAA,aAOL,CATA,IAAK3B,CAAAA,iBASL,CAVA,IAAKD,CAAAA,iBAUL,CAXA,IAAKZ,CAAAA,eAWL,CAZA,IAAKD,CAAAA,eAYL,CAbA,IAAKH,CAAAA,YAaL,CAdA,IAAKD,CAAAA,YAcL,CAdoB,CAiBpB,KAAKwC,CAAAA,WAAL,CAAmB,EArBuB,CAF5C,IAAI9tB,MAAQ9G,mBAAA,CAAoB,CAApB,CA0BZ+0B,aAAanzB,CAAAA,SAAb,CAAyBb,MAAO6C,CAAAA,MAAP,CAAckD,KAAMlF,CAAAA,SAApB,CAEzB,KAAKiC,IAAIA,IAAT,GAAiBiD,MAAjB,CACEiuB,YAAA,CAAalxB,IAAb,CAAA,CAAqBiD,KAAA,CAAMjD,IAAN,CAGvBkxB,aAAanzB,CAAAA,SAAU6yB,CAAAA,kBAAvB;AAA4CS,QAAS,CAACC,OAAD,CAAUC,QAAV,CAAoBC,OAApB,CAA6BC,QAA7B,CAAuC,CAC1F,IAAKjB,CAAAA,MAAL,CAAcc,OACd,KAAKb,CAAAA,OAAL,CAAec,QACf,KAAKb,CAAAA,MAAL,CAAcc,OACd,KAAKb,CAAAA,OAAL,CAAec,QAJ2E,CAO5F91B,OAAOC,CAAAA,OAAP,CAAiBs1B,YA5CqC,CAjoH5C,CAirHH,QAAQ,CAACv1B,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtDqP,QAASA,WAAU,CAACvH,KAAD,CAAQC,MAAR,CAAgB,CAEjC,IAAKA,CAAAA,MAAL,CADA,IAAKD,CAAAA,KACL,CADa,CAEC,KAAd,GAAIA,KAAJ,EAAiC,IAAjC,GAAsBC,MAAtB,GACE,IAAKA,CAAAA,MACL,CADcA,MACd,CAAA,IAAKD,CAAAA,KAAL,CAAaA,KAFf,CAHiC,CASnCuH,UAAWzN,CAAAA,SAAU6G,CAAAA,QAArB,CAAgC8sB,QAAS,EAAG,CAC1C,MAAO,KAAKztB,CAAAA,KAD8B,CAI5CuH,WAAWzN,CAAAA,SAAU+G,CAAAA,QAArB,CAAgC6sB,QAAS,CAAC1tB,KAAD,CAAQ,CAC/C,IAAKA,CAAAA,KAAL,CAAaA,KADkC,CAIjDuH,WAAWzN,CAAAA,SAAUiH,CAAAA,SAArB,CAAiC4sB,QAAS,EAAG,CAC3C,MAAO,KAAK1tB,CAAAA,MAD+B,CAI7CsH;UAAWzN,CAAAA,SAAUmH,CAAAA,SAArB,CAAiC2sB,QAAS,CAAC3tB,MAAD,CAAS,CACjD,IAAKA,CAAAA,MAAL,CAAcA,MADmC,CAInDvI,OAAOC,CAAAA,OAAP,CAAiB4P,UA9BqC,CAjrH5C,CAmtHH,QAAQ,CAAC7P,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAOtD21B,QAASA,QAAO,EAAG,CACjB,IAAKC,CAAAA,GAAL,CAAW,EACX,KAAK3M,CAAAA,IAAL,CAAY,EAFK,CAFnB,IAAItF,kBAAoB3jB,mBAAA,CAAoB,EAApB,CAOxB21B,QAAQ/zB,CAAAA,SAAUi0B,CAAAA,GAAlB,CAAwBC,QAAS,CAACpW,GAAD,CAAMjf,KAAN,CAAa,CAC5C,IAAIs1B,MAAQpS,iBAAkBK,CAAAA,QAAlB,CAA2BtE,GAA3B,CACP,KAAKsW,CAAAA,QAAL,CAAcD,KAAd,CAAL,GACE,IAAKH,CAAAA,GAAL,CAASG,KAAT,CACA,CADkBt1B,KAClB,CAAA,IAAKwoB,CAAAA,IAAKhe,CAAAA,IAAV,CAAeyU,GAAf,CAFF,CAF4C,CAQ9CiW,QAAQ/zB,CAAAA,SAAUo0B,CAAAA,QAAlB,CAA6BC,QAAS,CAACvW,GAAD,CAAM,CAC9BiE,iBAAkBK,CAAAA,QAAlB,CAA2BtE,GAA3B,CACZ,OAAwB,KAAxB,EAAO,IAAKkW,CAAAA,GAAL,CAASlW,GAAT,CAFmC,CAK5CiW,QAAQ/zB,CAAAA,SAAUT,CAAAA,GAAlB;AAAwB+0B,QAAS,CAACxW,GAAD,CAAM,CACjCqW,GAAAA,CAAQpS,iBAAkBK,CAAAA,QAAlB,CAA2BtE,GAA3B,CACZ,OAAO,KAAKkW,CAAAA,GAAL,CAASG,GAAT,CAF8B,CAKvCJ,QAAQ/zB,CAAAA,SAAUu0B,CAAAA,MAAlB,CAA2BC,QAAS,EAAG,CACrC,MAAO,KAAKnN,CAAAA,IADyB,CAIvCzpB,OAAOC,CAAAA,OAAP,CAAiBk2B,OAlCqC,CAntH5C,CAyvHH,QAAQ,CAACn2B,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAOtDq2B,QAASA,QAAO,EAAG,CACjB,IAAK7N,CAAAA,GAAL,CAAW,EADM,CAFnB,IAAI7E,kBAAoB3jB,mBAAA,CAAoB,EAApB,CAOxBq2B,QAAQz0B,CAAAA,SAAU6J,CAAAA,GAAlB,CAAwB6qB,QAAS,CAAC/kB,GAAD,CAAM,CACrC,IAAIwkB,MAAQpS,iBAAkBK,CAAAA,QAAlB,CAA2BzS,GAA3B,CACP,KAAKykB,CAAAA,QAAL,CAAcD,KAAd,CAAL,GAA2B,IAAKvN,CAAAA,GAAL,CAASuN,KAAT,CAA3B,CAA6CxkB,GAA7C,CAFqC,CAKvC8kB,QAAQz0B,CAAAA,SAAUyP,CAAAA,MAAlB,CAA2BklB,QAAS,CAAChlB,GAAD,CAAM,CACxC,OAAO,IAAKiX,CAAAA,GAAL,CAAS7E,iBAAkBK,CAAAA,QAAlB,CAA2BzS,GAA3B,CAAT,CADiC,CAI1C8kB,QAAQz0B,CAAAA,SAAU40B,CAAAA,KAAlB;AAA0BC,QAAS,EAAG,CACpC,IAAKjO,CAAAA,GAAL,CAAW,EADyB,CAItC6N,QAAQz0B,CAAAA,SAAUo0B,CAAAA,QAAlB,CAA6BU,QAAS,CAACnlB,GAAD,CAAM,CAC1C,MAAO,KAAKiX,CAAAA,GAAL,CAAS7E,iBAAkBK,CAAAA,QAAlB,CAA2BzS,GAA3B,CAAT,CAAP,EAAoDA,GADV,CAI5C8kB,QAAQz0B,CAAAA,SAAU+0B,CAAAA,OAAlB,CAA4BC,QAAS,EAAG,CACtC,MAAuB,EAAvB,GAAO,IAAK3vB,CAAAA,IAAL,EAD+B,CAIxCovB,QAAQz0B,CAAAA,SAAUqF,CAAAA,IAAlB,CAAyB4vB,QAAS,EAAG,CACnC,MAAO91B,OAAOkoB,CAAAA,IAAP,CAAY,IAAKT,CAAAA,GAAjB,CAAsBlkB,CAAAA,MADM,CAKrC+xB,QAAQz0B,CAAAA,SAAUk1B,CAAAA,QAAlB,CAA6BC,QAAS,CAAC9W,IAAD,CAAO,CAG3C,IAFA,IAAIgJ,KAAOloB,MAAOkoB,CAAAA,IAAP,CAAY,IAAKT,CAAAA,GAAjB,CAAX,CACIlkB,OAAS2kB,IAAK3kB,CAAAA,MADlB,CAESnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoBmE,MAApB,CAA4BnE,CAAA,EAA5B,CACE8f,IAAKhV,CAAAA,IAAL,CAAU,IAAKud,CAAAA,GAAL,CAASS,IAAA,CAAK9oB,CAAL,CAAT,CAAV,CAJyC,CAQ7Ck2B,QAAQz0B,CAAAA,SAAUqF,CAAAA,IAAlB,CAAyB4vB,QAAS,EAAG,CACnC,MAAO91B,OAAOkoB,CAAAA,IAAP,CAAY,IAAKT,CAAAA,GAAjB,CAAsBlkB,CAAAA,MADM,CAIrC+xB,QAAQz0B,CAAAA,SAAUo1B,CAAAA,MAAlB,CAA2BC,QAAS,CAAChX,IAAD,CAAO,CAEzC,IADA,IAAIle;AAAIke,IAAK3b,CAAAA,MAAb,CACSnE,EAAI,CAAb,CAAgBA,CAAhB,CAAoB4B,CAApB,CAAuB5B,CAAA,EAAvB,CAEE,IAAKsL,CAAAA,GAAL,CADQwU,IAAAQ,CAAKtgB,CAALsgB,CACR,CAJuC,CAQ3CjhB,OAAOC,CAAAA,OAAP,CAAiB42B,OA1DqC,CAzvH5C,CAuzHH,QAAQ,CAAC72B,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtD,IAAIqf,aAAe,QAAS,EAAG,CAAEC,QAASA,iBAAgB,CAAClc,MAAD,CAASmc,KAAT,CAAgB,CAAE,IAAK,IAAIpf,EAAI,CAAb,CAAgBA,CAAhB,CAAoBof,KAAMjb,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,CAAuC,CAAE,IAAIqf,WAAaD,KAAA,CAAMpf,CAAN,CAAUqf,WAAWte,CAAAA,UAAX,CAAwBse,UAAWte,CAAAA,UAAnC,EAAiD,CAAA,CAAOse,WAAWve,CAAAA,YAAX,CAA0B,CAAA,CAAU,QAAJ,EAAeue,WAAf,GAA2BA,UAAWC,CAAAA,QAAtC,CAAiD,CAAA,CAAjD,CAAuD1e,OAAOC,CAAAA,cAAP,CAAsBoC,MAAtB,CAA8Boc,UAAWE,CAAAA,GAAzC,CAA8CF,UAA9C,CAA5K,CAAzC,CAAoR,MAAO,SAAS,CAACG,WAAD,CAAcC,UAAd,CAA0BC,WAA1B,CAAuC,CAAMD,UAAJ,EAAgBN,gBAAA,CAAiBK,WAAY/d,CAAAA,SAA7B;AAAwCge,UAAxC,CAAyDC,YAAJ,EAAiBP,gBAAA,CAAiBK,WAAjB,CAA8BE,WAA9B,CAA4C,OAAOF,YAA3I,CAAtX,CAAZ,EAAnB,CAWIvP,WAAapQ,mBAAA,CAAoB,EAApB,CAEbk3B,QAAAA,CAAY,QAAS,EAAG,CACxBA,QAASA,UAAS,CAACC,CAAD,CAAIC,eAAJ,CAAqB,CAZO,GAAI,EAa9B7W,IAb8B,WAaxB2W,UAbwB,CAAJ,CAA0C,KAAM,KAAI1W,SAAJ,CAAc,mCAAd,CAAN,CAepF,GAAwB,IAAxB,GAAI4W,eAAJ,EAAoDjlB,IAAAA,EAApD,GAAgCilB,eAAhC,CAA+D,IAAKA,CAAAA,eAAL,CAAuB,IAAKC,CAAAA,uBAG9D/yB,gBAAA,CAAzB6yB,CAAJ,WAAiB/mB,WAAjB,CAAsC+mB,CAAElwB,CAAAA,IAAF,EAAtC,CAA6DkwB,CAAE7yB,CAAAA,MAE/D,KAAKgzB,CAAAA,UAAL,CAAgBH,CAAhB,CAAmB,CAAnB,CAAsB7yB,eAAtB,CAA+B,CAA/B,CARmC,CAWvC+a,YAAA,CAAa6X,SAAb,CAAwB,CAAC,CACrBxX,IAAK,YADgB;AAErBjf,MAAO62B,QAAmB,CAACH,CAAD,CAAIr1B,CAAJ,CAAO6c,CAAP,CAAU,CAChC,GAAI7c,CAAJ,CAAQ6c,CAAR,CAAW,CACP,IAAID,EAAI,IAAK6Y,CAAAA,UAAL,CAAgBJ,CAAhB,CAAmBr1B,CAAnB,CAAsB6c,CAAtB,CACR,KAAK2Y,CAAAA,UAAL,CAAgBH,CAAhB,CAAmBr1B,CAAnB,CAAsB4c,CAAtB,CACA,KAAK4Y,CAAAA,UAAL,CAAgBH,CAAhB,CAAmBzY,CAAnB,CAAuB,CAAvB,CAA0BC,CAA1B,CAHO,CADqB,CAFf,CAAD,CASrB,CACCe,IAAK,YADN,CAECjf,MAAO82B,QAAmB,CAACJ,CAAD,CAAIr1B,CAAJ,CAAO6c,CAAP,CAAU,CAIhC,IAHA,IAAI/W,EAAI,IAAK4vB,CAAAA,IAAL,CAAUL,CAAV,CAAar1B,CAAb,CAGR,CAAA,CAAA,CAAa,CACT,IAAA,CAAO,IAAKs1B,CAAAA,eAAL,CAAqBxvB,CAArB,CAAwB,IAAK4vB,CAAAA,IAAL,CAAUL,CAAV,CAAazF,CAAb,CAAxB,CAAP,CAAA,CACIA,CAAA,EACH,KAAA,CAAO,IAAK0F,CAAAA,eAAL,CAAqB,IAAKI,CAAAA,IAAL,CAAUL,CAAV,CAAah3B,CAAb,CAArB,CAAsCyH,CAAtC,CAAP,CAAA,CACGzH,CAAA,EACH,IAAIA,CAAJ,CAAQuxB,CAAR,CACG,IAAK+F,CAAAA,KAAL,CAAWN,CAAX,CAAch3B,CAAd,CAAiBuxB,CAAjB,CAEA,CADAvxB,CAAA,EACA,CAAAuxB,CAAA,EAHH,KAIM,OAAOA,EATL,CAJmB,CAFrC,CATqB,CA2BrB,CACChS,IAAK,MADN,CAECjf,MAAO+2B,QAAa,CAAC91B,MAAD,CAASgQ,KAAT,CAAgB,CAChC,MAAIhQ,OAAJ,WAAsB0O,WAAtB,CAAyC1O,MAAO0f,CAAAA,aAAP,CAAqB1P,KAArB,CAAzC,CAAiFhQ,MAAA,CAAOgQ,KAAP,CADjD,CAFrC,CA3BqB,CAgCrB,CACCgO,IAAK,MADN,CAECjf,MAAOi3B,QAAa,CAACh2B,MAAD,CAASgQ,KAAT,CAAgBjR,KAAhB,CAAuB,CACnCiB,MAAJ;AAAsB0O,UAAtB,CAAkC1O,MAAO4f,CAAAA,aAAP,CAAqB5P,KAArB,CAA4BjR,KAA5B,CAAlC,CAA0EiB,MAAA,CAAOgQ,KAAP,CAA1E,CAA0FjR,KADnD,CAF5C,CAhCqB,CAqCrB,CACCif,IAAK,OADN,CAECjf,MAAOg3B,QAAc,CAACN,CAAD,CAAIh3B,CAAJ,CAAOuxB,CAAP,CAAU,CAC3B,IAAIjJ,KAAO,IAAK+O,CAAAA,IAAL,CAAUL,CAAV,CAAah3B,CAAb,CACX,KAAKu3B,CAAAA,IAAL,CAAUP,CAAV,CAAah3B,CAAb,CAAgB,IAAKq3B,CAAAA,IAAL,CAAUL,CAAV,CAAazF,CAAb,CAAhB,CACA,KAAKgG,CAAAA,IAAL,CAAUP,CAAV,CAAazF,CAAb,CAAgBjJ,IAAhB,CAH2B,CAFhC,CArCqB,CA4CrB,CACC/I,IAAK,yBADN,CAECjf,MAAO42B,QAAgC,CAAC7Y,CAAD,CAAIC,CAAJ,CAAO,CAC1C,MAAOA,EAAP,CAAWD,CAD+B,CAF/C,CA5CqB,CAAxB,CAmDA,OAAO0Y,UA/DiB,CAAZ,EAkEhB13B,OAAOC,CAAAA,OAAP,CAAiBy3B,OApFqC,CAvzH5C,CA+4HH,QAAQ,CAAC13B,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtD,IAAIqf,aAAe,QAAS,EAAG,CAAEC,QAASA,iBAAgB,CAAClc,MAAD,CAASmc,KAAT,CAAgB,CAAE,IAAK,IAAIpf,EAAI,CAAb,CAAgBA,CAAhB,CAAoBof,KAAMjb,CAAAA,MAA1B,CAAkCnE,CAAA,EAAlC,CAAuC,CAAE,IAAIqf,WAAaD,KAAA,CAAMpf,CAAN,CAAUqf,WAAWte,CAAAA,UAAX,CAAwBse,UAAWte,CAAAA,UAAnC;AAAiD,CAAA,CAAOse,WAAWve,CAAAA,YAAX,CAA0B,CAAA,CAAU,QAAJ,EAAeue,WAAf,GAA2BA,UAAWC,CAAAA,QAAtC,CAAiD,CAAA,CAAjD,CAAuD1e,OAAOC,CAAAA,cAAP,CAAsBoC,MAAtB,CAA8Boc,UAAWE,CAAAA,GAAzC,CAA8CF,UAA9C,CAA5K,CAAzC,CAAoR,MAAO,SAAS,CAACG,WAAD,CAAcC,UAAd,CAA0BC,WAA1B,CAAuC,CAAMD,UAAJ,EAAgBN,gBAAA,CAAiBK,WAAY/d,CAAAA,SAA7B,CAAwCge,UAAxC,CAAyDC,YAAJ,EAAiBP,gBAAA,CAAiBK,WAAjB,CAA8BE,WAA9B,CAA4C,OAAOF,YAA3I,CAAtX,CAAZ,EAcfgY,QAAAA,CAAkB,QAAS,EAAG,CAC9BA,QAASA,gBAAe,CAACC,SAAD,CAAYC,SAAZ,CAAuB,CAC3C,IAAIC,YAAiC,CAAnB,CAAAlI,SAAUtrB,CAAAA,MAAV,EAAyC6N,IAAAA,EAAzC,GAAwByd,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,CAAtF,CACImI,iBAAsC,CAAnB,CAAAnI,SAAUtrB,CAAAA,MAAV;AAAyC6N,IAAAA,EAAzC,GAAwByd,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,EAD3F,CAEIoI,YAAiC,CAAnB,CAAApI,SAAUtrB,CAAAA,MAAV,EAAyC6N,IAAAA,EAAzC,GAAwByd,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,EAhB5C,IAAI,EAkB9BrP,IAlB8B,WAkBxBoX,gBAlBwB,CAAJ,CAA0C,KAAM,KAAInX,SAAJ,CAAc,mCAAd,CAAN,CAoBpF,IAAKoX,CAAAA,SAAL,CAAiBA,SACjB,KAAKC,CAAAA,SAAL,CAAiBA,SACjB,KAAKC,CAAAA,WAAL,CAAmBA,WACnB,KAAKC,CAAAA,gBAAL,CAAwBA,gBACxB,KAAKC,CAAAA,WAAL,CAAmBA,WAGnB,KAAKC,CAAAA,IAAL,CAAYL,SAAUtzB,CAAAA,MAAtB,CAA+B,CAC/B,KAAK4zB,CAAAA,IAAL,CAAYL,SAAUvzB,CAAAA,MAAtB,CAA+B,CAG/B,KAAK0rB,CAAAA,IAAL,CAAgB/pB,KAAJ,CAAU,IAAKgyB,CAAAA,IAAf,CACZ,KAAS93B,WAAT,CAAa,CAAb,CAAgBA,WAAhB,CAAoB,IAAK83B,CAAAA,IAAzB,CAA+B93B,WAAA,EAA/B,CAGI,IAFA,IAAK6vB,CAAAA,IAAL,CAAU7vB,WAAV,CAESuxB;AAFUzrB,KAAJ,CAAU,IAAKiyB,CAAAA,IAAf,CAENxG,CAAAA,gBAAAA,CAAI,CAAb,CAAgBA,gBAAhB,CAAoB,IAAKwG,CAAAA,IAAzB,CAA+BxG,gBAAA,EAA/B,CACI,IAAK1B,CAAAA,IAAL,CAAU7vB,WAAV,CAAA,CAAauxB,gBAAb,CAAA,CAAkB,CAK1B,KAAKyG,CAAAA,aAAL,CAAyBlyB,KAAJ,CAAU,IAAKgyB,CAAAA,IAAf,CACrB,KAASG,WAAT,CAAc,CAAd,CAAiBA,WAAjB,CAAsB,IAAKH,CAAAA,IAA3B,CAAiCG,WAAA,EAAjC,CAGI,IAFA,IAAKD,CAAAA,aAAL,CAAmBC,WAAnB,CAESC,CAFoBpyB,KAAJ,CAAU,IAAKiyB,CAAAA,IAAf,CAEhBG,CAAAA,gBAAAA,CAAK,CAAd,CAAiBA,gBAAjB,CAAsB,IAAKH,CAAAA,IAA3B,CAAiCG,gBAAA,EAAjC,CACI,IAAKF,CAAAA,aAAL,CAAmBC,WAAnB,CAAA,CAAuBC,gBAAvB,CAAA,CAA6B,CAAC,IAAD,CAAO,IAAP,CAAa,IAAb,CAKrC,KAAKC,CAAAA,UAAL,CAAkB,EAGlB,KAAKC,CAAAA,KAAL,CAAa,EAGb,KAAKC,CAAAA,YAAL,EA5C2C,CA+C/CnZ,YAAA,CAAasY,eAAb,CAA8B,CAAC,CAC3BjY,IAAK,UADsB,CAE3Bjf,MAAOg4B,QAAiB,EAAG,CACvB,MAAO,KAAKF,CAAAA,KADW,CAFA,CAAD;AAK3B,CACC7Y,IAAK,eADN,CAECjf,MAAOi4B,QAAsB,EAAG,CAC5B,MAAO,KAAKJ,CAAAA,UADgB,CAFjC,CAL2B,CAa3B,CACC5Y,IAAK,cADN,CAECjf,MAAO+3B,QAAqB,EAAG,CAE3B,IAAK,IAAI9G,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAKwG,CAAAA,IAAzB,CAA+BxG,CAAA,EAA/B,CACI,IAAK1B,CAAAA,IAAL,CAAU,CAAV,CAAA,CAAa0B,CAAb,CACA,CADkB,IAAK1B,CAAAA,IAAL,CAAU,CAAV,CAAA,CAAa0B,CAAb,CAAiB,CAAjB,CAClB,CADwC,IAAKsG,CAAAA,WAC7C,CAAA,IAAKG,CAAAA,aAAL,CAAmB,CAAnB,CAAA,CAAsBzG,CAAtB,CAAA,CAA2B,CAAC,CAAA,CAAD,CAAQ,CAAA,CAAR,CAAe,CAAA,CAAf,CAI/B,KAASvxB,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoB,IAAK83B,CAAAA,IAAzB,CAA+B93B,CAAA,EAA/B,CACI,IAAK6vB,CAAAA,IAAL,CAAU7vB,CAAV,CAAA,CAAa,CAAb,CACA,CADkB,IAAK6vB,CAAAA,IAAL,CAAU7vB,CAAV,CAAc,CAAd,CAAA,CAAiB,CAAjB,CAClB,CADwC,IAAK63B,CAAAA,WAC7C,CAAA,IAAKG,CAAAA,aAAL,CAAmBh4B,CAAnB,CAAA,CAAsB,CAAtB,CAAA,CAA2B,CAAC,CAAA,CAAD,CAAQ,CAAA,CAAR,CAAc,CAAA,CAAd,CAI/B,KAASw4B,CAAT,CAAe,CAAf,CAAkBA,CAAlB,CAAwB,IAAKV,CAAAA,IAA7B,CAAmCU,CAAA,EAAnC,CACI,IAAK,IAAIC,IAAM,CAAf,CAAkBA,GAAlB,CAAwB,IAAKV,CAAAA,IAA7B,CAAmCU,GAAA,EAAnC,CAA0C,CAStC,IAAIC,MAAQ,CANR,IAAKjB,CAAAA,SAAL,CAAee,CAAf,CAAqB,CAArB,CAAJG,GAAgC,IAAKjB,CAAAA,SAAL,CAAee,GAAf,CAAqB,CAArB,CAAhCE,CAAgE,IAAK9I,CAAAA,IAAL,CAAU2I,CAAV,CAAgB,CAAhB,CAAA,CAAmBC,GAAnB,CAAyB,CAAzB,CAAhEE,CAA8F,IAAKhB,CAAAA,WAAnGgB,CAA2H,IAAK9I,CAAAA,IAAL,CAAU2I,CAAV,CAAgB,CAAhB,CAAA,CAAmBC,GAAnB,CAAyB,CAAzB,CAA3HE;AAAyJ,IAAKf,CAAAA,gBAMlJ,CAJH,IAAK/H,CAAAA,IAAL,CAAU2I,CAAV,CAAgB,CAAhB,CAAA,CAAmBC,GAAnB,CAIG,CAJuB,IAAKZ,CAAAA,WAI5B,CAHD,IAAKhI,CAAAA,IAAL,CAAU2I,CAAV,CAAA,CAAeC,GAAf,CAAqB,CAArB,CAGC,CAHyB,IAAKZ,CAAAA,WAG9B,CAAZ,CACIe,QAAU,IAAKC,CAAAA,kBAAL,CAAwBH,KAAxB,CAGd,KAAK7I,CAAAA,IAAL,CAAU2I,CAAV,CAAA,CAAeC,GAAf,CAAA,CAAsBC,KAAA,CAAME,OAAA,CAAQ,CAAR,CAAN,CACtB,KAAKZ,CAAAA,aAAL,CAAmBQ,CAAnB,CAAA,CAAwBC,GAAxB,CAAA,CAA+B,CAACG,OAAQE,CAAAA,QAAR,CAAiB,CAAjB,CAAD,CAAsBF,OAAQE,CAAAA,QAAR,CAAiB,CAAjB,CAAtB,CAA2CF,OAAQE,CAAAA,QAAR,CAAiB,CAAjB,CAA3C,CAdO,CAmB9C,IAAKV,CAAAA,KAAL,CAAa,IAAKvI,CAAAA,IAAL,CAAU,IAAKiI,CAAAA,IAAf,CAAsB,CAAtB,CAAA,CAAyB,IAAKC,CAAAA,IAA9B,CAAqC,CAArC,CAlCc,CAFhC,CAb2B,CAsD3B,CACCxY,IAAK,oBADN,CAECjf,MAAOy4B,QAA2B,EAAG,CACjC,IAAIC,oBAAsB,EAO1B,KALAA,mBAAoBluB,CAAAA,IAApB,CAAyB,CAAEmuB,IAAK,CAAC,IAAKxB,CAAAA,SAAUtzB,CAAAA,MAAhB,CAAwB,IAAKuzB,CAAAA,SAAUvzB,CAAAA,MAAvC,CAAP,CACrB+0B,KAAM,EADe,CAErBC,KAAM,EAFe,CAAzB,CAKA,CAAOH,mBAAA,CAAoB,CAApB,CAAP,CAAA,CAA+B,CAC3B,IAAI9X;AAAU8X,mBAAA,CAAoB,CAApB,CAAd,CACI5f,WAAa,IAAK4e,CAAAA,aAAL,CAAmB9W,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAnB,CAAA,CAAmC/X,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAnC,CAEb7f,WAAA,CAAW,CAAX,CAAJ,EACI4f,mBAAoBluB,CAAAA,IAApB,CAAyB,CAAEmuB,IAAK,CAAC/X,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAD,CAAkB,CAAlB,CAAqB/X,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAArB,CAAsC,CAAtC,CAAP,CACrBC,KAAM,IAAKzB,CAAAA,SAAL,CAAevW,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAf,CAAgC,CAAhC,CAANC,CAA2ChY,OAAQgY,CAAAA,IAD9B,CAErBC,KAAM,IAAKzB,CAAAA,SAAL,CAAexW,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAf,CAAgC,CAAhC,CAANE,CAA2CjY,OAAQiY,CAAAA,IAF9B,CAAzB,CAKA/f,WAAA,CAAW,CAAX,CAAJ,EACI4f,mBAAoBluB,CAAAA,IAApB,CAAyB,CAAEmuB,IAAK,CAAC/X,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAD,CAAkB,CAAlB,CAAqB/X,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAArB,CAAP,CACrBC,KAAM,IAAKzB,CAAAA,SAAL,CAAevW,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAf,CAAgC,CAAhC,CAANC,CAA2ChY,OAAQgY,CAAAA,IAD9B,CAErBC,KAAM,GAANA,CAAYjY,OAAQiY,CAAAA,IAFC,CAAzB,CAKA/f,WAAA,CAAW,CAAX,CAAJ,EACI4f,mBAAoBluB,CAAAA,IAApB,CAAyB,CAAEmuB,IAAK,CAAC/X,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAD,CAAiB/X,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAjB,CAAkC,CAAlC,CAAP;AACrBC,KAAM,GAANA,CAAYhY,OAAQgY,CAAAA,IADC,CAErBC,KAAM,IAAKzB,CAAAA,SAAL,CAAexW,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAf,CAAgC,CAAhC,CAANE,CAA2CjY,OAAQiY,CAAAA,IAF9B,CAAzB,CAMmB,EAAvB,GAAIjY,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAAJ,EAA+C,CAA/C,GAA4B/X,OAAQ+X,CAAAA,GAAR,CAAY,CAAZ,CAA5B,EAAkD,IAAKd,CAAAA,UAAWrtB,CAAAA,IAAhB,CAAqB,CAAE2sB,UAAWvW,OAAQgY,CAAAA,IAArB,CACnExB,UAAWxW,OAAQiY,CAAAA,IADgD,CAArB,CAIlDH,oBAAoB9lB,CAAAA,KAApB,EA3B2B,CA8B/B,MAAO,KAAKilB,CAAAA,UAtCqB,CAFtC,CAtD2B,CAmG3B,CACC5Y,IAAK,eADN,CAECjf,MAAO84B,QAAsB,CAAC5U,GAAD,CAAMhE,GAAN,CAAW,CAGpC,IAHoC,IAChC6Y,QAAU,EADsB,CAEhCr5B,EAAI,EACR,CAAyC,EAAzC,IAAQA,CAAR,CAAYwkB,GAAIvT,CAAAA,OAAJ,CAAYuP,GAAZ,CAAiBxgB,CAAjB,CAAqB,CAArB,CAAZ,EAAA,CACIq5B,OAAQvuB,CAAAA,IAAR,CAAa9K,CAAb,CAEJ,OAAOq5B,QAN6B,CAFzC,CAnG2B,CA6G3B,CACC9Z,IAAK,oBADN,CAECjf,MAAOu4B,QAA2B,CAACS,KAAD,CAAQ,CACtC,MAAO,KAAKF,CAAAA,aAAL,CAAmBE,KAAnB,CAA0BnzB,IAAKoT,CAAAA,GAAIggB,CAAAA,KAAT,CAAe,IAAf,CAAqBD,KAArB,CAA1B,CAD+B,CAF3C,CA7G2B,CAA9B,CAoHA,OAAO9B,gBApKuB,CAAZ,EAuKtBn4B;MAAOC,CAAAA,OAAP,CAAiBk4B,OA1LqC,CA/4H5C,CA6kIH,QAAQ,CAACn4B,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKlD25B,OAAAA,CAAaA,QAAmB,EAAG,EAIvCA,QAAW/K,CAAAA,QAAX,CAAsB5uB,mBAAA,CAAoB,EAApB,CACtB25B,QAAWhiB,CAAAA,iBAAX,CAA+B3X,mBAAA,CAAoB,CAApB,CAC/B25B,QAAW7E,CAAAA,YAAX,CAA0B90B,mBAAA,CAAoB,EAApB,CAC1B25B,QAAW5E,CAAAA,YAAX,CAA0B/0B,mBAAA,CAAoB,EAApB,CAC1B25B,QAAWtqB,CAAAA,UAAX,CAAwBrP,mBAAA,CAAoB,EAApB,CACxB25B,QAAWhE,CAAAA,OAAX,CAAqB31B,mBAAA,CAAoB,EAApB,CACrB25B,QAAWtD,CAAAA,OAAX,CAAqBr2B,mBAAA,CAAoB,EAApB,CACrB25B,QAAWj2B,CAAAA,SAAX,CAAuB1D,mBAAA,CAAoB,CAApB,CACvB25B,QAAWh2B,CAAAA,KAAX,CAAmB3D,mBAAA,CAAoB,CAApB,CACnB25B,QAAWtyB,CAAAA,OAAX,CAAqBrH,mBAAA,CAAoB,EAApB,CACrB25B;OAAWxpB,CAAAA,KAAX,CAAmBnQ,mBAAA,CAAoB,EAApB,CACnB25B,QAAW1xB,CAAAA,MAAX,CAAoBjI,mBAAA,CAAoB,CAApB,CACpB25B,QAAW3xB,CAAAA,UAAX,CAAwBhI,mBAAA,CAAoB,EAApB,CACxB25B,QAAWhyB,CAAAA,UAAX,CAAwB3H,mBAAA,CAAoB,EAApB,CACxB25B,QAAW/T,CAAAA,SAAX,CAAuB5lB,mBAAA,CAAoB,EAApB,CACvB25B,QAAWhW,CAAAA,iBAAX,CAA+B3jB,mBAAA,CAAoB,EAApB,CAC/B25B,QAAWzC,CAAAA,SAAX,CAAuBl3B,mBAAA,CAAoB,EAApB,CACvB25B,QAAWvpB,CAAAA,UAAX,CAAwBpQ,mBAAA,CAAoB,EAApB,CACxB25B,QAAWr2B,CAAAA,YAAX,CAA0BtD,mBAAA,CAAoB,CAApB,CAC1B25B,QAAWhqB,CAAAA,MAAX,CAAoB3P,mBAAA,CAAoB,CAApB,CACpB25B,QAAWz2B,CAAAA,KAAX,CAAmBlD,mBAAA,CAAoB,CAApB,CACnB25B,QAAW1pB,CAAAA,aAAX,CAA2BjQ,mBAAA,CAAoB,CAApB,CAC3B25B;OAAW7yB,CAAAA,KAAX,CAAmB9G,mBAAA,CAAoB,CAApB,CACnB25B,QAAWzpB,CAAAA,MAAX,CAAoBlQ,mBAAA,CAAoB,EAApB,CACpB25B,QAAW33B,CAAAA,eAAX,CAA6BhC,mBAAA,CAAoB,CAApB,CAC7B25B,QAAWhC,CAAAA,eAAX,CAA6B33B,mBAAA,CAAoB,EAApB,CAE7BR,OAAOC,CAAAA,OAAP,CAAiBk6B,OApCqC,CA7kI5C,CAqnIH,QAAQ,CAACn6B,MAAD,CAASC,OAAT,CAAkBO,mBAAlB,CAAuC,CAKtDglB,QAASA,QAAO,EAAG,CACjB,IAAK4U,CAAAA,SAAL,CAAiB,EADA,CAIf93B,OAAAA,CAAIkjB,OAAQpjB,CAAAA,SAEhBE,QAAE+3B,CAAAA,WAAF,CAAgBC,QAAS,CAACC,KAAD,CAAQC,QAAR,CAAkB,CACzC,IAAKJ,CAAAA,SAAU3uB,CAAAA,IAAf,CAAoB,CACX8uB,KADW,CAERC,QAFQ,CAApB,CADyC,CAO3Cl4B,QAAEm4B,CAAAA,cAAF,CAAmBC,QAAS,CAACH,KAAD,CAAQC,QAAR,CAAkB,CAC5C,IAAK,IAAI75B,EAAI,IAAKy5B,CAAAA,SAAUt1B,CAAAA,MAA5B,CAAyC,CAAzC,EAAoCnE,CAApC,CAA4CA,CAAA,EAA5C,CAAiD,CAC/C,IAAIC,EAAI,IAAKw5B,CAAAA,SAAL,CAAez5B,CAAf,CAEJC;CAAE25B,CAAAA,KAAN,GAAgBA,KAAhB,EAAyB35B,CAAE45B,CAAAA,QAA3B,GAAwCA,QAAxC,EACE,IAAKJ,CAAAA,SAAUjoB,CAAAA,MAAf,CAAsBxR,CAAtB,CAAyB,CAAzB,CAJ6C,CADL,CAU9C2B,QAAEq4B,CAAAA,IAAF,CAASC,QAAS,CAACL,KAAD,CAAQM,IAAR,CAAc,CAC9B,IAAK,IAAIl6B,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAKy5B,CAAAA,SAAUt1B,CAAAA,MAAnC,CAA2CnE,CAAA,EAA3C,CAAgD,CAC9C,IAAIC,EAAI,IAAKw5B,CAAAA,SAAL,CAAez5B,CAAf,CAEJ45B,MAAJ,GAAc35B,CAAE25B,CAAAA,KAAhB,EACE35B,CAAE45B,CAAAA,QAAF,CAAWK,IAAX,CAJ4C,CADlB,CAUhC76B,OAAOC,CAAAA,OAAP,CAAiBulB,OAtCqC,CArnI5C,CApEM,CADI,CATpB,CADwG;\",\n\"sources\":[\"node_modules/layout-base/layout-base.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$layout_base$layout_base\\\"] = function(global,require,module,exports) {\\n(function webpackUniversalModuleDefinition(root, factory) {\\n\\tif(typeof exports === 'object' && typeof module === 'object')\\n\\t\\tmodule.exports = factory();\\n\\telse if(typeof define === 'function' && define.amd)\\n\\t\\tdefine([], factory);\\n\\telse if(typeof exports === 'object')\\n\\t\\texports[\\\"layoutBase\\\"] = factory();\\n\\telse\\n\\t\\troot[\\\"layoutBase\\\"] = factory();\\n})(this, function() {\\nreturn /******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// identity function for calling harmony imports with the correct context\\n/******/ \\t__webpack_require__.i = function(value) { return value; };\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, {\\n/******/ \\t\\t\\t\\tconfigurable: false,\\n/******/ \\t\\t\\t\\tenumerable: true,\\n/******/ \\t\\t\\t\\tget: getter\\n/******/ \\t\\t\\t});\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = 26);\\n/******/ })\\n/************************************************************************/\\n/******/ ([\\n/* 0 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction LayoutConstants() {}\\n\\n/**\\r\\n * Layout Quality: 0:draft, 1:default, 2:proof\\r\\n */\\nLayoutConstants.QUALITY = 1;\\n\\n/**\\r\\n * Default parameters\\r\\n */\\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\\nLayoutConstants.DEFAULT_INCREMENTAL = false;\\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\\n\\n// -----------------------------------------------------------------------------\\n// Section: General other constants\\n// -----------------------------------------------------------------------------\\n/*\\r\\n * Margins of a graph to be applied on bouding rectangle of its contents. We\\r\\n * assume margins on all four sides to be uniform.\\r\\n */\\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\\n\\n/*\\r\\n * Whether to consider labels in node dimensions or not\\r\\n */\\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\\n\\n/*\\r\\n * Default dimension of a non-compound node.\\r\\n */\\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\\n\\n/*\\r\\n * Default dimension of a non-compound node.\\r\\n */\\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\\n\\n/*\\r\\n * Empty compound node size. When a compound node is empty, its both\\r\\n * dimensions should be of this value.\\r\\n */\\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\\n\\n/*\\r\\n * Minimum length that an edge should take during layout\\r\\n */\\nLayoutConstants.MIN_EDGE_LENGTH = 1;\\n\\n/*\\r\\n * World boundaries that layout operates on\\r\\n */\\nLayoutConstants.WORLD_BOUNDARY = 1000000;\\n\\n/*\\r\\n * World boundaries that random positioning can be performed with\\r\\n */\\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\\n\\n/*\\r\\n * Coordinates of the world center\\r\\n */\\nLayoutConstants.WORLD_CENTER_X = 1200;\\nLayoutConstants.WORLD_CENTER_Y = 900;\\n\\nmodule.exports = LayoutConstants;\\n\\n/***/ }),\\n/* 1 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar LGraphObject = __webpack_require__(2);\\nvar IGeometry = __webpack_require__(8);\\nvar IMath = __webpack_require__(9);\\n\\nfunction LEdge(source, target, vEdge) {\\n  LGraphObject.call(this, vEdge);\\n\\n  this.isOverlapingSourceAndTarget = false;\\n  this.vGraphObject = vEdge;\\n  this.bendpoints = [];\\n  this.source = source;\\n  this.target = target;\\n}\\n\\nLEdge.prototype = Object.create(LGraphObject.prototype);\\n\\nfor (var prop in LGraphObject) {\\n  LEdge[prop] = LGraphObject[prop];\\n}\\n\\nLEdge.prototype.getSource = function () {\\n  return this.source;\\n};\\n\\nLEdge.prototype.getTarget = function () {\\n  return this.target;\\n};\\n\\nLEdge.prototype.isInterGraph = function () {\\n  return this.isInterGraph;\\n};\\n\\nLEdge.prototype.getLength = function () {\\n  return this.length;\\n};\\n\\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\\n  return this.isOverlapingSourceAndTarget;\\n};\\n\\nLEdge.prototype.getBendpoints = function () {\\n  return this.bendpoints;\\n};\\n\\nLEdge.prototype.getLca = function () {\\n  return this.lca;\\n};\\n\\nLEdge.prototype.getSourceInLca = function () {\\n  return this.sourceInLca;\\n};\\n\\nLEdge.prototype.getTargetInLca = function () {\\n  return this.targetInLca;\\n};\\n\\nLEdge.prototype.getOtherEnd = function (node) {\\n  if (this.source === node) {\\n    return this.target;\\n  } else if (this.target === node) {\\n    return this.source;\\n  } else {\\n    throw \\\"Node is not incident with this edge\\\";\\n  }\\n};\\n\\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\\n  var otherEnd = this.getOtherEnd(node);\\n  var root = graph.getGraphManager().getRoot();\\n\\n  while (true) {\\n    if (otherEnd.getOwner() == graph) {\\n      return otherEnd;\\n    }\\n\\n    if (otherEnd.getOwner() == root) {\\n      break;\\n    }\\n\\n    otherEnd = otherEnd.getOwner().getParent();\\n  }\\n\\n  return null;\\n};\\n\\nLEdge.prototype.updateLength = function () {\\n  var clipPointCoordinates = new Array(4);\\n\\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\\n\\n  if (!this.isOverlapingSourceAndTarget) {\\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\\n\\n    if (Math.abs(this.lengthX) < 1.0) {\\n      this.lengthX = IMath.sign(this.lengthX);\\n    }\\n\\n    if (Math.abs(this.lengthY) < 1.0) {\\n      this.lengthY = IMath.sign(this.lengthY);\\n    }\\n\\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\\n  }\\n};\\n\\nLEdge.prototype.updateLengthSimple = function () {\\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\\n\\n  if (Math.abs(this.lengthX) < 1.0) {\\n    this.lengthX = IMath.sign(this.lengthX);\\n  }\\n\\n  if (Math.abs(this.lengthY) < 1.0) {\\n    this.lengthY = IMath.sign(this.lengthY);\\n  }\\n\\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\\n};\\n\\nmodule.exports = LEdge;\\n\\n/***/ }),\\n/* 2 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction LGraphObject(vGraphObject) {\\n  this.vGraphObject = vGraphObject;\\n}\\n\\nmodule.exports = LGraphObject;\\n\\n/***/ }),\\n/* 3 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar LGraphObject = __webpack_require__(2);\\nvar Integer = __webpack_require__(10);\\nvar RectangleD = __webpack_require__(13);\\nvar LayoutConstants = __webpack_require__(0);\\nvar RandomSeed = __webpack_require__(16);\\nvar PointD = __webpack_require__(4);\\n\\nfunction LNode(gm, loc, size, vNode) {\\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\\n  if (size == null && vNode == null) {\\n    vNode = loc;\\n  }\\n\\n  LGraphObject.call(this, vNode);\\n\\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\\n  if (gm.graphManager != null) gm = gm.graphManager;\\n\\n  this.estimatedSize = Integer.MIN_VALUE;\\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\\n  this.vGraphObject = vNode;\\n  this.edges = [];\\n  this.graphManager = gm;\\n\\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\\n}\\n\\nLNode.prototype = Object.create(LGraphObject.prototype);\\nfor (var prop in LGraphObject) {\\n  LNode[prop] = LGraphObject[prop];\\n}\\n\\nLNode.prototype.getEdges = function () {\\n  return this.edges;\\n};\\n\\nLNode.prototype.getChild = function () {\\n  return this.child;\\n};\\n\\nLNode.prototype.getOwner = function () {\\n  //  if (this.owner != null) {\\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\\n  //      throw \\\"assert failed\\\";\\n  //    }\\n  //  }\\n\\n  return this.owner;\\n};\\n\\nLNode.prototype.getWidth = function () {\\n  return this.rect.width;\\n};\\n\\nLNode.prototype.setWidth = function (width) {\\n  this.rect.width = width;\\n};\\n\\nLNode.prototype.getHeight = function () {\\n  return this.rect.height;\\n};\\n\\nLNode.prototype.setHeight = function (height) {\\n  this.rect.height = height;\\n};\\n\\nLNode.prototype.getCenterX = function () {\\n  return this.rect.x + this.rect.width / 2;\\n};\\n\\nLNode.prototype.getCenterY = function () {\\n  return this.rect.y + this.rect.height / 2;\\n};\\n\\nLNode.prototype.getCenter = function () {\\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\\n};\\n\\nLNode.prototype.getLocation = function () {\\n  return new PointD(this.rect.x, this.rect.y);\\n};\\n\\nLNode.prototype.getRect = function () {\\n  return this.rect;\\n};\\n\\nLNode.prototype.getDiagonal = function () {\\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\\n};\\n\\n/**\\n * This method returns half the diagonal length of this node.\\n */\\nLNode.prototype.getHalfTheDiagonal = function () {\\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\\n};\\n\\nLNode.prototype.setRect = function (upperLeft, dimension) {\\n  this.rect.x = upperLeft.x;\\n  this.rect.y = upperLeft.y;\\n  this.rect.width = dimension.width;\\n  this.rect.height = dimension.height;\\n};\\n\\nLNode.prototype.setCenter = function (cx, cy) {\\n  this.rect.x = cx - this.rect.width / 2;\\n  this.rect.y = cy - this.rect.height / 2;\\n};\\n\\nLNode.prototype.setLocation = function (x, y) {\\n  this.rect.x = x;\\n  this.rect.y = y;\\n};\\n\\nLNode.prototype.moveBy = function (dx, dy) {\\n  this.rect.x += dx;\\n  this.rect.y += dy;\\n};\\n\\nLNode.prototype.getEdgeListToNode = function (to) {\\n  var edgeList = [];\\n  var edge;\\n  var self = this;\\n\\n  self.edges.forEach(function (edge) {\\n\\n    if (edge.target == to) {\\n      if (edge.source != self) throw \\\"Incorrect edge source!\\\";\\n\\n      edgeList.push(edge);\\n    }\\n  });\\n\\n  return edgeList;\\n};\\n\\nLNode.prototype.getEdgesBetween = function (other) {\\n  var edgeList = [];\\n  var edge;\\n\\n  var self = this;\\n  self.edges.forEach(function (edge) {\\n\\n    if (!(edge.source == self || edge.target == self)) throw \\\"Incorrect edge source and/or target\\\";\\n\\n    if (edge.target == other || edge.source == other) {\\n      edgeList.push(edge);\\n    }\\n  });\\n\\n  return edgeList;\\n};\\n\\nLNode.prototype.getNeighborsList = function () {\\n  var neighbors = new Set();\\n\\n  var self = this;\\n  self.edges.forEach(function (edge) {\\n\\n    if (edge.source == self) {\\n      neighbors.add(edge.target);\\n    } else {\\n      if (edge.target != self) {\\n        throw \\\"Incorrect incidency!\\\";\\n      }\\n\\n      neighbors.add(edge.source);\\n    }\\n  });\\n\\n  return neighbors;\\n};\\n\\nLNode.prototype.withChildren = function () {\\n  var withNeighborsList = new Set();\\n  var childNode;\\n  var children;\\n\\n  withNeighborsList.add(this);\\n\\n  if (this.child != null) {\\n    var nodes = this.child.getNodes();\\n    for (var i = 0; i < nodes.length; i++) {\\n      childNode = nodes[i];\\n      children = childNode.withChildren();\\n      children.forEach(function (node) {\\n        withNeighborsList.add(node);\\n      });\\n    }\\n  }\\n\\n  return withNeighborsList;\\n};\\n\\nLNode.prototype.getNoOfChildren = function () {\\n  var noOfChildren = 0;\\n  var childNode;\\n\\n  if (this.child == null) {\\n    noOfChildren = 1;\\n  } else {\\n    var nodes = this.child.getNodes();\\n    for (var i = 0; i < nodes.length; i++) {\\n      childNode = nodes[i];\\n\\n      noOfChildren += childNode.getNoOfChildren();\\n    }\\n  }\\n\\n  if (noOfChildren == 0) {\\n    noOfChildren = 1;\\n  }\\n  return noOfChildren;\\n};\\n\\nLNode.prototype.getEstimatedSize = function () {\\n  if (this.estimatedSize == Integer.MIN_VALUE) {\\n    throw \\\"assert failed\\\";\\n  }\\n  return this.estimatedSize;\\n};\\n\\nLNode.prototype.calcEstimatedSize = function () {\\n  if (this.child == null) {\\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\\n  } else {\\n    this.estimatedSize = this.child.calcEstimatedSize();\\n    this.rect.width = this.estimatedSize;\\n    this.rect.height = this.estimatedSize;\\n\\n    return this.estimatedSize;\\n  }\\n};\\n\\nLNode.prototype.scatter = function () {\\n  var randomCenterX;\\n  var randomCenterY;\\n\\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\\n\\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\\n\\n  this.rect.x = randomCenterX;\\n  this.rect.y = randomCenterY;\\n};\\n\\nLNode.prototype.updateBounds = function () {\\n  if (this.getChild() == null) {\\n    throw \\\"assert failed\\\";\\n  }\\n  if (this.getChild().getNodes().length != 0) {\\n    // wrap the children nodes by re-arranging the boundaries\\n    var childGraph = this.getChild();\\n    childGraph.updateBounds(true);\\n\\n    this.rect.x = childGraph.getLeft();\\n    this.rect.y = childGraph.getTop();\\n\\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\\n\\n    // Update compound bounds considering its label properties    \\n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\\n\\n      var width = childGraph.getRight() - childGraph.getLeft();\\n      var height = childGraph.getBottom() - childGraph.getTop();\\n\\n      if (this.labelWidth > width) {\\n        this.rect.x -= (this.labelWidth - width) / 2;\\n        this.setWidth(this.labelWidth);\\n      }\\n\\n      if (this.labelHeight > height) {\\n        if (this.labelPos == \\\"center\\\") {\\n          this.rect.y -= (this.labelHeight - height) / 2;\\n        } else if (this.labelPos == \\\"top\\\") {\\n          this.rect.y -= this.labelHeight - height;\\n        }\\n        this.setHeight(this.labelHeight);\\n      }\\n    }\\n  }\\n};\\n\\nLNode.prototype.getInclusionTreeDepth = function () {\\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\\n    throw \\\"assert failed\\\";\\n  }\\n  return this.inclusionTreeDepth;\\n};\\n\\nLNode.prototype.transform = function (trans) {\\n  var left = this.rect.x;\\n\\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\\n    left = LayoutConstants.WORLD_BOUNDARY;\\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\\n    left = -LayoutConstants.WORLD_BOUNDARY;\\n  }\\n\\n  var top = this.rect.y;\\n\\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\\n    top = LayoutConstants.WORLD_BOUNDARY;\\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\\n    top = -LayoutConstants.WORLD_BOUNDARY;\\n  }\\n\\n  var leftTop = new PointD(left, top);\\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\\n\\n  this.setLocation(vLeftTop.x, vLeftTop.y);\\n};\\n\\nLNode.prototype.getLeft = function () {\\n  return this.rect.x;\\n};\\n\\nLNode.prototype.getRight = function () {\\n  return this.rect.x + this.rect.width;\\n};\\n\\nLNode.prototype.getTop = function () {\\n  return this.rect.y;\\n};\\n\\nLNode.prototype.getBottom = function () {\\n  return this.rect.y + this.rect.height;\\n};\\n\\nLNode.prototype.getParent = function () {\\n  if (this.owner == null) {\\n    return null;\\n  }\\n\\n  return this.owner.getParent();\\n};\\n\\nmodule.exports = LNode;\\n\\n/***/ }),\\n/* 4 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction PointD(x, y) {\\n  if (x == null && y == null) {\\n    this.x = 0;\\n    this.y = 0;\\n  } else {\\n    this.x = x;\\n    this.y = y;\\n  }\\n}\\n\\nPointD.prototype.getX = function () {\\n  return this.x;\\n};\\n\\nPointD.prototype.getY = function () {\\n  return this.y;\\n};\\n\\nPointD.prototype.setX = function (x) {\\n  this.x = x;\\n};\\n\\nPointD.prototype.setY = function (y) {\\n  this.y = y;\\n};\\n\\nPointD.prototype.getDifference = function (pt) {\\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\\n};\\n\\nPointD.prototype.getCopy = function () {\\n  return new PointD(this.x, this.y);\\n};\\n\\nPointD.prototype.translate = function (dim) {\\n  this.x += dim.width;\\n  this.y += dim.height;\\n  return this;\\n};\\n\\nmodule.exports = PointD;\\n\\n/***/ }),\\n/* 5 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar LGraphObject = __webpack_require__(2);\\nvar Integer = __webpack_require__(10);\\nvar LayoutConstants = __webpack_require__(0);\\nvar LGraphManager = __webpack_require__(6);\\nvar LNode = __webpack_require__(3);\\nvar LEdge = __webpack_require__(1);\\nvar RectangleD = __webpack_require__(13);\\nvar Point = __webpack_require__(12);\\nvar LinkedList = __webpack_require__(11);\\n\\nfunction LGraph(parent, obj2, vGraph) {\\n  LGraphObject.call(this, vGraph);\\n  this.estimatedSize = Integer.MIN_VALUE;\\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\\n  this.edges = [];\\n  this.nodes = [];\\n  this.isConnected = false;\\n  this.parent = parent;\\n\\n  if (obj2 != null && obj2 instanceof LGraphManager) {\\n    this.graphManager = obj2;\\n  } else if (obj2 != null && obj2 instanceof Layout) {\\n    this.graphManager = obj2.graphManager;\\n  }\\n}\\n\\nLGraph.prototype = Object.create(LGraphObject.prototype);\\nfor (var prop in LGraphObject) {\\n  LGraph[prop] = LGraphObject[prop];\\n}\\n\\nLGraph.prototype.getNodes = function () {\\n  return this.nodes;\\n};\\n\\nLGraph.prototype.getEdges = function () {\\n  return this.edges;\\n};\\n\\nLGraph.prototype.getGraphManager = function () {\\n  return this.graphManager;\\n};\\n\\nLGraph.prototype.getParent = function () {\\n  return this.parent;\\n};\\n\\nLGraph.prototype.getLeft = function () {\\n  return this.left;\\n};\\n\\nLGraph.prototype.getRight = function () {\\n  return this.right;\\n};\\n\\nLGraph.prototype.getTop = function () {\\n  return this.top;\\n};\\n\\nLGraph.prototype.getBottom = function () {\\n  return this.bottom;\\n};\\n\\nLGraph.prototype.isConnected = function () {\\n  return this.isConnected;\\n};\\n\\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\\n  if (sourceNode == null && targetNode == null) {\\n    var newNode = obj1;\\n    if (this.graphManager == null) {\\n      throw \\\"Graph has no graph mgr!\\\";\\n    }\\n    if (this.getNodes().indexOf(newNode) > -1) {\\n      throw \\\"Node already in graph!\\\";\\n    }\\n    newNode.owner = this;\\n    this.getNodes().push(newNode);\\n\\n    return newNode;\\n  } else {\\n    var newEdge = obj1;\\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\\n      throw \\\"Source or target not in graph!\\\";\\n    }\\n\\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\\n      throw \\\"Both owners must be this graph!\\\";\\n    }\\n\\n    if (sourceNode.owner != targetNode.owner) {\\n      return null;\\n    }\\n\\n    // set source and target\\n    newEdge.source = sourceNode;\\n    newEdge.target = targetNode;\\n\\n    // set as intra-graph edge\\n    newEdge.isInterGraph = false;\\n\\n    // add to graph edge list\\n    this.getEdges().push(newEdge);\\n\\n    // add to incidency lists\\n    sourceNode.edges.push(newEdge);\\n\\n    if (targetNode != sourceNode) {\\n      targetNode.edges.push(newEdge);\\n    }\\n\\n    return newEdge;\\n  }\\n};\\n\\nLGraph.prototype.remove = function (obj) {\\n  var node = obj;\\n  if (obj instanceof LNode) {\\n    if (node == null) {\\n      throw \\\"Node is null!\\\";\\n    }\\n    if (!(node.owner != null && node.owner == this)) {\\n      throw \\\"Owner graph is invalid!\\\";\\n    }\\n    if (this.graphManager == null) {\\n      throw \\\"Owner graph manager is invalid!\\\";\\n    }\\n    // remove incident edges first (make a copy to do it safely)\\n    var edgesToBeRemoved = node.edges.slice();\\n    var edge;\\n    var s = edgesToBeRemoved.length;\\n    for (var i = 0; i < s; i++) {\\n      edge = edgesToBeRemoved[i];\\n\\n      if (edge.isInterGraph) {\\n        this.graphManager.remove(edge);\\n      } else {\\n        edge.source.owner.remove(edge);\\n      }\\n    }\\n\\n    // now the node itself\\n    var index = this.nodes.indexOf(node);\\n    if (index == -1) {\\n      throw \\\"Node not in owner node list!\\\";\\n    }\\n\\n    this.nodes.splice(index, 1);\\n  } else if (obj instanceof LEdge) {\\n    var edge = obj;\\n    if (edge == null) {\\n      throw \\\"Edge is null!\\\";\\n    }\\n    if (!(edge.source != null && edge.target != null)) {\\n      throw \\\"Source and/or target is null!\\\";\\n    }\\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\\n      throw \\\"Source and/or target owner is invalid!\\\";\\n    }\\n\\n    var sourceIndex = edge.source.edges.indexOf(edge);\\n    var targetIndex = edge.target.edges.indexOf(edge);\\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\\n      throw \\\"Source and/or target doesn't know this edge!\\\";\\n    }\\n\\n    edge.source.edges.splice(sourceIndex, 1);\\n\\n    if (edge.target != edge.source) {\\n      edge.target.edges.splice(targetIndex, 1);\\n    }\\n\\n    var index = edge.source.owner.getEdges().indexOf(edge);\\n    if (index == -1) {\\n      throw \\\"Not in owner's edge list!\\\";\\n    }\\n\\n    edge.source.owner.getEdges().splice(index, 1);\\n  }\\n};\\n\\nLGraph.prototype.updateLeftTop = function () {\\n  var top = Integer.MAX_VALUE;\\n  var left = Integer.MAX_VALUE;\\n  var nodeTop;\\n  var nodeLeft;\\n  var margin;\\n\\n  var nodes = this.getNodes();\\n  var s = nodes.length;\\n\\n  for (var i = 0; i < s; i++) {\\n    var lNode = nodes[i];\\n    nodeTop = lNode.getTop();\\n    nodeLeft = lNode.getLeft();\\n\\n    if (top > nodeTop) {\\n      top = nodeTop;\\n    }\\n\\n    if (left > nodeLeft) {\\n      left = nodeLeft;\\n    }\\n  }\\n\\n  // Do we have any nodes in this graph?\\n  if (top == Integer.MAX_VALUE) {\\n    return null;\\n  }\\n\\n  if (nodes[0].getParent().paddingLeft != undefined) {\\n    margin = nodes[0].getParent().paddingLeft;\\n  } else {\\n    margin = this.margin;\\n  }\\n\\n  this.left = left - margin;\\n  this.top = top - margin;\\n\\n  // Apply the margins and return the result\\n  return new Point(this.left, this.top);\\n};\\n\\nLGraph.prototype.updateBounds = function (recursive) {\\n  // calculate bounds\\n  var left = Integer.MAX_VALUE;\\n  var right = -Integer.MAX_VALUE;\\n  var top = Integer.MAX_VALUE;\\n  var bottom = -Integer.MAX_VALUE;\\n  var nodeLeft;\\n  var nodeRight;\\n  var nodeTop;\\n  var nodeBottom;\\n  var margin;\\n\\n  var nodes = this.nodes;\\n  var s = nodes.length;\\n  for (var i = 0; i < s; i++) {\\n    var lNode = nodes[i];\\n\\n    if (recursive && lNode.child != null) {\\n      lNode.updateBounds();\\n    }\\n    nodeLeft = lNode.getLeft();\\n    nodeRight = lNode.getRight();\\n    nodeTop = lNode.getTop();\\n    nodeBottom = lNode.getBottom();\\n\\n    if (left > nodeLeft) {\\n      left = nodeLeft;\\n    }\\n\\n    if (right < nodeRight) {\\n      right = nodeRight;\\n    }\\n\\n    if (top > nodeTop) {\\n      top = nodeTop;\\n    }\\n\\n    if (bottom < nodeBottom) {\\n      bottom = nodeBottom;\\n    }\\n  }\\n\\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\\n  if (left == Integer.MAX_VALUE) {\\n    this.left = this.parent.getLeft();\\n    this.right = this.parent.getRight();\\n    this.top = this.parent.getTop();\\n    this.bottom = this.parent.getBottom();\\n  }\\n\\n  if (nodes[0].getParent().paddingLeft != undefined) {\\n    margin = nodes[0].getParent().paddingLeft;\\n  } else {\\n    margin = this.margin;\\n  }\\n\\n  this.left = boundingRect.x - margin;\\n  this.right = boundingRect.x + boundingRect.width + margin;\\n  this.top = boundingRect.y - margin;\\n  this.bottom = boundingRect.y + boundingRect.height + margin;\\n};\\n\\nLGraph.calculateBounds = function (nodes) {\\n  var left = Integer.MAX_VALUE;\\n  var right = -Integer.MAX_VALUE;\\n  var top = Integer.MAX_VALUE;\\n  var bottom = -Integer.MAX_VALUE;\\n  var nodeLeft;\\n  var nodeRight;\\n  var nodeTop;\\n  var nodeBottom;\\n\\n  var s = nodes.length;\\n\\n  for (var i = 0; i < s; i++) {\\n    var lNode = nodes[i];\\n    nodeLeft = lNode.getLeft();\\n    nodeRight = lNode.getRight();\\n    nodeTop = lNode.getTop();\\n    nodeBottom = lNode.getBottom();\\n\\n    if (left > nodeLeft) {\\n      left = nodeLeft;\\n    }\\n\\n    if (right < nodeRight) {\\n      right = nodeRight;\\n    }\\n\\n    if (top > nodeTop) {\\n      top = nodeTop;\\n    }\\n\\n    if (bottom < nodeBottom) {\\n      bottom = nodeBottom;\\n    }\\n  }\\n\\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\\n\\n  return boundingRect;\\n};\\n\\nLGraph.prototype.getInclusionTreeDepth = function () {\\n  if (this == this.graphManager.getRoot()) {\\n    return 1;\\n  } else {\\n    return this.parent.getInclusionTreeDepth();\\n  }\\n};\\n\\nLGraph.prototype.getEstimatedSize = function () {\\n  if (this.estimatedSize == Integer.MIN_VALUE) {\\n    throw \\\"assert failed\\\";\\n  }\\n  return this.estimatedSize;\\n};\\n\\nLGraph.prototype.calcEstimatedSize = function () {\\n  var size = 0;\\n  var nodes = this.nodes;\\n  var s = nodes.length;\\n\\n  for (var i = 0; i < s; i++) {\\n    var lNode = nodes[i];\\n    size += lNode.calcEstimatedSize();\\n  }\\n\\n  if (size == 0) {\\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\\n  } else {\\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\\n  }\\n\\n  return this.estimatedSize;\\n};\\n\\nLGraph.prototype.updateConnected = function () {\\n  var self = this;\\n  if (this.nodes.length == 0) {\\n    this.isConnected = true;\\n    return;\\n  }\\n\\n  var queue = new LinkedList();\\n  var visited = new Set();\\n  var currentNode = this.nodes[0];\\n  var neighborEdges;\\n  var currentNeighbor;\\n  var childrenOfNode = currentNode.withChildren();\\n  childrenOfNode.forEach(function (node) {\\n    queue.push(node);\\n    visited.add(node);\\n  });\\n\\n  while (queue.length !== 0) {\\n    currentNode = queue.shift();\\n\\n    // Traverse all neighbors of this node\\n    neighborEdges = currentNode.getEdges();\\n    var size = neighborEdges.length;\\n    for (var i = 0; i < size; i++) {\\n      var neighborEdge = neighborEdges[i];\\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\\n\\n      // Add unvisited neighbors to the list to visit\\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\\n        var childrenOfNeighbor = currentNeighbor.withChildren();\\n\\n        childrenOfNeighbor.forEach(function (node) {\\n          queue.push(node);\\n          visited.add(node);\\n        });\\n      }\\n    }\\n  }\\n\\n  this.isConnected = false;\\n\\n  if (visited.size >= this.nodes.length) {\\n    var noOfVisitedInThisGraph = 0;\\n\\n    visited.forEach(function (visitedNode) {\\n      if (visitedNode.owner == self) {\\n        noOfVisitedInThisGraph++;\\n      }\\n    });\\n\\n    if (noOfVisitedInThisGraph == this.nodes.length) {\\n      this.isConnected = true;\\n    }\\n  }\\n};\\n\\nmodule.exports = LGraph;\\n\\n/***/ }),\\n/* 6 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar LGraph;\\nvar LEdge = __webpack_require__(1);\\n\\nfunction LGraphManager(layout) {\\n  LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\\n  this.layout = layout;\\n\\n  this.graphs = [];\\n  this.edges = [];\\n}\\n\\nLGraphManager.prototype.addRoot = function () {\\n  var ngraph = this.layout.newGraph();\\n  var nnode = this.layout.newNode(null);\\n  var root = this.add(ngraph, nnode);\\n  this.setRootGraph(root);\\n  return this.rootGraph;\\n};\\n\\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\\n  if (newEdge == null && sourceNode == null && targetNode == null) {\\n    if (newGraph == null) {\\n      throw \\\"Graph is null!\\\";\\n    }\\n    if (parentNode == null) {\\n      throw \\\"Parent node is null!\\\";\\n    }\\n    if (this.graphs.indexOf(newGraph) > -1) {\\n      throw \\\"Graph already in this graph mgr!\\\";\\n    }\\n\\n    this.graphs.push(newGraph);\\n\\n    if (newGraph.parent != null) {\\n      throw \\\"Already has a parent!\\\";\\n    }\\n    if (parentNode.child != null) {\\n      throw \\\"Already has a child!\\\";\\n    }\\n\\n    newGraph.parent = parentNode;\\n    parentNode.child = newGraph;\\n\\n    return newGraph;\\n  } else {\\n    //change the order of the parameters\\n    targetNode = newEdge;\\n    sourceNode = parentNode;\\n    newEdge = newGraph;\\n    var sourceGraph = sourceNode.getOwner();\\n    var targetGraph = targetNode.getOwner();\\n\\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\\n      throw \\\"Source not in this graph mgr!\\\";\\n    }\\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\\n      throw \\\"Target not in this graph mgr!\\\";\\n    }\\n\\n    if (sourceGraph == targetGraph) {\\n      newEdge.isInterGraph = false;\\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\\n    } else {\\n      newEdge.isInterGraph = true;\\n\\n      // set source and target\\n      newEdge.source = sourceNode;\\n      newEdge.target = targetNode;\\n\\n      // add edge to inter-graph edge list\\n      if (this.edges.indexOf(newEdge) > -1) {\\n        throw \\\"Edge already in inter-graph edge list!\\\";\\n      }\\n\\n      this.edges.push(newEdge);\\n\\n      // add edge to source and target incidency lists\\n      if (!(newEdge.source != null && newEdge.target != null)) {\\n        throw \\\"Edge source and/or target is null!\\\";\\n      }\\n\\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\\n        throw \\\"Edge already in source and/or target incidency list!\\\";\\n      }\\n\\n      newEdge.source.edges.push(newEdge);\\n      newEdge.target.edges.push(newEdge);\\n\\n      return newEdge;\\n    }\\n  }\\n};\\n\\nLGraphManager.prototype.remove = function (lObj) {\\n  if (lObj instanceof LGraph) {\\n    var graph = lObj;\\n    if (graph.getGraphManager() != this) {\\n      throw \\\"Graph not in this graph mgr\\\";\\n    }\\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\\n      throw \\\"Invalid parent node!\\\";\\n    }\\n\\n    // first the edges (make a copy to do it safely)\\n    var edgesToBeRemoved = [];\\n\\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\\n\\n    var edge;\\n    var s = edgesToBeRemoved.length;\\n    for (var i = 0; i < s; i++) {\\n      edge = edgesToBeRemoved[i];\\n      graph.remove(edge);\\n    }\\n\\n    // then the nodes (make a copy to do it safely)\\n    var nodesToBeRemoved = [];\\n\\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\\n\\n    var node;\\n    s = nodesToBeRemoved.length;\\n    for (var i = 0; i < s; i++) {\\n      node = nodesToBeRemoved[i];\\n      graph.remove(node);\\n    }\\n\\n    // check if graph is the root\\n    if (graph == this.rootGraph) {\\n      this.setRootGraph(null);\\n    }\\n\\n    // now remove the graph itself\\n    var index = this.graphs.indexOf(graph);\\n    this.graphs.splice(index, 1);\\n\\n    // also reset the parent of the graph\\n    graph.parent = null;\\n  } else if (lObj instanceof LEdge) {\\n    edge = lObj;\\n    if (edge == null) {\\n      throw \\\"Edge is null!\\\";\\n    }\\n    if (!edge.isInterGraph) {\\n      throw \\\"Not an inter-graph edge!\\\";\\n    }\\n    if (!(edge.source != null && edge.target != null)) {\\n      throw \\\"Source and/or target is null!\\\";\\n    }\\n\\n    // remove edge from source and target nodes' incidency lists\\n\\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\\n      throw \\\"Source and/or target doesn't know this edge!\\\";\\n    }\\n\\n    var index = edge.source.edges.indexOf(edge);\\n    edge.source.edges.splice(index, 1);\\n    index = edge.target.edges.indexOf(edge);\\n    edge.target.edges.splice(index, 1);\\n\\n    // remove edge from owner graph manager's inter-graph edge list\\n\\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\\n      throw \\\"Edge owner graph or owner graph manager is null!\\\";\\n    }\\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\\n      throw \\\"Not in owner graph manager's edge list!\\\";\\n    }\\n\\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\\n  }\\n};\\n\\nLGraphManager.prototype.updateBounds = function () {\\n  this.rootGraph.updateBounds(true);\\n};\\n\\nLGraphManager.prototype.getGraphs = function () {\\n  return this.graphs;\\n};\\n\\nLGraphManager.prototype.getAllNodes = function () {\\n  if (this.allNodes == null) {\\n    var nodeList = [];\\n    var graphs = this.getGraphs();\\n    var s = graphs.length;\\n    for (var i = 0; i < s; i++) {\\n      nodeList = nodeList.concat(graphs[i].getNodes());\\n    }\\n    this.allNodes = nodeList;\\n  }\\n  return this.allNodes;\\n};\\n\\nLGraphManager.prototype.resetAllNodes = function () {\\n  this.allNodes = null;\\n};\\n\\nLGraphManager.prototype.resetAllEdges = function () {\\n  this.allEdges = null;\\n};\\n\\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\\n  this.allNodesToApplyGravitation = null;\\n};\\n\\nLGraphManager.prototype.getAllEdges = function () {\\n  if (this.allEdges == null) {\\n    var edgeList = [];\\n    var graphs = this.getGraphs();\\n    var s = graphs.length;\\n    for (var i = 0; i < graphs.length; i++) {\\n      edgeList = edgeList.concat(graphs[i].getEdges());\\n    }\\n\\n    edgeList = edgeList.concat(this.edges);\\n\\n    this.allEdges = edgeList;\\n  }\\n  return this.allEdges;\\n};\\n\\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\\n  return this.allNodesToApplyGravitation;\\n};\\n\\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\\n  if (this.allNodesToApplyGravitation != null) {\\n    throw \\\"assert failed\\\";\\n  }\\n\\n  this.allNodesToApplyGravitation = nodeList;\\n};\\n\\nLGraphManager.prototype.getRoot = function () {\\n  return this.rootGraph;\\n};\\n\\nLGraphManager.prototype.setRootGraph = function (graph) {\\n  if (graph.getGraphManager() != this) {\\n    throw \\\"Root not in this graph mgr!\\\";\\n  }\\n\\n  this.rootGraph = graph;\\n  // root graph must have a root node associated with it for convenience\\n  if (graph.parent == null) {\\n    graph.parent = this.layout.newNode(\\\"Root node\\\");\\n  }\\n};\\n\\nLGraphManager.prototype.getLayout = function () {\\n  return this.layout;\\n};\\n\\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\\n  if (!(firstNode != null && secondNode != null)) {\\n    throw \\\"assert failed\\\";\\n  }\\n\\n  if (firstNode == secondNode) {\\n    return true;\\n  }\\n  // Is second node an ancestor of the first one?\\n  var ownerGraph = firstNode.getOwner();\\n  var parentNode;\\n\\n  do {\\n    parentNode = ownerGraph.getParent();\\n\\n    if (parentNode == null) {\\n      break;\\n    }\\n\\n    if (parentNode == secondNode) {\\n      return true;\\n    }\\n\\n    ownerGraph = parentNode.getOwner();\\n    if (ownerGraph == null) {\\n      break;\\n    }\\n  } while (true);\\n  // Is first node an ancestor of the second one?\\n  ownerGraph = secondNode.getOwner();\\n\\n  do {\\n    parentNode = ownerGraph.getParent();\\n\\n    if (parentNode == null) {\\n      break;\\n    }\\n\\n    if (parentNode == firstNode) {\\n      return true;\\n    }\\n\\n    ownerGraph = parentNode.getOwner();\\n    if (ownerGraph == null) {\\n      break;\\n    }\\n  } while (true);\\n\\n  return false;\\n};\\n\\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\\n  var edge;\\n  var sourceNode;\\n  var targetNode;\\n  var sourceAncestorGraph;\\n  var targetAncestorGraph;\\n\\n  var edges = this.getAllEdges();\\n  var s = edges.length;\\n  for (var i = 0; i < s; i++) {\\n    edge = edges[i];\\n\\n    sourceNode = edge.source;\\n    targetNode = edge.target;\\n    edge.lca = null;\\n    edge.sourceInLca = sourceNode;\\n    edge.targetInLca = targetNode;\\n\\n    if (sourceNode == targetNode) {\\n      edge.lca = sourceNode.getOwner();\\n      continue;\\n    }\\n\\n    sourceAncestorGraph = sourceNode.getOwner();\\n\\n    while (edge.lca == null) {\\n      edge.targetInLca = targetNode;\\n      targetAncestorGraph = targetNode.getOwner();\\n\\n      while (edge.lca == null) {\\n        if (targetAncestorGraph == sourceAncestorGraph) {\\n          edge.lca = targetAncestorGraph;\\n          break;\\n        }\\n\\n        if (targetAncestorGraph == this.rootGraph) {\\n          break;\\n        }\\n\\n        if (edge.lca != null) {\\n          throw \\\"assert failed\\\";\\n        }\\n        edge.targetInLca = targetAncestorGraph.getParent();\\n        targetAncestorGraph = edge.targetInLca.getOwner();\\n      }\\n\\n      if (sourceAncestorGraph == this.rootGraph) {\\n        break;\\n      }\\n\\n      if (edge.lca == null) {\\n        edge.sourceInLca = sourceAncestorGraph.getParent();\\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\\n      }\\n    }\\n\\n    if (edge.lca == null) {\\n      throw \\\"assert failed\\\";\\n    }\\n  }\\n};\\n\\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\\n  if (firstNode == secondNode) {\\n    return firstNode.getOwner();\\n  }\\n  var firstOwnerGraph = firstNode.getOwner();\\n\\n  do {\\n    if (firstOwnerGraph == null) {\\n      break;\\n    }\\n    var secondOwnerGraph = secondNode.getOwner();\\n\\n    do {\\n      if (secondOwnerGraph == null) {\\n        break;\\n      }\\n\\n      if (secondOwnerGraph == firstOwnerGraph) {\\n        return secondOwnerGraph;\\n      }\\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\\n    } while (true);\\n\\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\\n  } while (true);\\n\\n  return firstOwnerGraph;\\n};\\n\\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\\n  if (graph == null && depth == null) {\\n    graph = this.rootGraph;\\n    depth = 1;\\n  }\\n  var node;\\n\\n  var nodes = graph.getNodes();\\n  var s = nodes.length;\\n  for (var i = 0; i < s; i++) {\\n    node = nodes[i];\\n    node.inclusionTreeDepth = depth;\\n\\n    if (node.child != null) {\\n      this.calcInclusionTreeDepths(node.child, depth + 1);\\n    }\\n  }\\n};\\n\\nLGraphManager.prototype.includesInvalidEdge = function () {\\n  var edge;\\n\\n  var s = this.edges.length;\\n  for (var i = 0; i < s; i++) {\\n    edge = this.edges[i];\\n\\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n};\\n\\nmodule.exports = LGraphManager;\\n\\n/***/ }),\\n/* 7 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar LayoutConstants = __webpack_require__(0);\\n\\nfunction FDLayoutConstants() {}\\n\\n//FDLayoutConstants inherits static props in LayoutConstants\\nfor (var prop in LayoutConstants) {\\n  FDLayoutConstants[prop] = LayoutConstants[prop];\\n}\\n\\nFDLayoutConstants.MAX_ITERATIONS = 2500;\\n\\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\\n\\nmodule.exports = FDLayoutConstants;\\n\\n/***/ }),\\n/* 8 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\n/**\\n * This class maintains a list of static geometry related utility methods.\\n *\\n *\\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\\n */\\n\\nvar Point = __webpack_require__(12);\\n\\nfunction IGeometry() {}\\n\\n/**\\n * This method calculates *half* the amount in x and y directions of the two\\n * input rectangles needed to separate them keeping their respective\\n * positioning, and returns the result in the input array. An input\\n * separation buffer added to the amount in both directions. We assume that\\n * the two rectangles do intersect.\\n */\\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\\n  if (!rectA.intersects(rectB)) {\\n    throw \\\"assert failed\\\";\\n  }\\n\\n  var directions = new Array(2);\\n\\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\\n\\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\\n\\n  // update the overlapping amounts for the following cases:\\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\\n    /* Case x.1:\\n    *\\n    * rectA\\n    * \\t|                       |\\n    * \\t|        _________      |\\n    * \\t|        |       |      |\\n    * \\t|________|_______|______|\\n    * \\t\\t\\t |       |\\n    *           |       |\\n    *        rectB\\n    */\\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\\n    /* Case x.2:\\n    *\\n    * rectB\\n    * \\t|                       |\\n    * \\t|        _________      |\\n    * \\t|        |       |      |\\n    * \\t|________|_______|______|\\n    * \\t\\t\\t |       |\\n    *           |       |\\n    *        rectA\\n    */\\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\\n  }\\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\\n    /* Case y.1:\\n     *          ________ rectA\\n     *         |\\n     *         |\\n     *   ______|____  rectB\\n     *         |    |\\n     *         |    |\\n     *   ______|____|\\n     *         |\\n     *         |\\n     *         |________\\n     *\\n     */\\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\\n    /* Case y.2:\\n    *          ________ rectB\\n    *         |\\n    *         |\\n    *   ______|____  rectA\\n    *         |    |\\n    *         |    |\\n    *   ______|____|\\n    *         |\\n    *         |\\n    *         |________\\n    *\\n    */\\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\\n  }\\n\\n  // find slope of the line passes two centers\\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\\n  // if centers are overlapped\\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\\n    // assume the slope is 1 (45 degree)\\n    slope = 1.0;\\n  }\\n\\n  var moveByY = slope * overlapAmount[0];\\n  var moveByX = overlapAmount[1] / slope;\\n  if (overlapAmount[0] < moveByX) {\\n    moveByX = overlapAmount[0];\\n  } else {\\n    moveByY = overlapAmount[1];\\n  }\\n  // return half the amount so that if each rectangle is moved by these\\n  // amounts in opposite directions, overlap will be resolved\\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\\n};\\n\\n/**\\n * This method decides the separation direction of overlapping nodes\\n *\\n * if directions[0] = -1, then rectA goes left\\n * if directions[0] = 1,  then rectA goes right\\n * if directions[1] = -1, then rectA goes up\\n * if directions[1] = 1,  then rectA goes down\\n */\\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\\n  if (rectA.getCenterX() < rectB.getCenterX()) {\\n    directions[0] = -1;\\n  } else {\\n    directions[0] = 1;\\n  }\\n\\n  if (rectA.getCenterY() < rectB.getCenterY()) {\\n    directions[1] = -1;\\n  } else {\\n    directions[1] = 1;\\n  }\\n};\\n\\n/**\\n * This method calculates the intersection (clipping) points of the two\\n * input rectangles with line segment defined by the centers of these two\\n * rectangles. The clipping points are saved in the input double array and\\n * whether or not the two rectangles overlap is returned.\\n */\\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\\n  var p1x = rectA.getCenterX();\\n  var p1y = rectA.getCenterY();\\n  var p2x = rectB.getCenterX();\\n  var p2y = rectB.getCenterY();\\n\\n  //if two rectangles intersect, then clipping points are centers\\n  if (rectA.intersects(rectB)) {\\n    result[0] = p1x;\\n    result[1] = p1y;\\n    result[2] = p2x;\\n    result[3] = p2y;\\n    return true;\\n  }\\n  //variables for rectA\\n  var topLeftAx = rectA.getX();\\n  var topLeftAy = rectA.getY();\\n  var topRightAx = rectA.getRight();\\n  var bottomLeftAx = rectA.getX();\\n  var bottomLeftAy = rectA.getBottom();\\n  var bottomRightAx = rectA.getRight();\\n  var halfWidthA = rectA.getWidthHalf();\\n  var halfHeightA = rectA.getHeightHalf();\\n  //variables for rectB\\n  var topLeftBx = rectB.getX();\\n  var topLeftBy = rectB.getY();\\n  var topRightBx = rectB.getRight();\\n  var bottomLeftBx = rectB.getX();\\n  var bottomLeftBy = rectB.getBottom();\\n  var bottomRightBx = rectB.getRight();\\n  var halfWidthB = rectB.getWidthHalf();\\n  var halfHeightB = rectB.getHeightHalf();\\n\\n  //flag whether clipping points are found\\n  var clipPointAFound = false;\\n  var clipPointBFound = false;\\n\\n  // line is vertical\\n  if (p1x === p2x) {\\n    if (p1y > p2y) {\\n      result[0] = p1x;\\n      result[1] = topLeftAy;\\n      result[2] = p2x;\\n      result[3] = bottomLeftBy;\\n      return false;\\n    } else if (p1y < p2y) {\\n      result[0] = p1x;\\n      result[1] = bottomLeftAy;\\n      result[2] = p2x;\\n      result[3] = topLeftBy;\\n      return false;\\n    } else {\\n      //not line, return null;\\n    }\\n  }\\n  // line is horizontal\\n  else if (p1y === p2y) {\\n      if (p1x > p2x) {\\n        result[0] = topLeftAx;\\n        result[1] = p1y;\\n        result[2] = topRightBx;\\n        result[3] = p2y;\\n        return false;\\n      } else if (p1x < p2x) {\\n        result[0] = topRightAx;\\n        result[1] = p1y;\\n        result[2] = topLeftBx;\\n        result[3] = p2y;\\n        return false;\\n      } else {\\n        //not valid line, return null;\\n      }\\n    } else {\\n      //slopes of rectA's and rectB's diagonals\\n      var slopeA = rectA.height / rectA.width;\\n      var slopeB = rectB.height / rectB.width;\\n\\n      //slope of line between center of rectA and center of rectB\\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\\n      var cardinalDirectionA = void 0;\\n      var cardinalDirectionB = void 0;\\n      var tempPointAx = void 0;\\n      var tempPointAy = void 0;\\n      var tempPointBx = void 0;\\n      var tempPointBy = void 0;\\n\\n      //determine whether clipping point is the corner of nodeA\\n      if (-slopeA === slopePrime) {\\n        if (p1x > p2x) {\\n          result[0] = bottomLeftAx;\\n          result[1] = bottomLeftAy;\\n          clipPointAFound = true;\\n        } else {\\n          result[0] = topRightAx;\\n          result[1] = topLeftAy;\\n          clipPointAFound = true;\\n        }\\n      } else if (slopeA === slopePrime) {\\n        if (p1x > p2x) {\\n          result[0] = topLeftAx;\\n          result[1] = topLeftAy;\\n          clipPointAFound = true;\\n        } else {\\n          result[0] = bottomRightAx;\\n          result[1] = bottomLeftAy;\\n          clipPointAFound = true;\\n        }\\n      }\\n\\n      //determine whether clipping point is the corner of nodeB\\n      if (-slopeB === slopePrime) {\\n        if (p2x > p1x) {\\n          result[2] = bottomLeftBx;\\n          result[3] = bottomLeftBy;\\n          clipPointBFound = true;\\n        } else {\\n          result[2] = topRightBx;\\n          result[3] = topLeftBy;\\n          clipPointBFound = true;\\n        }\\n      } else if (slopeB === slopePrime) {\\n        if (p2x > p1x) {\\n          result[2] = topLeftBx;\\n          result[3] = topLeftBy;\\n          clipPointBFound = true;\\n        } else {\\n          result[2] = bottomRightBx;\\n          result[3] = bottomLeftBy;\\n          clipPointBFound = true;\\n        }\\n      }\\n\\n      //if both clipping points are corners\\n      if (clipPointAFound && clipPointBFound) {\\n        return false;\\n      }\\n\\n      //determine Cardinal Direction of rectangles\\n      if (p1x > p2x) {\\n        if (p1y > p2y) {\\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\\n        } else {\\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\\n        }\\n      } else {\\n        if (p1y > p2y) {\\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\\n        } else {\\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\\n        }\\n      }\\n      //calculate clipping Point if it is not found before\\n      if (!clipPointAFound) {\\n        switch (cardinalDirectionA) {\\n          case 1:\\n            tempPointAy = topLeftAy;\\n            tempPointAx = p1x + -halfHeightA / slopePrime;\\n            result[0] = tempPointAx;\\n            result[1] = tempPointAy;\\n            break;\\n          case 2:\\n            tempPointAx = bottomRightAx;\\n            tempPointAy = p1y + halfWidthA * slopePrime;\\n            result[0] = tempPointAx;\\n            result[1] = tempPointAy;\\n            break;\\n          case 3:\\n            tempPointAy = bottomLeftAy;\\n            tempPointAx = p1x + halfHeightA / slopePrime;\\n            result[0] = tempPointAx;\\n            result[1] = tempPointAy;\\n            break;\\n          case 4:\\n            tempPointAx = bottomLeftAx;\\n            tempPointAy = p1y + -halfWidthA * slopePrime;\\n            result[0] = tempPointAx;\\n            result[1] = tempPointAy;\\n            break;\\n        }\\n      }\\n      if (!clipPointBFound) {\\n        switch (cardinalDirectionB) {\\n          case 1:\\n            tempPointBy = topLeftBy;\\n            tempPointBx = p2x + -halfHeightB / slopePrime;\\n            result[2] = tempPointBx;\\n            result[3] = tempPointBy;\\n            break;\\n          case 2:\\n            tempPointBx = bottomRightBx;\\n            tempPointBy = p2y + halfWidthB * slopePrime;\\n            result[2] = tempPointBx;\\n            result[3] = tempPointBy;\\n            break;\\n          case 3:\\n            tempPointBy = bottomLeftBy;\\n            tempPointBx = p2x + halfHeightB / slopePrime;\\n            result[2] = tempPointBx;\\n            result[3] = tempPointBy;\\n            break;\\n          case 4:\\n            tempPointBx = bottomLeftBx;\\n            tempPointBy = p2y + -halfWidthB * slopePrime;\\n            result[2] = tempPointBx;\\n            result[3] = tempPointBy;\\n            break;\\n        }\\n      }\\n    }\\n  return false;\\n};\\n\\n/**\\n * This method returns in which cardinal direction does input point stays\\n * 1: North\\n * 2: East\\n * 3: South\\n * 4: West\\n */\\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\\n  if (slope > slopePrime) {\\n    return line;\\n  } else {\\n    return 1 + line % 4;\\n  }\\n};\\n\\n/**\\n * This method calculates the intersection of the two lines defined by\\n * point pairs (s1,s2) and (f1,f2).\\n */\\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\\n  if (f2 == null) {\\n    return this.getIntersection2(s1, s2, f1);\\n  }\\n\\n  var x1 = s1.x;\\n  var y1 = s1.y;\\n  var x2 = s2.x;\\n  var y2 = s2.y;\\n  var x3 = f1.x;\\n  var y3 = f1.y;\\n  var x4 = f2.x;\\n  var y4 = f2.y;\\n  var x = void 0,\\n      y = void 0; // intersection point\\n  var a1 = void 0,\\n      a2 = void 0,\\n      b1 = void 0,\\n      b2 = void 0,\\n      c1 = void 0,\\n      c2 = void 0; // coefficients of line eqns.\\n  var denom = void 0;\\n\\n  a1 = y2 - y1;\\n  b1 = x1 - x2;\\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\\n\\n  a2 = y4 - y3;\\n  b2 = x3 - x4;\\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\\n\\n  denom = a1 * b2 - a2 * b1;\\n\\n  if (denom === 0) {\\n    return null;\\n  }\\n\\n  x = (b1 * c2 - b2 * c1) / denom;\\n  y = (a2 * c1 - a1 * c2) / denom;\\n\\n  return new Point(x, y);\\n};\\n\\n/**\\n * This method finds and returns the angle of the vector from the + x-axis\\n * in clockwise direction (compatible w/ Java coordinate system!).\\n */\\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\\n  var C_angle = void 0;\\n\\n  if (Cx !== Nx) {\\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\\n\\n    if (Nx < Cx) {\\n      C_angle += Math.PI;\\n    } else if (Ny < Cy) {\\n      C_angle += this.TWO_PI;\\n    }\\n  } else if (Ny < Cy) {\\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\\n  } else {\\n    C_angle = this.HALF_PI; // 90 degrees\\n  }\\n\\n  return C_angle;\\n};\\n\\n/**\\n * This method checks whether the given two line segments (one with point\\n * p1 and p2, the other with point p3 and p4) intersect at a point other\\n * than these points.\\n */\\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\\n  var a = p1.x;\\n  var b = p1.y;\\n  var c = p2.x;\\n  var d = p2.y;\\n  var p = p3.x;\\n  var q = p3.y;\\n  var r = p4.x;\\n  var s = p4.y;\\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\\n\\n  if (det === 0) {\\n    return false;\\n  } else {\\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\\n  }\\n};\\n\\n// -----------------------------------------------------------------------------\\n// Section: Class Constants\\n// -----------------------------------------------------------------------------\\n/**\\n * Some useful pre-calculated constants\\n */\\nIGeometry.HALF_PI = 0.5 * Math.PI;\\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\\nIGeometry.TWO_PI = 2.0 * Math.PI;\\nIGeometry.THREE_PI = 3.0 * Math.PI;\\n\\nmodule.exports = IGeometry;\\n\\n/***/ }),\\n/* 9 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction IMath() {}\\n\\n/**\\n * This method returns the sign of the input value.\\n */\\nIMath.sign = function (value) {\\n  if (value > 0) {\\n    return 1;\\n  } else if (value < 0) {\\n    return -1;\\n  } else {\\n    return 0;\\n  }\\n};\\n\\nIMath.floor = function (value) {\\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\\n};\\n\\nIMath.ceil = function (value) {\\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\\n};\\n\\nmodule.exports = IMath;\\n\\n/***/ }),\\n/* 10 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction Integer() {}\\n\\nInteger.MAX_VALUE = 2147483647;\\nInteger.MIN_VALUE = -2147483648;\\n\\nmodule.exports = Integer;\\n\\n/***/ }),\\n/* 11 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nvar nodeFrom = function nodeFrom(value) {\\n  return { value: value, next: null, prev: null };\\n};\\n\\nvar add = function add(prev, node, next, list) {\\n  if (prev !== null) {\\n    prev.next = node;\\n  } else {\\n    list.head = node;\\n  }\\n\\n  if (next !== null) {\\n    next.prev = node;\\n  } else {\\n    list.tail = node;\\n  }\\n\\n  node.prev = prev;\\n  node.next = next;\\n\\n  list.length++;\\n\\n  return node;\\n};\\n\\nvar _remove = function _remove(node, list) {\\n  var prev = node.prev,\\n      next = node.next;\\n\\n\\n  if (prev !== null) {\\n    prev.next = next;\\n  } else {\\n    list.head = next;\\n  }\\n\\n  if (next !== null) {\\n    next.prev = prev;\\n  } else {\\n    list.tail = prev;\\n  }\\n\\n  node.prev = node.next = null;\\n\\n  list.length--;\\n\\n  return node;\\n};\\n\\nvar LinkedList = function () {\\n  function LinkedList(vals) {\\n    var _this = this;\\n\\n    _classCallCheck(this, LinkedList);\\n\\n    this.length = 0;\\n    this.head = null;\\n    this.tail = null;\\n\\n    if (vals != null) {\\n      vals.forEach(function (v) {\\n        return _this.push(v);\\n      });\\n    }\\n  }\\n\\n  _createClass(LinkedList, [{\\n    key: \\\"size\\\",\\n    value: function size() {\\n      return this.length;\\n    }\\n  }, {\\n    key: \\\"insertBefore\\\",\\n    value: function insertBefore(val, otherNode) {\\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\\n    }\\n  }, {\\n    key: \\\"insertAfter\\\",\\n    value: function insertAfter(val, otherNode) {\\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\\n    }\\n  }, {\\n    key: \\\"insertNodeBefore\\\",\\n    value: function insertNodeBefore(newNode, otherNode) {\\n      return add(otherNode.prev, newNode, otherNode, this);\\n    }\\n  }, {\\n    key: \\\"insertNodeAfter\\\",\\n    value: function insertNodeAfter(newNode, otherNode) {\\n      return add(otherNode, newNode, otherNode.next, this);\\n    }\\n  }, {\\n    key: \\\"push\\\",\\n    value: function push(val) {\\n      return add(this.tail, nodeFrom(val), null, this);\\n    }\\n  }, {\\n    key: \\\"unshift\\\",\\n    value: function unshift(val) {\\n      return add(null, nodeFrom(val), this.head, this);\\n    }\\n  }, {\\n    key: \\\"remove\\\",\\n    value: function remove(node) {\\n      return _remove(node, this);\\n    }\\n  }, {\\n    key: \\\"pop\\\",\\n    value: function pop() {\\n      return _remove(this.tail, this).value;\\n    }\\n  }, {\\n    key: \\\"popNode\\\",\\n    value: function popNode() {\\n      return _remove(this.tail, this);\\n    }\\n  }, {\\n    key: \\\"shift\\\",\\n    value: function shift() {\\n      return _remove(this.head, this).value;\\n    }\\n  }, {\\n    key: \\\"shiftNode\\\",\\n    value: function shiftNode() {\\n      return _remove(this.head, this);\\n    }\\n  }, {\\n    key: \\\"get_object_at\\\",\\n    value: function get_object_at(index) {\\n      if (index <= this.length()) {\\n        var i = 1;\\n        var current = this.head;\\n        while (i < index) {\\n          current = current.next;\\n          i++;\\n        }\\n        return current.value;\\n      }\\n    }\\n  }, {\\n    key: \\\"set_object_at\\\",\\n    value: function set_object_at(index, value) {\\n      if (index <= this.length()) {\\n        var i = 1;\\n        var current = this.head;\\n        while (i < index) {\\n          current = current.next;\\n          i++;\\n        }\\n        current.value = value;\\n      }\\n    }\\n  }]);\\n\\n  return LinkedList;\\n}();\\n\\nmodule.exports = LinkedList;\\n\\n/***/ }),\\n/* 12 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\n/*\\r\\n *This class is the javascript implementation of the Point.java class in jdk\\r\\n */\\nfunction Point(x, y, p) {\\n  this.x = null;\\n  this.y = null;\\n  if (x == null && y == null && p == null) {\\n    this.x = 0;\\n    this.y = 0;\\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\\n    this.x = x;\\n    this.y = y;\\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\\n    p = x;\\n    this.x = p.x;\\n    this.y = p.y;\\n  }\\n}\\n\\nPoint.prototype.getX = function () {\\n  return this.x;\\n};\\n\\nPoint.prototype.getY = function () {\\n  return this.y;\\n};\\n\\nPoint.prototype.getLocation = function () {\\n  return new Point(this.x, this.y);\\n};\\n\\nPoint.prototype.setLocation = function (x, y, p) {\\n  if (x.constructor.name == 'Point' && y == null && p == null) {\\n    p = x;\\n    this.setLocation(p.x, p.y);\\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\\n    //if both parameters are integer just move (x,y) location\\n    if (parseInt(x) == x && parseInt(y) == y) {\\n      this.move(x, y);\\n    } else {\\n      this.x = Math.floor(x + 0.5);\\n      this.y = Math.floor(y + 0.5);\\n    }\\n  }\\n};\\n\\nPoint.prototype.move = function (x, y) {\\n  this.x = x;\\n  this.y = y;\\n};\\n\\nPoint.prototype.translate = function (dx, dy) {\\n  this.x += dx;\\n  this.y += dy;\\n};\\n\\nPoint.prototype.equals = function (obj) {\\n  if (obj.constructor.name == \\\"Point\\\") {\\n    var pt = obj;\\n    return this.x == pt.x && this.y == pt.y;\\n  }\\n  return this == obj;\\n};\\n\\nPoint.prototype.toString = function () {\\n  return new Point().constructor.name + \\\"[x=\\\" + this.x + \\\",y=\\\" + this.y + \\\"]\\\";\\n};\\n\\nmodule.exports = Point;\\n\\n/***/ }),\\n/* 13 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction RectangleD(x, y, width, height) {\\n  this.x = 0;\\n  this.y = 0;\\n  this.width = 0;\\n  this.height = 0;\\n\\n  if (x != null && y != null && width != null && height != null) {\\n    this.x = x;\\n    this.y = y;\\n    this.width = width;\\n    this.height = height;\\n  }\\n}\\n\\nRectangleD.prototype.getX = function () {\\n  return this.x;\\n};\\n\\nRectangleD.prototype.setX = function (x) {\\n  this.x = x;\\n};\\n\\nRectangleD.prototype.getY = function () {\\n  return this.y;\\n};\\n\\nRectangleD.prototype.setY = function (y) {\\n  this.y = y;\\n};\\n\\nRectangleD.prototype.getWidth = function () {\\n  return this.width;\\n};\\n\\nRectangleD.prototype.setWidth = function (width) {\\n  this.width = width;\\n};\\n\\nRectangleD.prototype.getHeight = function () {\\n  return this.height;\\n};\\n\\nRectangleD.prototype.setHeight = function (height) {\\n  this.height = height;\\n};\\n\\nRectangleD.prototype.getRight = function () {\\n  return this.x + this.width;\\n};\\n\\nRectangleD.prototype.getBottom = function () {\\n  return this.y + this.height;\\n};\\n\\nRectangleD.prototype.intersects = function (a) {\\n  if (this.getRight() < a.x) {\\n    return false;\\n  }\\n\\n  if (this.getBottom() < a.y) {\\n    return false;\\n  }\\n\\n  if (a.getRight() < this.x) {\\n    return false;\\n  }\\n\\n  if (a.getBottom() < this.y) {\\n    return false;\\n  }\\n\\n  return true;\\n};\\n\\nRectangleD.prototype.getCenterX = function () {\\n  return this.x + this.width / 2;\\n};\\n\\nRectangleD.prototype.getMinX = function () {\\n  return this.getX();\\n};\\n\\nRectangleD.prototype.getMaxX = function () {\\n  return this.getX() + this.width;\\n};\\n\\nRectangleD.prototype.getCenterY = function () {\\n  return this.y + this.height / 2;\\n};\\n\\nRectangleD.prototype.getMinY = function () {\\n  return this.getY();\\n};\\n\\nRectangleD.prototype.getMaxY = function () {\\n  return this.getY() + this.height;\\n};\\n\\nRectangleD.prototype.getWidthHalf = function () {\\n  return this.width / 2;\\n};\\n\\nRectangleD.prototype.getHeightHalf = function () {\\n  return this.height / 2;\\n};\\n\\nmodule.exports = RectangleD;\\n\\n/***/ }),\\n/* 14 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nfunction UniqueIDGeneretor() {}\\n\\nUniqueIDGeneretor.lastID = 0;\\n\\nUniqueIDGeneretor.createID = function (obj) {\\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\\n    return obj;\\n  }\\n  if (obj.uniqueID != null) {\\n    return obj.uniqueID;\\n  }\\n  obj.uniqueID = UniqueIDGeneretor.getString();\\n  UniqueIDGeneretor.lastID++;\\n  return obj.uniqueID;\\n};\\n\\nUniqueIDGeneretor.getString = function (id) {\\n  if (id == null) id = UniqueIDGeneretor.lastID;\\n  return \\\"Object#\\\" + id + \\\"\\\";\\n};\\n\\nUniqueIDGeneretor.isPrimitive = function (arg) {\\n  var type = typeof arg === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(arg);\\n  return arg == null || type != \\\"object\\\" && type != \\\"function\\\";\\n};\\n\\nmodule.exports = UniqueIDGeneretor;\\n\\n/***/ }),\\n/* 15 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\\n\\nvar LayoutConstants = __webpack_require__(0);\\nvar LGraphManager = __webpack_require__(6);\\nvar LNode = __webpack_require__(3);\\nvar LEdge = __webpack_require__(1);\\nvar LGraph = __webpack_require__(5);\\nvar PointD = __webpack_require__(4);\\nvar Transform = __webpack_require__(17);\\nvar Emitter = __webpack_require__(27);\\n\\nfunction Layout(isRemoteUse) {\\n  Emitter.call(this);\\n\\n  //Layout Quality: 0:draft, 1:default, 2:proof\\n  this.layoutQuality = LayoutConstants.QUALITY;\\n  //Whether layout should create bendpoints as needed or not\\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\\n  //Whether layout should be incremental or not\\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\\n  //Whether we animate from before to after layout node positions\\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\\n  //Whether we animate the layout process or not\\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\\n  //Number iterations that should be done between two successive animations\\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\\n  /**\\r\\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\\r\\n   * they are, both spring and repulsion forces between two leaf nodes can be\\r\\n   * calculated without the expensive clipping point calculations, resulting\\r\\n   * in major speed-up.\\r\\n   */\\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\\n  /**\\r\\n   * This is used for creation of bendpoints by using dummy nodes and edges.\\r\\n   * Maps an LEdge to its dummy bendpoint path.\\r\\n   */\\n  this.edgeToDummyNodes = new Map();\\n  this.graphManager = new LGraphManager(this);\\n  this.isLayoutFinished = false;\\n  this.isSubLayout = false;\\n  this.isRemoteUse = false;\\n\\n  if (isRemoteUse != null) {\\n    this.isRemoteUse = isRemoteUse;\\n  }\\n}\\n\\nLayout.RANDOM_SEED = 1;\\n\\nLayout.prototype = Object.create(Emitter.prototype);\\n\\nLayout.prototype.getGraphManager = function () {\\n  return this.graphManager;\\n};\\n\\nLayout.prototype.getAllNodes = function () {\\n  return this.graphManager.getAllNodes();\\n};\\n\\nLayout.prototype.getAllEdges = function () {\\n  return this.graphManager.getAllEdges();\\n};\\n\\nLayout.prototype.getAllNodesToApplyGravitation = function () {\\n  return this.graphManager.getAllNodesToApplyGravitation();\\n};\\n\\nLayout.prototype.newGraphManager = function () {\\n  var gm = new LGraphManager(this);\\n  this.graphManager = gm;\\n  return gm;\\n};\\n\\nLayout.prototype.newGraph = function (vGraph) {\\n  return new LGraph(null, this.graphManager, vGraph);\\n};\\n\\nLayout.prototype.newNode = function (vNode) {\\n  return new LNode(this.graphManager, vNode);\\n};\\n\\nLayout.prototype.newEdge = function (vEdge) {\\n  return new LEdge(null, null, vEdge);\\n};\\n\\nLayout.prototype.checkLayoutSuccess = function () {\\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\\n};\\n\\nLayout.prototype.runLayout = function () {\\n  this.isLayoutFinished = false;\\n\\n  if (this.tilingPreLayout) {\\n    this.tilingPreLayout();\\n  }\\n\\n  this.initParameters();\\n  var isLayoutSuccessfull;\\n\\n  if (this.checkLayoutSuccess()) {\\n    isLayoutSuccessfull = false;\\n  } else {\\n    isLayoutSuccessfull = this.layout();\\n  }\\n\\n  if (LayoutConstants.ANIMATE === 'during') {\\n    // If this is a 'during' layout animation. Layout is not finished yet. \\n    // We need to perform these in index.js when layout is really finished.\\n    return false;\\n  }\\n\\n  if (isLayoutSuccessfull) {\\n    if (!this.isSubLayout) {\\n      this.doPostLayout();\\n    }\\n  }\\n\\n  if (this.tilingPostLayout) {\\n    this.tilingPostLayout();\\n  }\\n\\n  this.isLayoutFinished = true;\\n\\n  return isLayoutSuccessfull;\\n};\\n\\n/**\\r\\n * This method performs the operations required after layout.\\r\\n */\\nLayout.prototype.doPostLayout = function () {\\n  //assert !isSubLayout : \\\"Should not be called on sub-layout!\\\";\\n  // Propagate geometric changes to v-level objects\\n  if (!this.incremental) {\\n    this.transform();\\n  }\\n  this.update();\\n};\\n\\n/**\\r\\n * This method updates the geometry of the target graph according to\\r\\n * calculated layout.\\r\\n */\\nLayout.prototype.update2 = function () {\\n  // update bend points\\n  if (this.createBendsAsNeeded) {\\n    this.createBendpointsFromDummyNodes();\\n\\n    // reset all edges, since the topology has changed\\n    this.graphManager.resetAllEdges();\\n  }\\n\\n  // perform edge, node and root updates if layout is not called\\n  // remotely\\n  if (!this.isRemoteUse) {\\n    // update all edges\\n    var edge;\\n    var allEdges = this.graphManager.getAllEdges();\\n    for (var i = 0; i < allEdges.length; i++) {\\n      edge = allEdges[i];\\n      //      this.update(edge);\\n    }\\n\\n    // recursively update nodes\\n    var node;\\n    var nodes = this.graphManager.getRoot().getNodes();\\n    for (var i = 0; i < nodes.length; i++) {\\n      node = nodes[i];\\n      //      this.update(node);\\n    }\\n\\n    // update root graph\\n    this.update(this.graphManager.getRoot());\\n  }\\n};\\n\\nLayout.prototype.update = function (obj) {\\n  if (obj == null) {\\n    this.update2();\\n  } else if (obj instanceof LNode) {\\n    var node = obj;\\n    if (node.getChild() != null) {\\n      // since node is compound, recursively update child nodes\\n      var nodes = node.getChild().getNodes();\\n      for (var i = 0; i < nodes.length; i++) {\\n        update(nodes[i]);\\n      }\\n    }\\n\\n    // if the l-level node is associated with a v-level graph object,\\n    // then it is assumed that the v-level node implements the\\n    // interface Updatable.\\n    if (node.vGraphObject != null) {\\n      // cast to Updatable without any type check\\n      var vNode = node.vGraphObject;\\n\\n      // call the update method of the interface\\n      vNode.update(node);\\n    }\\n  } else if (obj instanceof LEdge) {\\n    var edge = obj;\\n    // if the l-level edge is associated with a v-level graph object,\\n    // then it is assumed that the v-level edge implements the\\n    // interface Updatable.\\n\\n    if (edge.vGraphObject != null) {\\n      // cast to Updatable without any type check\\n      var vEdge = edge.vGraphObject;\\n\\n      // call the update method of the interface\\n      vEdge.update(edge);\\n    }\\n  } else if (obj instanceof LGraph) {\\n    var graph = obj;\\n    // if the l-level graph is associated with a v-level graph object,\\n    // then it is assumed that the v-level object implements the\\n    // interface Updatable.\\n\\n    if (graph.vGraphObject != null) {\\n      // cast to Updatable without any type check\\n      var vGraph = graph.vGraphObject;\\n\\n      // call the update method of the interface\\n      vGraph.update(graph);\\n    }\\n  }\\n};\\n\\n/**\\r\\n * This method is used to set all layout parameters to default values\\r\\n * determined at compile time.\\r\\n */\\nLayout.prototype.initParameters = function () {\\n  if (!this.isSubLayout) {\\n    this.layoutQuality = LayoutConstants.QUALITY;\\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\\n  }\\n\\n  if (this.animationDuringLayout) {\\n    this.animationOnLayout = false;\\n  }\\n};\\n\\nLayout.prototype.transform = function (newLeftTop) {\\n  if (newLeftTop == undefined) {\\n    this.transform(new PointD(0, 0));\\n  } else {\\n    // create a transformation object (from Eclipse to layout). When an\\n    // inverse transform is applied, we get upper-left coordinate of the\\n    // drawing or the root graph at given input coordinate (some margins\\n    // already included in calculation of left-top).\\n\\n    var trans = new Transform();\\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\\n\\n    if (leftTop != null) {\\n      trans.setWorldOrgX(newLeftTop.x);\\n      trans.setWorldOrgY(newLeftTop.y);\\n\\n      trans.setDeviceOrgX(leftTop.x);\\n      trans.setDeviceOrgY(leftTop.y);\\n\\n      var nodes = this.getAllNodes();\\n      var node;\\n\\n      for (var i = 0; i < nodes.length; i++) {\\n        node = nodes[i];\\n        node.transform(trans);\\n      }\\n    }\\n  }\\n};\\n\\nLayout.prototype.positionNodesRandomly = function (graph) {\\n\\n  if (graph == undefined) {\\n    //assert !this.incremental;\\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\\n    this.getGraphManager().getRoot().updateBounds(true);\\n  } else {\\n    var lNode;\\n    var childGraph;\\n\\n    var nodes = graph.getNodes();\\n    for (var i = 0; i < nodes.length; i++) {\\n      lNode = nodes[i];\\n      childGraph = lNode.getChild();\\n\\n      if (childGraph == null) {\\n        lNode.scatter();\\n      } else if (childGraph.getNodes().length == 0) {\\n        lNode.scatter();\\n      } else {\\n        this.positionNodesRandomly(childGraph);\\n        lNode.updateBounds();\\n      }\\n    }\\n  }\\n};\\n\\n/**\\r\\n * This method returns a list of trees where each tree is represented as a\\r\\n * list of l-nodes. The method returns a list of size 0 when:\\r\\n * - The graph is not flat or\\r\\n * - One of the component(s) of the graph is not a tree.\\r\\n */\\nLayout.prototype.getFlatForest = function () {\\n  var flatForest = [];\\n  var isForest = true;\\n\\n  // Quick reference for all nodes in the graph manager associated with\\n  // this layout. The list should not be changed.\\n  var allNodes = this.graphManager.getRoot().getNodes();\\n\\n  // First be sure that the graph is flat\\n  var isFlat = true;\\n\\n  for (var i = 0; i < allNodes.length; i++) {\\n    if (allNodes[i].getChild() != null) {\\n      isFlat = false;\\n    }\\n  }\\n\\n  // Return empty forest if the graph is not flat.\\n  if (!isFlat) {\\n    return flatForest;\\n  }\\n\\n  // Run BFS for each component of the graph.\\n\\n  var visited = new Set();\\n  var toBeVisited = [];\\n  var parents = new Map();\\n  var unProcessedNodes = [];\\n\\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\\n\\n  // Each iteration of this loop finds a component of the graph and\\n  // decides whether it is a tree or not. If it is a tree, adds it to the\\n  // forest and continued with the next component.\\n\\n  while (unProcessedNodes.length > 0 && isForest) {\\n    toBeVisited.push(unProcessedNodes[0]);\\n\\n    // Start the BFS. Each iteration of this loop visits a node in a\\n    // BFS manner.\\n    while (toBeVisited.length > 0 && isForest) {\\n      //pool operation\\n      var currentNode = toBeVisited[0];\\n      toBeVisited.splice(0, 1);\\n      visited.add(currentNode);\\n\\n      // Traverse all neighbors of this node\\n      var neighborEdges = currentNode.getEdges();\\n\\n      for (var i = 0; i < neighborEdges.length; i++) {\\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\\n\\n        // If BFS is not growing from this neighbor.\\n        if (parents.get(currentNode) != currentNeighbor) {\\n          // We haven't previously visited this neighbor.\\n          if (!visited.has(currentNeighbor)) {\\n            toBeVisited.push(currentNeighbor);\\n            parents.set(currentNeighbor, currentNode);\\n          }\\n          // Since we have previously visited this neighbor and\\n          // this neighbor is not parent of currentNode, given\\n          // graph contains a component that is not tree, hence\\n          // it is not a forest.\\n          else {\\n              isForest = false;\\n              break;\\n            }\\n        }\\n      }\\n    }\\n\\n    // The graph contains a component that is not a tree. Empty\\n    // previously found trees. The method will end.\\n    if (!isForest) {\\n      flatForest = [];\\n    }\\n    // Save currently visited nodes as a tree in our forest. Reset\\n    // visited and parents lists. Continue with the next component of\\n    // the graph, if any.\\n    else {\\n        var temp = [].concat(_toConsumableArray(visited));\\n        flatForest.push(temp);\\n        //flatForest = flatForest.concat(temp);\\n        //unProcessedNodes.removeAll(visited);\\n        for (var i = 0; i < temp.length; i++) {\\n          var value = temp[i];\\n          var index = unProcessedNodes.indexOf(value);\\n          if (index > -1) {\\n            unProcessedNodes.splice(index, 1);\\n          }\\n        }\\n        visited = new Set();\\n        parents = new Map();\\n      }\\n  }\\n\\n  return flatForest;\\n};\\n\\n/**\\r\\n * This method creates dummy nodes (an l-level node with minimal dimensions)\\r\\n * for the given edge (one per bendpoint). The existing l-level structure\\r\\n * is updated accordingly.\\r\\n */\\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\\n  var dummyNodes = [];\\n  var prev = edge.source;\\n\\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\\n\\n  for (var i = 0; i < edge.bendpoints.length; i++) {\\n    // create new dummy node\\n    var dummyNode = this.newNode(null);\\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\\n\\n    graph.add(dummyNode);\\n\\n    // create new dummy edge between prev and dummy node\\n    var dummyEdge = this.newEdge(null);\\n    this.graphManager.add(dummyEdge, prev, dummyNode);\\n\\n    dummyNodes.add(dummyNode);\\n    prev = dummyNode;\\n  }\\n\\n  var dummyEdge = this.newEdge(null);\\n  this.graphManager.add(dummyEdge, prev, edge.target);\\n\\n  this.edgeToDummyNodes.set(edge, dummyNodes);\\n\\n  // remove real edge from graph manager if it is inter-graph\\n  if (edge.isInterGraph()) {\\n    this.graphManager.remove(edge);\\n  }\\n  // else, remove the edge from the current graph\\n  else {\\n      graph.remove(edge);\\n    }\\n\\n  return dummyNodes;\\n};\\n\\n/**\\r\\n * This method creates bendpoints for edges from the dummy nodes\\r\\n * at l-level.\\r\\n */\\nLayout.prototype.createBendpointsFromDummyNodes = function () {\\n  var edges = [];\\n  edges = edges.concat(this.graphManager.getAllEdges());\\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\\n\\n  for (var k = 0; k < edges.length; k++) {\\n    var lEdge = edges[k];\\n\\n    if (lEdge.bendpoints.length > 0) {\\n      var path = this.edgeToDummyNodes.get(lEdge);\\n\\n      for (var i = 0; i < path.length; i++) {\\n        var dummyNode = path[i];\\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\\n\\n        // update bendpoint's location according to dummy node\\n        var ebp = lEdge.bendpoints.get(i);\\n        ebp.x = p.x;\\n        ebp.y = p.y;\\n\\n        // remove the dummy node, dummy edges incident with this\\n        // dummy node is also removed (within the remove method)\\n        dummyNode.getOwner().remove(dummyNode);\\n      }\\n\\n      // add the real edge to graph\\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\\n    }\\n  }\\n};\\n\\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\\n  if (minDiv != undefined && maxMul != undefined) {\\n    var value = defaultValue;\\n\\n    if (sliderValue <= 50) {\\n      var minValue = defaultValue / minDiv;\\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\\n    } else {\\n      var maxValue = defaultValue * maxMul;\\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\\n    }\\n\\n    return value;\\n  } else {\\n    var a, b;\\n\\n    if (sliderValue <= 50) {\\n      a = 9.0 * defaultValue / 500.0;\\n      b = defaultValue / 10.0;\\n    } else {\\n      a = 9.0 * defaultValue / 50.0;\\n      b = -8 * defaultValue;\\n    }\\n\\n    return a * sliderValue + b;\\n  }\\n};\\n\\n/**\\r\\n * This method finds and returns the center of the given nodes, assuming\\r\\n * that the given nodes form a tree in themselves.\\r\\n */\\nLayout.findCenterOfTree = function (nodes) {\\n  var list = [];\\n  list = list.concat(nodes);\\n\\n  var removedNodes = [];\\n  var remainingDegrees = new Map();\\n  var foundCenter = false;\\n  var centerNode = null;\\n\\n  if (list.length == 1 || list.length == 2) {\\n    foundCenter = true;\\n    centerNode = list[0];\\n  }\\n\\n  for (var i = 0; i < list.length; i++) {\\n    var node = list[i];\\n    var degree = node.getNeighborsList().size;\\n    remainingDegrees.set(node, node.getNeighborsList().size);\\n\\n    if (degree == 1) {\\n      removedNodes.push(node);\\n    }\\n  }\\n\\n  var tempList = [];\\n  tempList = tempList.concat(removedNodes);\\n\\n  while (!foundCenter) {\\n    var tempList2 = [];\\n    tempList2 = tempList2.concat(tempList);\\n    tempList = [];\\n\\n    for (var i = 0; i < list.length; i++) {\\n      var node = list[i];\\n\\n      var index = list.indexOf(node);\\n      if (index >= 0) {\\n        list.splice(index, 1);\\n      }\\n\\n      var neighbours = node.getNeighborsList();\\n\\n      neighbours.forEach(function (neighbour) {\\n        if (removedNodes.indexOf(neighbour) < 0) {\\n          var otherDegree = remainingDegrees.get(neighbour);\\n          var newDegree = otherDegree - 1;\\n\\n          if (newDegree == 1) {\\n            tempList.push(neighbour);\\n          }\\n\\n          remainingDegrees.set(neighbour, newDegree);\\n        }\\n      });\\n    }\\n\\n    removedNodes = removedNodes.concat(tempList);\\n\\n    if (list.length == 1 || list.length == 2) {\\n      foundCenter = true;\\n      centerNode = list[0];\\n    }\\n  }\\n\\n  return centerNode;\\n};\\n\\n/**\\r\\n * During the coarsening process, this layout may be referenced by two graph managers\\r\\n * this setter function grants access to change the currently being used graph manager\\r\\n */\\nLayout.prototype.setGraphManager = function (gm) {\\n  this.graphManager = gm;\\n};\\n\\nmodule.exports = Layout;\\n\\n/***/ }),\\n/* 16 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction RandomSeed() {}\\n// adapted from: https://stackoverflow.com/a/19303725\\nRandomSeed.seed = 1;\\nRandomSeed.x = 0;\\n\\nRandomSeed.nextDouble = function () {\\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\\n  return RandomSeed.x - Math.floor(RandomSeed.x);\\n};\\n\\nmodule.exports = RandomSeed;\\n\\n/***/ }),\\n/* 17 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar PointD = __webpack_require__(4);\\n\\nfunction Transform(x, y) {\\n  this.lworldOrgX = 0.0;\\n  this.lworldOrgY = 0.0;\\n  this.ldeviceOrgX = 0.0;\\n  this.ldeviceOrgY = 0.0;\\n  this.lworldExtX = 1.0;\\n  this.lworldExtY = 1.0;\\n  this.ldeviceExtX = 1.0;\\n  this.ldeviceExtY = 1.0;\\n}\\n\\nTransform.prototype.getWorldOrgX = function () {\\n  return this.lworldOrgX;\\n};\\n\\nTransform.prototype.setWorldOrgX = function (wox) {\\n  this.lworldOrgX = wox;\\n};\\n\\nTransform.prototype.getWorldOrgY = function () {\\n  return this.lworldOrgY;\\n};\\n\\nTransform.prototype.setWorldOrgY = function (woy) {\\n  this.lworldOrgY = woy;\\n};\\n\\nTransform.prototype.getWorldExtX = function () {\\n  return this.lworldExtX;\\n};\\n\\nTransform.prototype.setWorldExtX = function (wex) {\\n  this.lworldExtX = wex;\\n};\\n\\nTransform.prototype.getWorldExtY = function () {\\n  return this.lworldExtY;\\n};\\n\\nTransform.prototype.setWorldExtY = function (wey) {\\n  this.lworldExtY = wey;\\n};\\n\\n/* Device related */\\n\\nTransform.prototype.getDeviceOrgX = function () {\\n  return this.ldeviceOrgX;\\n};\\n\\nTransform.prototype.setDeviceOrgX = function (dox) {\\n  this.ldeviceOrgX = dox;\\n};\\n\\nTransform.prototype.getDeviceOrgY = function () {\\n  return this.ldeviceOrgY;\\n};\\n\\nTransform.prototype.setDeviceOrgY = function (doy) {\\n  this.ldeviceOrgY = doy;\\n};\\n\\nTransform.prototype.getDeviceExtX = function () {\\n  return this.ldeviceExtX;\\n};\\n\\nTransform.prototype.setDeviceExtX = function (dex) {\\n  this.ldeviceExtX = dex;\\n};\\n\\nTransform.prototype.getDeviceExtY = function () {\\n  return this.ldeviceExtY;\\n};\\n\\nTransform.prototype.setDeviceExtY = function (dey) {\\n  this.ldeviceExtY = dey;\\n};\\n\\nTransform.prototype.transformX = function (x) {\\n  var xDevice = 0.0;\\n  var worldExtX = this.lworldExtX;\\n  if (worldExtX != 0.0) {\\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\\n  }\\n\\n  return xDevice;\\n};\\n\\nTransform.prototype.transformY = function (y) {\\n  var yDevice = 0.0;\\n  var worldExtY = this.lworldExtY;\\n  if (worldExtY != 0.0) {\\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\\n  }\\n\\n  return yDevice;\\n};\\n\\nTransform.prototype.inverseTransformX = function (x) {\\n  var xWorld = 0.0;\\n  var deviceExtX = this.ldeviceExtX;\\n  if (deviceExtX != 0.0) {\\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\\n  }\\n\\n  return xWorld;\\n};\\n\\nTransform.prototype.inverseTransformY = function (y) {\\n  var yWorld = 0.0;\\n  var deviceExtY = this.ldeviceExtY;\\n  if (deviceExtY != 0.0) {\\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\\n  }\\n  return yWorld;\\n};\\n\\nTransform.prototype.inverseTransformPoint = function (inPoint) {\\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\\n  return outPoint;\\n};\\n\\nmodule.exports = Transform;\\n\\n/***/ }),\\n/* 18 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\\n\\nvar Layout = __webpack_require__(15);\\nvar FDLayoutConstants = __webpack_require__(7);\\nvar LayoutConstants = __webpack_require__(0);\\nvar IGeometry = __webpack_require__(8);\\nvar IMath = __webpack_require__(9);\\n\\nfunction FDLayout() {\\n  Layout.call(this);\\n\\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\\n  this.totalDisplacement = 0.0;\\n  this.oldTotalDisplacement = 0.0;\\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\\n}\\n\\nFDLayout.prototype = Object.create(Layout.prototype);\\n\\nfor (var prop in Layout) {\\n  FDLayout[prop] = Layout[prop];\\n}\\n\\nFDLayout.prototype.initParameters = function () {\\n  Layout.prototype.initParameters.call(this, arguments);\\n\\n  this.totalIterations = 0;\\n  this.notAnimatedIterations = 0;\\n\\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\\n\\n  this.grid = [];\\n};\\n\\nFDLayout.prototype.calcIdealEdgeLengths = function () {\\n  var edge;\\n  var lcaDepth;\\n  var source;\\n  var target;\\n  var sizeOfSourceInLca;\\n  var sizeOfTargetInLca;\\n\\n  var allEdges = this.getGraphManager().getAllEdges();\\n  for (var i = 0; i < allEdges.length; i++) {\\n    edge = allEdges[i];\\n\\n    edge.idealLength = this.idealEdgeLength;\\n\\n    if (edge.isInterGraph) {\\n      source = edge.getSource();\\n      target = edge.getTarget();\\n\\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\\n\\n      if (this.useSmartIdealEdgeLengthCalculation) {\\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\\n      }\\n\\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\\n\\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\\n    }\\n  }\\n};\\n\\nFDLayout.prototype.initSpringEmbedder = function () {\\n\\n  var s = this.getAllNodes().length;\\n  if (this.incremental) {\\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\\n    }\\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\\n  } else {\\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\\n    } else {\\n      this.coolingFactor = 1.0;\\n    }\\n    this.initialCoolingFactor = this.coolingFactor;\\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\\n  }\\n\\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\\n\\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\\n\\n  this.repulsionRange = this.calcRepulsionRange();\\n};\\n\\nFDLayout.prototype.calcSpringForces = function () {\\n  var lEdges = this.getAllEdges();\\n  var edge;\\n\\n  for (var i = 0; i < lEdges.length; i++) {\\n    edge = lEdges[i];\\n\\n    this.calcSpringForce(edge, edge.idealLength);\\n  }\\n};\\n\\nFDLayout.prototype.calcRepulsionForces = function () {\\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n\\n  var i, j;\\n  var nodeA, nodeB;\\n  var lNodes = this.getAllNodes();\\n  var processedNodeSet;\\n\\n  if (this.useFRGridVariant) {\\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\\n      this.updateGrid();\\n    }\\n\\n    processedNodeSet = new Set();\\n\\n    // calculate repulsion forces between each nodes and its surrounding\\n    for (i = 0; i < lNodes.length; i++) {\\n      nodeA = lNodes[i];\\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\\n      processedNodeSet.add(nodeA);\\n    }\\n  } else {\\n    for (i = 0; i < lNodes.length; i++) {\\n      nodeA = lNodes[i];\\n\\n      for (j = i + 1; j < lNodes.length; j++) {\\n        nodeB = lNodes[j];\\n\\n        // If both nodes are not members of the same graph, skip.\\n        if (nodeA.getOwner() != nodeB.getOwner()) {\\n          continue;\\n        }\\n\\n        this.calcRepulsionForce(nodeA, nodeB);\\n      }\\n    }\\n  }\\n};\\n\\nFDLayout.prototype.calcGravitationalForces = function () {\\n  var node;\\n  var lNodes = this.getAllNodesToApplyGravitation();\\n\\n  for (var i = 0; i < lNodes.length; i++) {\\n    node = lNodes[i];\\n    this.calcGravitationalForce(node);\\n  }\\n};\\n\\nFDLayout.prototype.moveNodes = function () {\\n  var lNodes = this.getAllNodes();\\n  var node;\\n\\n  for (var i = 0; i < lNodes.length; i++) {\\n    node = lNodes[i];\\n    node.move();\\n  }\\n};\\n\\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\\n  var sourceNode = edge.getSource();\\n  var targetNode = edge.getTarget();\\n\\n  var length;\\n  var springForce;\\n  var springForceX;\\n  var springForceY;\\n\\n  // Update edge length\\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\\n    edge.updateLengthSimple();\\n  } else {\\n    edge.updateLength();\\n\\n    if (edge.isOverlapingSourceAndTarget) {\\n      return;\\n    }\\n  }\\n\\n  length = edge.getLength();\\n\\n  if (length == 0) return;\\n\\n  // Calculate spring forces\\n  springForce = this.springConstant * (length - idealLength);\\n\\n  // Project force onto x and y axes\\n  springForceX = springForce * (edge.lengthX / length);\\n  springForceY = springForce * (edge.lengthY / length);\\n\\n  // Apply forces on the end nodes\\n  sourceNode.springForceX += springForceX;\\n  sourceNode.springForceY += springForceY;\\n  targetNode.springForceX -= springForceX;\\n  targetNode.springForceY -= springForceY;\\n};\\n\\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\\n  var rectA = nodeA.getRect();\\n  var rectB = nodeB.getRect();\\n  var overlapAmount = new Array(2);\\n  var clipPoints = new Array(4);\\n  var distanceX;\\n  var distanceY;\\n  var distanceSquared;\\n  var distance;\\n  var repulsionForce;\\n  var repulsionForceX;\\n  var repulsionForceY;\\n\\n  if (rectA.intersects(rectB)) // two nodes overlap\\n    {\\n      // calculate separation amount in x and y directions\\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\\n\\n      repulsionForceX = 2 * overlapAmount[0];\\n      repulsionForceY = 2 * overlapAmount[1];\\n\\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\\n\\n      // Apply forces on the two nodes\\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\\n    } else // no overlap\\n    {\\n      // calculate distance\\n\\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\\n        {\\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\\n        } else // use clipping points\\n        {\\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\\n\\n          distanceX = clipPoints[2] - clipPoints[0];\\n          distanceY = clipPoints[3] - clipPoints[1];\\n        }\\n\\n      // No repulsion range. FR grid variant should take care of this.\\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\\n      }\\n\\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\\n      }\\n\\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\\n      distance = Math.sqrt(distanceSquared);\\n\\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\\n\\n      // Project force onto x and y axes\\n      repulsionForceX = repulsionForce * distanceX / distance;\\n      repulsionForceY = repulsionForce * distanceY / distance;\\n\\n      // Apply forces on the two nodes    \\n      nodeA.repulsionForceX -= repulsionForceX;\\n      nodeA.repulsionForceY -= repulsionForceY;\\n      nodeB.repulsionForceX += repulsionForceX;\\n      nodeB.repulsionForceY += repulsionForceY;\\n    }\\n};\\n\\nFDLayout.prototype.calcGravitationalForce = function (node) {\\n  var ownerGraph;\\n  var ownerCenterX;\\n  var ownerCenterY;\\n  var distanceX;\\n  var distanceY;\\n  var absDistanceX;\\n  var absDistanceY;\\n  var estimatedSize;\\n  ownerGraph = node.getOwner();\\n\\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\\n  distanceX = node.getCenterX() - ownerCenterX;\\n  distanceY = node.getCenterY() - ownerCenterY;\\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\\n\\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\\n    {\\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\\n\\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\\n        node.gravitationForceX = -this.gravityConstant * distanceX;\\n        node.gravitationForceY = -this.gravityConstant * distanceY;\\n      }\\n    } else // inside a compound\\n    {\\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\\n\\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\\n      }\\n    }\\n};\\n\\nFDLayout.prototype.isConverged = function () {\\n  var converged;\\n  var oscilating = false;\\n\\n  if (this.totalIterations > this.maxIterations / 3) {\\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\\n  }\\n\\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\\n\\n  this.oldTotalDisplacement = this.totalDisplacement;\\n\\n  return converged || oscilating;\\n};\\n\\nFDLayout.prototype.animate = function () {\\n  if (this.animationDuringLayout && !this.isSubLayout) {\\n    if (this.notAnimatedIterations == this.animationPeriod) {\\n      this.update();\\n      this.notAnimatedIterations = 0;\\n    } else {\\n      this.notAnimatedIterations++;\\n    }\\n  }\\n};\\n\\n//This method calculates the number of children (weight) for all nodes\\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\\n  var node;\\n  var allNodes = this.graphManager.getAllNodes();\\n\\n  for (var i = 0; i < allNodes.length; i++) {\\n    node = allNodes[i];\\n    node.noOfChildren = node.getNoOfChildren();\\n  }\\n};\\n\\n// -----------------------------------------------------------------------------\\n// Section: FR-Grid Variant Repulsion Force Calculation\\n// -----------------------------------------------------------------------------\\n\\nFDLayout.prototype.calcGrid = function (graph) {\\n\\n  var sizeX = 0;\\n  var sizeY = 0;\\n\\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\\n\\n  var grid = new Array(sizeX);\\n\\n  for (var i = 0; i < sizeX; i++) {\\n    grid[i] = new Array(sizeY);\\n  }\\n\\n  for (var i = 0; i < sizeX; i++) {\\n    for (var j = 0; j < sizeY; j++) {\\n      grid[i][j] = new Array();\\n    }\\n  }\\n\\n  return grid;\\n};\\n\\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\\n\\n  var startX = 0;\\n  var finishX = 0;\\n  var startY = 0;\\n  var finishY = 0;\\n\\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\\n\\n  for (var i = startX; i <= finishX; i++) {\\n    for (var j = startY; j <= finishY; j++) {\\n      this.grid[i][j].push(v);\\n      v.setGridCoordinates(startX, finishX, startY, finishY);\\n    }\\n  }\\n};\\n\\nFDLayout.prototype.updateGrid = function () {\\n  var i;\\n  var nodeA;\\n  var lNodes = this.getAllNodes();\\n\\n  this.grid = this.calcGrid(this.graphManager.getRoot());\\n\\n  // put all nodes to proper grid cells\\n  for (i = 0; i < lNodes.length; i++) {\\n    nodeA = lNodes[i];\\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\\n  }\\n};\\n\\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\\n\\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\\n    var surrounding = new Set();\\n    nodeA.surrounding = new Array();\\n    var nodeB;\\n    var grid = this.grid;\\n\\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\\n          for (var k = 0; k < grid[i][j].length; k++) {\\n            nodeB = grid[i][j][k];\\n\\n            // If both nodes are not members of the same graph, \\n            // or both nodes are the same, skip.\\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\\n              continue;\\n            }\\n\\n            // check if the repulsion force between\\n            // nodeA and nodeB has already been calculated\\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\\n\\n              // if the distance between nodeA and nodeB \\n              // is less then calculation range\\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\\n                //then add nodeB to surrounding of nodeA\\n                surrounding.add(nodeB);\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\\n  }\\n  for (i = 0; i < nodeA.surrounding.length; i++) {\\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\\n  }\\n};\\n\\nFDLayout.prototype.calcRepulsionRange = function () {\\n  return 0.0;\\n};\\n\\nmodule.exports = FDLayout;\\n\\n/***/ }),\\n/* 19 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar LEdge = __webpack_require__(1);\\nvar FDLayoutConstants = __webpack_require__(7);\\n\\nfunction FDLayoutEdge(source, target, vEdge) {\\n  LEdge.call(this, source, target, vEdge);\\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\\n}\\n\\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\\n\\nfor (var prop in LEdge) {\\n  FDLayoutEdge[prop] = LEdge[prop];\\n}\\n\\nmodule.exports = FDLayoutEdge;\\n\\n/***/ }),\\n/* 20 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar LNode = __webpack_require__(3);\\n\\nfunction FDLayoutNode(gm, loc, size, vNode) {\\n  // alternative constructor is handled inside LNode\\n  LNode.call(this, gm, loc, size, vNode);\\n  //Spring, repulsion and gravitational forces acting on this node\\n  this.springForceX = 0;\\n  this.springForceY = 0;\\n  this.repulsionForceX = 0;\\n  this.repulsionForceY = 0;\\n  this.gravitationForceX = 0;\\n  this.gravitationForceY = 0;\\n  //Amount by which this node is to be moved in this iteration\\n  this.displacementX = 0;\\n  this.displacementY = 0;\\n\\n  //Start and finish grid coordinates that this node is fallen into\\n  this.startX = 0;\\n  this.finishX = 0;\\n  this.startY = 0;\\n  this.finishY = 0;\\n\\n  //Geometric neighbors of this node\\n  this.surrounding = [];\\n}\\n\\nFDLayoutNode.prototype = Object.create(LNode.prototype);\\n\\nfor (var prop in LNode) {\\n  FDLayoutNode[prop] = LNode[prop];\\n}\\n\\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\\n  this.startX = _startX;\\n  this.finishX = _finishX;\\n  this.startY = _startY;\\n  this.finishY = _finishY;\\n};\\n\\nmodule.exports = FDLayoutNode;\\n\\n/***/ }),\\n/* 21 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction DimensionD(width, height) {\\n  this.width = 0;\\n  this.height = 0;\\n  if (width !== null && height !== null) {\\n    this.height = height;\\n    this.width = width;\\n  }\\n}\\n\\nDimensionD.prototype.getWidth = function () {\\n  return this.width;\\n};\\n\\nDimensionD.prototype.setWidth = function (width) {\\n  this.width = width;\\n};\\n\\nDimensionD.prototype.getHeight = function () {\\n  return this.height;\\n};\\n\\nDimensionD.prototype.setHeight = function (height) {\\n  this.height = height;\\n};\\n\\nmodule.exports = DimensionD;\\n\\n/***/ }),\\n/* 22 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar UniqueIDGeneretor = __webpack_require__(14);\\n\\nfunction HashMap() {\\n  this.map = {};\\n  this.keys = [];\\n}\\n\\nHashMap.prototype.put = function (key, value) {\\n  var theId = UniqueIDGeneretor.createID(key);\\n  if (!this.contains(theId)) {\\n    this.map[theId] = value;\\n    this.keys.push(key);\\n  }\\n};\\n\\nHashMap.prototype.contains = function (key) {\\n  var theId = UniqueIDGeneretor.createID(key);\\n  return this.map[key] != null;\\n};\\n\\nHashMap.prototype.get = function (key) {\\n  var theId = UniqueIDGeneretor.createID(key);\\n  return this.map[theId];\\n};\\n\\nHashMap.prototype.keySet = function () {\\n  return this.keys;\\n};\\n\\nmodule.exports = HashMap;\\n\\n/***/ }),\\n/* 23 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar UniqueIDGeneretor = __webpack_require__(14);\\n\\nfunction HashSet() {\\n  this.set = {};\\n}\\n;\\n\\nHashSet.prototype.add = function (obj) {\\n  var theId = UniqueIDGeneretor.createID(obj);\\n  if (!this.contains(theId)) this.set[theId] = obj;\\n};\\n\\nHashSet.prototype.remove = function (obj) {\\n  delete this.set[UniqueIDGeneretor.createID(obj)];\\n};\\n\\nHashSet.prototype.clear = function () {\\n  this.set = {};\\n};\\n\\nHashSet.prototype.contains = function (obj) {\\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\\n};\\n\\nHashSet.prototype.isEmpty = function () {\\n  return this.size() === 0;\\n};\\n\\nHashSet.prototype.size = function () {\\n  return Object.keys(this.set).length;\\n};\\n\\n//concats this.set to the given list\\nHashSet.prototype.addAllTo = function (list) {\\n  var keys = Object.keys(this.set);\\n  var length = keys.length;\\n  for (var i = 0; i < length; i++) {\\n    list.push(this.set[keys[i]]);\\n  }\\n};\\n\\nHashSet.prototype.size = function () {\\n  return Object.keys(this.set).length;\\n};\\n\\nHashSet.prototype.addAll = function (list) {\\n  var s = list.length;\\n  for (var i = 0; i < s; i++) {\\n    var v = list[i];\\n    this.add(v);\\n  }\\n};\\n\\nmodule.exports = HashSet;\\n\\n/***/ }),\\n/* 24 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/**\\n * A classic Quicksort algorithm with Hoare's partition\\n * - Works also on LinkedList objects\\n *\\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\\n */\\n\\nvar LinkedList = __webpack_require__(11);\\n\\nvar Quicksort = function () {\\n    function Quicksort(A, compareFunction) {\\n        _classCallCheck(this, Quicksort);\\n\\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\\n\\n        var length = void 0;\\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\\n\\n        this._quicksort(A, 0, length - 1);\\n    }\\n\\n    _createClass(Quicksort, [{\\n        key: '_quicksort',\\n        value: function _quicksort(A, p, r) {\\n            if (p < r) {\\n                var q = this._partition(A, p, r);\\n                this._quicksort(A, p, q);\\n                this._quicksort(A, q + 1, r);\\n            }\\n        }\\n    }, {\\n        key: '_partition',\\n        value: function _partition(A, p, r) {\\n            var x = this._get(A, p);\\n            var i = p;\\n            var j = r;\\n            while (true) {\\n                while (this.compareFunction(x, this._get(A, j))) {\\n                    j--;\\n                }while (this.compareFunction(this._get(A, i), x)) {\\n                    i++;\\n                }if (i < j) {\\n                    this._swap(A, i, j);\\n                    i++;\\n                    j--;\\n                } else return j;\\n            }\\n        }\\n    }, {\\n        key: '_get',\\n        value: function _get(object, index) {\\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\\n        }\\n    }, {\\n        key: '_set',\\n        value: function _set(object, index, value) {\\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\\n        }\\n    }, {\\n        key: '_swap',\\n        value: function _swap(A, i, j) {\\n            var temp = this._get(A, i);\\n            this._set(A, i, this._get(A, j));\\n            this._set(A, j, temp);\\n        }\\n    }, {\\n        key: '_defaultCompareFunction',\\n        value: function _defaultCompareFunction(a, b) {\\n            return b > a;\\n        }\\n    }]);\\n\\n    return Quicksort;\\n}();\\n\\nmodule.exports = Quicksort;\\n\\n/***/ }),\\n/* 25 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n/**\\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\\n *\\n *   Aside from the inputs, you can assign the scores for,\\n *   - Match: The two characters at the current index are same.\\n *   - Mismatch: The two characters at the current index are different.\\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\\n */\\n\\nvar NeedlemanWunsch = function () {\\n    function NeedlemanWunsch(sequence1, sequence2) {\\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\\n\\n        _classCallCheck(this, NeedlemanWunsch);\\n\\n        this.sequence1 = sequence1;\\n        this.sequence2 = sequence2;\\n        this.match_score = match_score;\\n        this.mismatch_penalty = mismatch_penalty;\\n        this.gap_penalty = gap_penalty;\\n\\n        // Just the remove redundancy\\n        this.iMax = sequence1.length + 1;\\n        this.jMax = sequence2.length + 1;\\n\\n        // Grid matrix of scores\\n        this.grid = new Array(this.iMax);\\n        for (var i = 0; i < this.iMax; i++) {\\n            this.grid[i] = new Array(this.jMax);\\n\\n            for (var j = 0; j < this.jMax; j++) {\\n                this.grid[i][j] = 0;\\n            }\\n        }\\n\\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\\n        this.tracebackGrid = new Array(this.iMax);\\n        for (var _i = 0; _i < this.iMax; _i++) {\\n            this.tracebackGrid[_i] = new Array(this.jMax);\\n\\n            for (var _j = 0; _j < this.jMax; _j++) {\\n                this.tracebackGrid[_i][_j] = [null, null, null];\\n            }\\n        }\\n\\n        // The aligned sequences (return multiple possibilities)\\n        this.alignments = [];\\n\\n        // Final alignment score\\n        this.score = -1;\\n\\n        // Calculate scores and tracebacks\\n        this.computeGrids();\\n    }\\n\\n    _createClass(NeedlemanWunsch, [{\\n        key: \\\"getScore\\\",\\n        value: function getScore() {\\n            return this.score;\\n        }\\n    }, {\\n        key: \\\"getAlignments\\\",\\n        value: function getAlignments() {\\n            return this.alignments;\\n        }\\n\\n        // Main dynamic programming procedure\\n\\n    }, {\\n        key: \\\"computeGrids\\\",\\n        value: function computeGrids() {\\n            // Fill in the first row\\n            for (var j = 1; j < this.jMax; j++) {\\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\\n                this.tracebackGrid[0][j] = [false, false, true];\\n            }\\n\\n            // Fill in the first column\\n            for (var i = 1; i < this.iMax; i++) {\\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\\n                this.tracebackGrid[i][0] = [false, true, false];\\n            }\\n\\n            // Fill the rest of the grid\\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\\n                    var diag = void 0;\\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\\n\\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\\n\\n                    // If there exists multiple max values, capture them for multiple paths\\n                    var maxOf = [diag, up, left];\\n                    var indices = this.arrayAllMaxIndexes(maxOf);\\n\\n                    // Update Grids\\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\\n                }\\n            }\\n\\n            // Update alignment score\\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\\n        }\\n\\n        // Gets all possible valid sequence combinations\\n\\n    }, {\\n        key: \\\"alignmentTraceback\\\",\\n        value: function alignmentTraceback() {\\n            var inProcessAlignments = [];\\n\\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\\n                seq1: \\\"\\\",\\n                seq2: \\\"\\\"\\n            });\\n\\n            while (inProcessAlignments[0]) {\\n                var current = inProcessAlignments[0];\\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\\n\\n                if (directions[0]) {\\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\\n                    });\\n                }\\n                if (directions[1]) {\\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\\n                        seq2: '-' + current.seq2\\n                    });\\n                }\\n                if (directions[2]) {\\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\\n                        seq1: '-' + current.seq1,\\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\\n                    });\\n                }\\n\\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\\n                    sequence2: current.seq2\\n                });\\n\\n                inProcessAlignments.shift();\\n            }\\n\\n            return this.alignments;\\n        }\\n\\n        // Helper Functions\\n\\n    }, {\\n        key: \\\"getAllIndexes\\\",\\n        value: function getAllIndexes(arr, val) {\\n            var indexes = [],\\n                i = -1;\\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\\n                indexes.push(i);\\n            }\\n            return indexes;\\n        }\\n    }, {\\n        key: \\\"arrayAllMaxIndexes\\\",\\n        value: function arrayAllMaxIndexes(array) {\\n            return this.getAllIndexes(array, Math.max.apply(null, array));\\n        }\\n    }]);\\n\\n    return NeedlemanWunsch;\\n}();\\n\\nmodule.exports = NeedlemanWunsch;\\n\\n/***/ }),\\n/* 26 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nvar layoutBase = function layoutBase() {\\n  return;\\n};\\n\\nlayoutBase.FDLayout = __webpack_require__(18);\\nlayoutBase.FDLayoutConstants = __webpack_require__(7);\\nlayoutBase.FDLayoutEdge = __webpack_require__(19);\\nlayoutBase.FDLayoutNode = __webpack_require__(20);\\nlayoutBase.DimensionD = __webpack_require__(21);\\nlayoutBase.HashMap = __webpack_require__(22);\\nlayoutBase.HashSet = __webpack_require__(23);\\nlayoutBase.IGeometry = __webpack_require__(8);\\nlayoutBase.IMath = __webpack_require__(9);\\nlayoutBase.Integer = __webpack_require__(10);\\nlayoutBase.Point = __webpack_require__(12);\\nlayoutBase.PointD = __webpack_require__(4);\\nlayoutBase.RandomSeed = __webpack_require__(16);\\nlayoutBase.RectangleD = __webpack_require__(13);\\nlayoutBase.Transform = __webpack_require__(17);\\nlayoutBase.UniqueIDGeneretor = __webpack_require__(14);\\nlayoutBase.Quicksort = __webpack_require__(24);\\nlayoutBase.LinkedList = __webpack_require__(11);\\nlayoutBase.LGraphObject = __webpack_require__(2);\\nlayoutBase.LGraph = __webpack_require__(5);\\nlayoutBase.LEdge = __webpack_require__(1);\\nlayoutBase.LGraphManager = __webpack_require__(6);\\nlayoutBase.LNode = __webpack_require__(3);\\nlayoutBase.Layout = __webpack_require__(15);\\nlayoutBase.LayoutConstants = __webpack_require__(0);\\nlayoutBase.NeedlemanWunsch = __webpack_require__(25);\\n\\nmodule.exports = layoutBase;\\n\\n/***/ }),\\n/* 27 */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\n\\nfunction Emitter() {\\n  this.listeners = [];\\n}\\n\\nvar p = Emitter.prototype;\\n\\np.addListener = function (event, callback) {\\n  this.listeners.push({\\n    event: event,\\n    callback: callback\\n  });\\n};\\n\\np.removeListener = function (event, callback) {\\n  for (var i = this.listeners.length; i >= 0; i--) {\\n    var l = this.listeners[i];\\n\\n    if (l.event === event && l.callback === callback) {\\n      this.listeners.splice(i, 1);\\n    }\\n  }\\n};\\n\\np.emit = function (event, data) {\\n  for (var i = 0; i < this.listeners.length; i++) {\\n    var l = this.listeners[i];\\n\\n    if (event === l.event) {\\n      l.callback(data);\\n    }\\n  }\\n};\\n\\nmodule.exports = Emitter;\\n\\n/***/ })\\n/******/ ]);\\n});\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"webpackUniversalModuleDefinition\",\"root\",\"factory\",\"define\",\"amd\",\"modules\",\"__webpack_require__\",\"moduleId\",\"installedModules\",\"i\",\"l\",\"call\",\"m\",\"c\",\"__webpack_require__.i\",\"value\",\"d\",\"__webpack_require__.d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"configurable\",\"enumerable\",\"get\",\"n\",\"__webpack_require__.n\",\"__esModule\",\"getDefault\",\"getModuleExports\",\"__webpack_require__.o\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"LayoutConstants\",\"QUALITY\",\"DEFAULT_CREATE_BENDS_AS_NEEDED\",\"DEFAULT_INCREMENTAL\",\"DEFAULT_ANIMATION_ON_LAYOUT\",\"DEFAULT_ANIMATION_DURING_LAYOUT\",\"DEFAULT_ANIMATION_PERIOD\",\"DEFAULT_UNIFORM_LEAF_NODE_SIZES\",\"DEFAULT_GRAPH_MARGIN\",\"NODE_DIMENSIONS_INCLUDE_LABELS\",\"SIMPLE_NODE_SIZE\",\"SIMPLE_NODE_HALF_SIZE\",\"EMPTY_COMPOUND_NODE_SIZE\",\"MIN_EDGE_LENGTH\",\"WORLD_BOUNDARY\",\"INITIAL_WORLD_BOUNDARY\",\"WORLD_CENTER_X\",\"WORLD_CENTER_Y\",\"LEdge\",\"source\",\"target\",\"vEdge\",\"LGraphObject\",\"isOverlapingSourceAndTarget\",\"vGraphObject\",\"bendpoints\",\"IGeometry\",\"IMath\",\"create\",\"prop\",\"getSource\",\"LEdge.prototype.getSource\",\"getTarget\",\"LEdge.prototype.getTarget\",\"isInterGraph\",\"LEdge.prototype.isInterGraph\",\"getLength\",\"LEdge.prototype.getLength\",\"length\",\"LEdge.prototype.isOverlapingSourceAndTarget\",\"getBendpoints\",\"LEdge.prototype.getBendpoints\",\"getLca\",\"LEdge.prototype.getLca\",\"lca\",\"getSourceInLca\",\"LEdge.prototype.getSourceInLca\",\"sourceInLca\",\"getTargetInLca\",\"LEdge.prototype.getTargetInLca\",\"targetInLca\",\"getOtherEnd\",\"LEdge.prototype.getOtherEnd\",\"node\",\"getOtherEndInGraph\",\"LEdge.prototype.getOtherEndInGraph\",\"graph\",\"otherEnd\",\"getGraphManager\",\"getRoot\",\"getOwner\",\"getParent\",\"updateLength\",\"LEdge.prototype.updateLength\",\"clipPointCoordinates\",\"Array\",\"getIntersection\",\"getRect\",\"lengthX\",\"lengthY\",\"Math\",\"abs\",\"sign\",\"sqrt\",\"updateLengthSimple\",\"LEdge.prototype.updateLengthSimple\",\"getCenterX\",\"getCenterY\",\"LNode\",\"gm\",\"loc\",\"size\",\"vNode\",\"graphManager\",\"estimatedSize\",\"Integer\",\"MIN_VALUE\",\"inclusionTreeDepth\",\"MAX_VALUE\",\"edges\",\"rect\",\"RectangleD\",\"x\",\"y\",\"width\",\"height\",\"RandomSeed\",\"PointD\",\"getEdges\",\"LNode.prototype.getEdges\",\"getChild\",\"LNode.prototype.getChild\",\"child\",\"LNode.prototype.getOwner\",\"owner\",\"getWidth\",\"LNode.prototype.getWidth\",\"setWidth\",\"LNode.prototype.setWidth\",\"getHeight\",\"LNode.prototype.getHeight\",\"setHeight\",\"LNode.prototype.setHeight\",\"LNode.prototype.getCenterX\",\"LNode.prototype.getCenterY\",\"getCenter\",\"LNode.prototype.getCenter\",\"getLocation\",\"LNode.prototype.getLocation\",\"LNode.prototype.getRect\",\"getDiagonal\",\"LNode.prototype.getDiagonal\",\"getHalfTheDiagonal\",\"LNode.prototype.getHalfTheDiagonal\",\"setRect\",\"LNode.prototype.setRect\",\"upperLeft\",\"dimension\",\"setCenter\",\"LNode.prototype.setCenter\",\"cx\",\"cy\",\"setLocation\",\"LNode.prototype.setLocation\",\"moveBy\",\"LNode.prototype.moveBy\",\"dx\",\"dy\",\"getEdgeListToNode\",\"LNode.prototype.getEdgeListToNode\",\"to\",\"edgeList\",\"self\",\"forEach\",\"edge\",\"push\",\"getEdgesBetween\",\"LNode.prototype.getEdgesBetween\",\"other\",\"getNeighborsList\",\"LNode.prototype.getNeighborsList\",\"neighbors\",\"Set\",\"add\",\"withChildren\",\"LNode.prototype.withChildren\",\"withNeighborsList\",\"nodes\",\"getNodes\",\"childNode\",\"children\",\"getNoOfChildren\",\"LNode.prototype.getNoOfChildren\",\"noOfChildren\",\"getEstimatedSize\",\"LNode.prototype.getEstimatedSize\",\"calcEstimatedSize\",\"LNode.prototype.calcEstimatedSize\",\"scatter\",\"LNode.prototype.scatter\",\"minX\",\"maxX\",\"randomCenterX\",\"nextDouble\",\"minY\",\"maxY\",\"randomCenterY\",\"updateBounds\",\"LNode.prototype.updateBounds\",\"childGraph\",\"getLeft\",\"getTop\",\"getRight\",\"getBottom\",\"labelWidth\",\"labelHeight\",\"labelPos\",\"getInclusionTreeDepth\",\"LNode.prototype.getInclusionTreeDepth\",\"transform\",\"LNode.prototype.transform\",\"trans\",\"left\",\"top\",\"leftTop\",\"vLeftTop\",\"inverseTransformPoint\",\"LNode.prototype.getLeft\",\"LNode.prototype.getRight\",\"LNode.prototype.getTop\",\"LNode.prototype.getBottom\",\"LNode.prototype.getParent\",\"getX\",\"PointD.prototype.getX\",\"getY\",\"PointD.prototype.getY\",\"setX\",\"PointD.prototype.setX\",\"setY\",\"PointD.prototype.setY\",\"getDifference\",\"PointD.prototype.getDifference\",\"pt\",\"DimensionD\",\"getCopy\",\"PointD.prototype.getCopy\",\"translate\",\"PointD.prototype.translate\",\"dim\",\"LGraph\",\"parent\",\"obj2\",\"vGraph\",\"margin\",\"isConnected\",\"LGraphManager\",\"Layout\",\"Point\",\"LinkedList\",\"LGraph.prototype.getNodes\",\"LGraph.prototype.getEdges\",\"LGraph.prototype.getGraphManager\",\"LGraph.prototype.getParent\",\"LGraph.prototype.getLeft\",\"LGraph.prototype.getRight\",\"right\",\"LGraph.prototype.getTop\",\"LGraph.prototype.getBottom\",\"bottom\",\"LGraph.prototype.isConnected\",\"LGraph.prototype.add\",\"obj1\",\"sourceNode\",\"targetNode\",\"indexOf\",\"remove\",\"LGraph.prototype.remove\",\"obj\",\"edgesToBeRemoved\",\"slice\",\"index\",\"splice\",\"sourceIndex\",\"targetIndex\",\"updateLeftTop\",\"LGraph.prototype.updateLeftTop\",\"nodeTop\",\"nodeLeft\",\"lNode\",\"undefined\",\"paddingLeft\",\"LGraph.prototype.updateBounds\",\"recursive\",\"nodeRight\",\"nodeBottom\",\"boundingRect\",\"calculateBounds\",\"LGraph.calculateBounds\",\"LGraph.prototype.getInclusionTreeDepth\",\"LGraph.prototype.getEstimatedSize\",\"LGraph.prototype.calcEstimatedSize\",\"updateConnected\",\"LGraph.prototype.updateConnected\",\"queue\",\"visited\",\"currentNode\",\"childrenOfNode\",\"shift\",\"neighborEdges\",\"currentNeighbor\",\"neighborEdge\",\"has\",\"childrenOfNeighbor\",\"noOfVisitedInThisGraph\",\"visitedNode\",\"layout\",\"graphs\",\"addRoot\",\"LGraphManager.prototype.addRoot\",\"ngraph\",\"newGraph\",\"nnode\",\"newNode\",\"setRootGraph\",\"rootGraph\",\"LGraphManager.prototype.add\",\"parentNode\",\"newEdge\",\"sourceGraph\",\"targetGraph\",\"LGraphManager.prototype.remove\",\"lObj\",\"concat\",\"nodesToBeRemoved\",\"LGraphManager.prototype.updateBounds\",\"getGraphs\",\"LGraphManager.prototype.getGraphs\",\"getAllNodes\",\"LGraphManager.prototype.getAllNodes\",\"allNodes\",\"nodeList\",\"resetAllNodes\",\"LGraphManager.prototype.resetAllNodes\",\"resetAllEdges\",\"LGraphManager.prototype.resetAllEdges\",\"allEdges\",\"resetAllNodesToApplyGravitation\",\"LGraphManager.prototype.resetAllNodesToApplyGravitation\",\"allNodesToApplyGravitation\",\"getAllEdges\",\"LGraphManager.prototype.getAllEdges\",\"getAllNodesToApplyGravitation\",\"LGraphManager.prototype.getAllNodesToApplyGravitation\",\"setAllNodesToApplyGravitation\",\"LGraphManager.prototype.setAllNodesToApplyGravitation\",\"LGraphManager.prototype.getRoot\",\"LGraphManager.prototype.setRootGraph\",\"getLayout\",\"LGraphManager.prototype.getLayout\",\"isOneAncestorOfOther\",\"LGraphManager.prototype.isOneAncestorOfOther\",\"firstNode\",\"secondNode\",\"ownerGraph\",\"calcLowestCommonAncestors\",\"LGraphManager.prototype.calcLowestCommonAncestors\",\"targetAncestorGraph\",\"sourceAncestorGraph\",\"calcLowestCommonAncestor\",\"LGraphManager.prototype.calcLowestCommonAncestor\",\"firstOwnerGraph\",\"secondOwnerGraph\",\"calcInclusionTreeDepths\",\"LGraphManager.prototype.calcInclusionTreeDepths\",\"depth\",\"includesInvalidEdge\",\"LGraphManager.prototype.includesInvalidEdge\",\"FDLayoutConstants\",\"MAX_ITERATIONS\",\"DEFAULT_EDGE_LENGTH\",\"DEFAULT_SPRING_STRENGTH\",\"DEFAULT_REPULSION_STRENGTH\",\"DEFAULT_GRAVITY_STRENGTH\",\"DEFAULT_COMPOUND_GRAVITY_STRENGTH\",\"DEFAULT_GRAVITY_RANGE_FACTOR\",\"DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR\",\"DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION\",\"DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION\",\"DEFAULT_COOLING_FACTOR_INCREMENTAL\",\"COOLING_ADAPTATION_FACTOR\",\"ADAPTATION_LOWER_NODE_LIMIT\",\"ADAPTATION_UPPER_NODE_LIMIT\",\"MAX_NODE_DISPLACEMENT_INCREMENTAL\",\"MAX_NODE_DISPLACEMENT\",\"MIN_REPULSION_DIST\",\"CONVERGENCE_CHECK_PERIOD\",\"PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR\",\"GRID_CALCULATION_CHECK_PERIOD\",\"calcSeparationAmount\",\"IGeometry.calcSeparationAmount\",\"rectA\",\"rectB\",\"overlapAmount\",\"separationBuffer\",\"intersects\",\"directions\",\"decideDirectionsForOverlappingNodes\",\"min\",\"max\",\"slope\",\"moveByY\",\"moveByX\",\"IGeometry.decideDirectionsForOverlappingNodes\",\"getIntersection2\",\"IGeometry.getIntersection2\",\"result\",\"p1x\",\"p1y\",\"p2x\",\"p2y\",\"topLeftAx\",\"topLeftAy\",\"topRightAx\",\"bottomLeftAx\",\"bottomLeftAy\",\"bottomRightAx\",\"halfWidthA\",\"getWidthHalf\",\"halfHeightA\",\"getHeightHalf\",\"topLeftBx\",\"topLeftBy\",\"topRightBx\",\"bottomLeftBx\",\"bottomLeftBy\",\"bottomRightBx\",\"halfWidthB\",\"halfHeightB\",\"clipPointAFound\",\"clipPointBFound\",\"slopeA\",\"slopeB\",\"slopePrime\",\"cardinalDirectionA\",\"getCardinalDirection\",\"cardinalDirectionB\",\"IGeometry.getCardinalDirection\",\"line\",\"IGeometry.getIntersection\",\"s1\",\"s2\",\"f1\",\"f2\",\"x1\",\"y1\",\"x2\",\"y2\",\"x3\",\"y3\",\"x4\",\"y4\",\"a1\",\"b1\",\"c1\",\"a2\",\"b2\",\"c2\",\"denom\",\"angleOfVector\",\"IGeometry.angleOfVector\",\"Cx\",\"Cy\",\"Nx\",\"Ny\",\"C_angle\",\"atan\",\"PI\",\"TWO_PI\",\"ONE_AND_HALF_PI\",\"HALF_PI\",\"doIntersect\",\"IGeometry.doIntersect\",\"p1\",\"p2\",\"p3\",\"p4\",\"a\",\"b\",\"q\",\"r\",\"det\",\"lambda\",\"gamma\",\"THREE_PI\",\"IMath.sign\",\"floor\",\"IMath.floor\",\"ceil\",\"IMath.ceil\",\"_createClass\",\"defineProperties\",\"props\",\"descriptor\",\"writable\",\"key\",\"Constructor\",\"protoProps\",\"staticProps\",\"nodeFrom\",\"next\",\"prev\",\"list\",\"head\",\"tail\",\"_remove\",\"vals\",\"_this\",\"instance\",\"TypeError\",\"v\",\"insertBefore\",\"val\",\"otherNode\",\"insertAfter\",\"insertNodeBefore\",\"insertNodeAfter\",\"unshift\",\"pop\",\"popNode\",\"shiftNode\",\"get_object_at\",\"current\",\"set_object_at\",\"constructor\",\"Point.prototype.getX\",\"Point.prototype.getY\",\"Point.prototype.getLocation\",\"Point.prototype.setLocation\",\"parseInt\",\"move\",\"Point.prototype.move\",\"Point.prototype.translate\",\"equals\",\"Point.prototype.equals\",\"toString\",\"Point.prototype.toString\",\"RectangleD.prototype.getX\",\"RectangleD.prototype.setX\",\"RectangleD.prototype.getY\",\"RectangleD.prototype.setY\",\"RectangleD.prototype.getWidth\",\"RectangleD.prototype.setWidth\",\"RectangleD.prototype.getHeight\",\"RectangleD.prototype.setHeight\",\"RectangleD.prototype.getRight\",\"RectangleD.prototype.getBottom\",\"RectangleD.prototype.intersects\",\"RectangleD.prototype.getCenterX\",\"getMinX\",\"RectangleD.prototype.getMinX\",\"getMaxX\",\"RectangleD.prototype.getMaxX\",\"RectangleD.prototype.getCenterY\",\"getMinY\",\"RectangleD.prototype.getMinY\",\"getMaxY\",\"RectangleD.prototype.getMaxY\",\"RectangleD.prototype.getWidthHalf\",\"RectangleD.prototype.getHeightHalf\",\"UniqueIDGeneretor\",\"_typeof\",\"Symbol\",\"iterator\",\"lastID\",\"createID\",\"UniqueIDGeneretor.createID\",\"isPrimitive\",\"uniqueID\",\"getString\",\"UniqueIDGeneretor.getString\",\"id\",\"UniqueIDGeneretor.isPrimitive\",\"arg\",\"type\",\"_toConsumableArray\",\"arr\",\"isArray\",\"arr2\",\"from\",\"isRemoteUse\",\"Emitter\",\"layoutQuality\",\"createBendsAsNeeded\",\"incremental\",\"animationOnLayout\",\"animationDuringLayout\",\"animationPeriod\",\"uniformLeafNodeSizes\",\"edgeToDummyNodes\",\"Map\",\"isSubLayout\",\"isLayoutFinished\",\"Transform\",\"RANDOM_SEED\",\"Layout.prototype.getGraphManager\",\"Layout.prototype.getAllNodes\",\"Layout.prototype.getAllEdges\",\"Layout.prototype.getAllNodesToApplyGravitation\",\"newGraphManager\",\"Layout.prototype.newGraphManager\",\"Layout.prototype.newGraph\",\"Layout.prototype.newNode\",\"Layout.prototype.newEdge\",\"checkLayoutSuccess\",\"Layout.prototype.checkLayoutSuccess\",\"runLayout\",\"Layout.prototype.runLayout\",\"tilingPreLayout\",\"initParameters\",\"isLayoutSuccessfull\",\"ANIMATE\",\"doPostLayout\",\"tilingPostLayout\",\"Layout.prototype.doPostLayout\",\"update\",\"update2\",\"Layout.prototype.update2\",\"createBendpointsFromDummyNodes\",\"Layout.prototype.update\",\"Layout.prototype.initParameters\",\"Layout.prototype.transform\",\"newLeftTop\",\"setWorldOrgX\",\"setWorldOrgY\",\"setDeviceOrgX\",\"setDeviceOrgY\",\"positionNodesRandomly\",\"Layout.prototype.positionNodesRandomly\",\"getFlatForest\",\"Layout.prototype.getFlatForest\",\"flatForest\",\"isForest\",\"isFlat\",\"toBeVisited\",\"parents\",\"unProcessedNodes\",\"set\",\"temp\",\"createDummyNodesForBendpoints\",\"Layout.prototype.createDummyNodesForBendpoints\",\"dummyNodes\",\"dummyNode\",\"Dimension\",\"dummyEdge\",\"Layout.prototype.createBendpointsFromDummyNodes\",\"keys\",\"k\",\"lEdge\",\"path\",\"ebp\",\"Layout.transform\",\"sliderValue\",\"defaultValue\",\"minDiv\",\"maxMul\",\"findCenterOfTree\",\"Layout.findCenterOfTree\",\"removedNodes\",\"remainingDegrees\",\"foundCenter\",\"centerNode\",\"degree\",\"tempList\",\"tempList2\",\"neighbours\",\"neighbour\",\"newDegree\",\"otherDegree\",\"setGraphManager\",\"Layout.prototype.setGraphManager\",\"seed\",\"RandomSeed.nextDouble\",\"sin\",\"ldeviceOrgY\",\"ldeviceOrgX\",\"lworldOrgY\",\"lworldOrgX\",\"ldeviceExtY\",\"ldeviceExtX\",\"lworldExtY\",\"lworldExtX\",\"getWorldOrgX\",\"Transform.prototype.getWorldOrgX\",\"Transform.prototype.setWorldOrgX\",\"wox\",\"getWorldOrgY\",\"Transform.prototype.getWorldOrgY\",\"Transform.prototype.setWorldOrgY\",\"woy\",\"getWorldExtX\",\"Transform.prototype.getWorldExtX\",\"setWorldExtX\",\"Transform.prototype.setWorldExtX\",\"wex\",\"getWorldExtY\",\"Transform.prototype.getWorldExtY\",\"setWorldExtY\",\"Transform.prototype.setWorldExtY\",\"wey\",\"getDeviceOrgX\",\"Transform.prototype.getDeviceOrgX\",\"Transform.prototype.setDeviceOrgX\",\"dox\",\"getDeviceOrgY\",\"Transform.prototype.getDeviceOrgY\",\"Transform.prototype.setDeviceOrgY\",\"doy\",\"getDeviceExtX\",\"Transform.prototype.getDeviceExtX\",\"setDeviceExtX\",\"Transform.prototype.setDeviceExtX\",\"dex\",\"getDeviceExtY\",\"Transform.prototype.getDeviceExtY\",\"setDeviceExtY\",\"Transform.prototype.setDeviceExtY\",\"dey\",\"transformX\",\"Transform.prototype.transformX\",\"xDevice\",\"worldExtX\",\"transformY\",\"Transform.prototype.transformY\",\"yDevice\",\"worldExtY\",\"inverseTransformX\",\"Transform.prototype.inverseTransformX\",\"xWorld\",\"deviceExtX\",\"inverseTransformY\",\"Transform.prototype.inverseTransformY\",\"yWorld\",\"deviceExtY\",\"Transform.prototype.inverseTransformPoint\",\"inPoint\",\"outPoint\",\"FDLayout\",\"useSmartIdealEdgeLengthCalculation\",\"idealEdgeLength\",\"springConstant\",\"repulsionConstant\",\"gravityConstant\",\"compoundGravityConstant\",\"gravityRangeFactor\",\"compoundGravityRangeFactor\",\"displacementThresholdPerNode\",\"initialCoolingFactor\",\"coolingFactor\",\"oldTotalDisplacement\",\"totalDisplacement\",\"maxIterations\",\"FDLayout.prototype.initParameters\",\"arguments\",\"notAnimatedIterations\",\"totalIterations\",\"useFRGridVariant\",\"grid\",\"calcIdealEdgeLengths\",\"FDLayout.prototype.calcIdealEdgeLengths\",\"lcaDepth\",\"sizeOfTargetInLca\",\"idealLength\",\"sizeOfSourceInLca\",\"initSpringEmbedder\",\"FDLayout.prototype.initSpringEmbedder\",\"maxNodeDisplacement\",\"totalDisplacementThreshold\",\"repulsionRange\",\"calcRepulsionRange\",\"calcSpringForces\",\"FDLayout.prototype.calcSpringForces\",\"lEdges\",\"calcSpringForce\",\"calcRepulsionForces\",\"FDLayout.prototype.calcRepulsionForces\",\"gridUpdateAllowed\",\"forceToNodeSurroundingUpdate\",\"lNodes\",\"updateGrid\",\"processedNodeSet\",\"nodeA\",\"calculateRepulsionForceOfANode\",\"j\",\"nodeB\",\"calcRepulsionForce\",\"calcGravitationalForces\",\"FDLayout.prototype.calcGravitationalForces\",\"calcGravitationalForce\",\"moveNodes\",\"FDLayout.prototype.moveNodes\",\"FDLayout.prototype.calcSpringForce\",\"springForce\",\"springForceX\",\"springForceY\",\"FDLayout.prototype.calcRepulsionForce\",\"clipPoints\",\"repulsionForceX\",\"repulsionForceY\",\"childrenConstant\",\"distanceX\",\"distanceY\",\"distanceSquared\",\"distance\",\"repulsionForce\",\"FDLayout.prototype.calcGravitationalForce\",\"ownerCenterX\",\"ownerCenterY\",\"absDistanceX\",\"absDistanceY\",\"gravitationForceX\",\"gravitationForceY\",\"isConverged\",\"FDLayout.prototype.isConverged\",\"oscilating\",\"converged\",\"animate\",\"FDLayout.prototype.animate\",\"calcNoOfChildrenForAllNodes\",\"FDLayout.prototype.calcNoOfChildrenForAllNodes\",\"calcGrid\",\"FDLayout.prototype.calcGrid\",\"sizeX\",\"sizeY\",\"addNodeToGrid\",\"FDLayout.prototype.addNodeToGrid\",\"startX\",\"finishX\",\"startY\",\"finishY\",\"setGridCoordinates\",\"FDLayout.prototype.updateGrid\",\"FDLayout.prototype.calculateRepulsionForceOfANode\",\"surrounding\",\"FDLayout.prototype.calcRepulsionRange\",\"FDLayoutEdge\",\"FDLayoutNode\",\"displacementY\",\"displacementX\",\"FDLayoutNode.prototype.setGridCoordinates\",\"_startX\",\"_finishX\",\"_startY\",\"_finishY\",\"DimensionD.prototype.getWidth\",\"DimensionD.prototype.setWidth\",\"DimensionD.prototype.getHeight\",\"DimensionD.prototype.setHeight\",\"HashMap\",\"map\",\"put\",\"HashMap.prototype.put\",\"theId\",\"contains\",\"HashMap.prototype.contains\",\"HashMap.prototype.get\",\"keySet\",\"HashMap.prototype.keySet\",\"HashSet\",\"HashSet.prototype.add\",\"HashSet.prototype.remove\",\"clear\",\"HashSet.prototype.clear\",\"HashSet.prototype.contains\",\"isEmpty\",\"HashSet.prototype.isEmpty\",\"HashSet.prototype.size\",\"addAllTo\",\"HashSet.prototype.addAllTo\",\"addAll\",\"HashSet.prototype.addAll\",\"Quicksort\",\"A\",\"compareFunction\",\"_defaultCompareFunction\",\"_quicksort\",\"_partition\",\"_get\",\"_swap\",\"_set\",\"NeedlemanWunsch\",\"sequence1\",\"sequence2\",\"match_score\",\"mismatch_penalty\",\"gap_penalty\",\"iMax\",\"jMax\",\"tracebackGrid\",\"_i\",\"_j\",\"alignments\",\"score\",\"computeGrids\",\"getScore\",\"getAlignments\",\"_i2\",\"_j2\",\"maxOf\",\"diag\",\"indices\",\"arrayAllMaxIndexes\",\"includes\",\"alignmentTraceback\",\"inProcessAlignments\",\"pos\",\"seq1\",\"seq2\",\"getAllIndexes\",\"indexes\",\"array\",\"apply\",\"layoutBase\",\"listeners\",\"addListener\",\"p.addListener\",\"event\",\"callback\",\"removeListener\",\"p.removeListener\",\"emit\",\"p.emit\",\"data\"]\n}\n"]