["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/vega-label/build/vega-label.js"],"~:js","shadow$provide.module$node_modules$vega_label$build$vega_label=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){\"object\"===typeof exports$jscomp$0&&\"undefined\"!==typeof module?factory(exports$jscomp$0,require(\"module$node_modules$vega_canvas$build$vega_canvas_min\"),require(\"module$node_modules$vega_dataflow$build$vega_dataflow\"),require(\"module$node_modules$vega_scenegraph$build$vega_scenegraph\"),require(\"module$node_modules$vega_util$build$vega_util\")):\"function\"===\ntypeof define&&define.amd?define([\"exports\",\"vega-canvas\",\"vega-dataflow\",\"vega-scenegraph\",\"vega-util\"],factory):(global=\"undefined\"!==typeof globalThis?globalThis:global||self,factory((global.vega=global.vega||{},global.vega.transforms={}),global.vega,global.vega,global.vega,global.vega))})(this,function(exports,vegaCanvas,vegaDataflow,vegaScenegraph,vegaUtil){function baseBitmaps($,data){const bitmap=$.bitmap();(data||[]).forEach(d=>bitmap.set($(d.boundary[0]),$(d.boundary[3])));return[bitmap,\nvoid 0]}function markBitmaps($,avoidMarks,labelInside,isGroupArea){const width=$.width,height=$.height,border=labelInside||isGroupArea,context=vegaCanvas.canvas(width,height).getContext(\"2d\");avoidMarks.forEach(items=>draw(context,items,border));avoidMarks=new Uint32Array(context.getImageData(0,0,width,height).data.buffer);labelInside=$.bitmap();const layer2=border&&$.bitmap();let x,y,u,v,alpha;for(y=0;y<height;++y)for(x=0;x<width;++x)if(alpha=avoidMarks[y*width+x]&4278190080)u=$(x),v=$(y),isGroupArea||\nlabelInside.set(u,v),border&&alpha^268435456&&layer2.set(u,v);return[labelInside,layer2]}function draw(context,items,interior){if(items.length){var type=items[0].mark.marktype;\"group\"===type?items.forEach(group=>{group.items.forEach(mark=>draw(context,mark.items,interior))}):vegaScenegraph.Marks[type].draw(context,{items:interior?items.map(prepare):items})}}function prepare(source){source=vegaDataflow.rederive(source,{});source.stroke&&(source.strokeOpacity=1);source.fill&&(source.fillOpacity=.0625,\nsource.stroke=\"#000\",source.strokeOpacity=1,source.strokeWidth=2);return source}function Bitmap(w,h){const array=new Uint32Array(~~((w*h+32)/32));return{array,get:(x,y)=>{x=y*w+x;return array[x>>>5]&1<<(x&31)},set:(x,y)=>{x=y*w+x;array[x>>>5]|=1<<(x&31)},clear:(x,y)=>{x=y*w+x;array[x>>>5]&=~(1<<(x&31))},getRange:(x,y,x2,y2)=>{let end,indexStart,indexEnd;for(;y2>=y;--y2){var start=y2*w+x;end=y2*w+x2;indexStart=start>>>5;indexEnd=end>>>5;if(indexStart===indexEnd){if(array[indexStart]&RIGHT0[start&31]&\nRIGHT1[(end&31)+1])return!0}else{if(array[indexStart]&RIGHT0[start&31]||array[indexEnd]&RIGHT1[(end&31)+1])return!0;for(start=indexStart+1;start<indexEnd;++start)if(array[start])return!0}}return!1},setRange:(x,y,x2,y2)=>{let end,indexStart,indexEnd;for(;y<=y2;++y){var start=y*w+x;end=y*w+x2;indexStart=start>>>5;indexEnd=end>>>5;if(indexStart===indexEnd)array[indexStart]|=RIGHT0[start&31]&RIGHT1[(end&31)+1];else for(array[indexStart]|=RIGHT0[start&31],array[indexEnd]|=RIGHT1[(end&31)+1],start=indexStart+\n1;start<indexEnd;++start)array[start]|=4294967295}},clearRange:(x,y,x2,y2)=>{let end,indexStart,indexEnd;for(;y<=y2;++y){var start=y*w+x;end=y*w+x2;indexStart=start>>>5;indexEnd=end>>>5;if(indexStart===indexEnd)array[indexStart]&=RIGHT1[start&31]|RIGHT0[(end&31)+1];else for(array[indexStart]&=RIGHT1[start&31],array[indexEnd]&=RIGHT0[(end&31)+1],start=indexStart+1;start<indexEnd;++start)array[start]&=0}},outOfBounds:(x,y,x2,y2)=>0>x||0>y||y2>=h||x2>=w}}function scaler(width,height,padding){const ratio=\nMath.max(1,Math.sqrt(width*height/1E6)),w=~~((width+2*padding+ratio)/ratio),h=~~((height+2*padding+ratio)/ratio),scale=_=>~~((_+padding)/ratio);scale.invert=_=>_*ratio-padding;scale.bitmap=()=>Bitmap(w,h);scale.ratio=ratio;scale.padding=padding;scale.width=width;scale.height=height;return scale}function outOfBounds(x,y,textWidth,textHeight,width,height){textWidth/=2;return 0>x-textWidth||x+textWidth>width||0>y-(textWidth=textHeight/2)||y+textWidth>height}function collision($,x,y,textHeight,textWidth,\nh,bm0,bm1){textWidth=textWidth*h/(2*textHeight);textHeight=$(x-textWidth);x=$(x+textWidth);textWidth=$(y-(h/=2));$=$(y+h);return bm0.outOfBounds(textHeight,textWidth,x,$)||bm0.getRange(textHeight,textWidth,x,$)||bm1&&bm1.getRange(textHeight,textWidth,x,$)}function placeMarkLabel($,bitmaps,anchors,offsets){const width=$.width,height=$.height,bm0$jscomp$0=bitmaps[0],bm1$jscomp$0=bitmaps[1],n=offsets.length;return function(d){const boundary=d.boundary,textHeight=d.datum.fontSize;if(0>boundary[2]||0>\nboundary[5]||boundary[0]>width||boundary[3]>height)return!1;let textWidth=0,dx,dy;let insideFactor,x1;let y2;let yc;let _y1,_y2;for(let i=0;i<n;++i){dx=(anchors[i]&3)-1;dy=(anchors[i]>>>2&3)-1;var isInside=0===dx&&0===dy||0>offsets[i];var sizeFactor=dx&&dy?Math.SQRT1_2:1;insideFactor=0>offsets[i]?-1:1;x1=boundary[1+dx]+offsets[i]*dx*sizeFactor;yc=boundary[4+dy]+insideFactor*textHeight*dy/2+offsets[i]*dy*sizeFactor;sizeFactor=yc-textHeight/2;y2=yc+textHeight/2;var _x1=$(x1);_y1=$(sizeFactor);_y2=$(y2);\nif(!textWidth){var x2=_x1;var xc=_y1;var _x2=_y2;var bm0=bm0$jscomp$0,bm1=bm1$jscomp$0,x1$jscomp$0=x1,x2$jscomp$0=x1,y1=sizeFactor,y2$jscomp$0=y2,boundary$jscomp$0=boundary,isInside$jscomp$0=isInside;if(!bm0.outOfBounds(x2,xc,_x1,_x2)&&(isInside$jscomp$0&&bm1?!bm1.getRange(x2,xc,_x1,_x2)&&boundary$jscomp$0[0]<=x1$jscomp$0&&x2$jscomp$0<=boundary$jscomp$0[2]&&boundary$jscomp$0[3]<=y1&&y2$jscomp$0<=boundary$jscomp$0[5]:!bm0.getRange(x2,xc,_x1,_x2)))textWidth=vegaScenegraph.textMetrics.width(d.datum,\nd.datum.text);else continue}xc=x1+insideFactor*textWidth*dx/2;x1=xc-textWidth/2;x2=xc+textWidth/2;_x1=$(x1);_x2=$(x2);bm0=_x1;bm1=_x2;x1$jscomp$0=_y1;x2$jscomp$0=_y2;y1=bm0$jscomp$0;y2$jscomp$0=bm1$jscomp$0;boundary$jscomp$0=x1;isInside$jscomp$0=x2;var y1$jscomp$0=sizeFactor,y2$jscomp$1=y2,boundary$jscomp$1=boundary;if(!y1.outOfBounds(bm0,x1$jscomp$0,bm1,x2$jscomp$0)&&(isInside&&y2$jscomp$0?!y2$jscomp$0.getRange(bm0,x1$jscomp$0,bm1,x2$jscomp$0)&&boundary$jscomp$1[0]<=boundary$jscomp$0&&isInside$jscomp$0<=\nboundary$jscomp$1[2]&&boundary$jscomp$1[3]<=y1$jscomp$0&&y2$jscomp$1<=boundary$jscomp$1[5]:!y1.getRange(bm0,x1$jscomp$0,bm1,x2$jscomp$0)))return d.x=dx?0>dx*insideFactor?x2:x1:xc,d.y=dy?0>dy*insideFactor?y2:sizeFactor:yc,d.align=Aligns[dx*insideFactor+1],d.baseline=Baselines[dy*insideFactor+1],bm0$jscomp$0.setRange(_x1,_y1,_x2,_y2),!0}return!1}}function labelLayout(texts,size,compare,offset,anchor,avoidMarks,avoidBaseMark,lineAnchor,markIndex,padding,method){if(!texts.length)return texts;var positions=\nMath.max(offset.length,anchor.length);offset=getOffsets(offset,positions);anchor=getAnchors(anchor,positions);positions=markType(texts[0].datum);const grouptype=\"group\"===positions&&texts[0].datum.items[markIndex].marktype,isGroupArea=\"area\"===grouptype,boundary=markBoundary(positions,grouptype,lineAnchor,markIndex);size=scaler(size[0],size[1],padding);padding=isGroupArea&&\"naive\"===method;lineAnchor=texts.map(d=>({datum:d,opacity:0,x:void 0,y:void 0,align:void 0,baseline:void 0,boundary:boundary(d)}));\nif(!padding){compare&&lineAnchor.sort((a,b)=>compare(a.datum,b.datum));var bitmaps=!1;for(padding=0;padding<anchor.length&&!bitmaps;++padding)bitmaps=5===anchor[padding]||0>offset[padding];positions&&(avoidBaseMark||isGroupArea)&&(avoidMarks=[texts.map(d=>d.datum)].concat(avoidMarks));bitmaps=avoidMarks.length?markBitmaps(size,avoidMarks,bitmaps,isGroupArea):baseBitmaps(size,avoidBaseMark&&lineAnchor)}const place=isGroupArea?placeAreaLabel[method](size,bitmaps,avoidBaseMark,markIndex):placeMarkLabel(size,\nbitmaps,anchor,offset);lineAnchor.forEach(d=>d.opacity=+place(d));return lineAnchor}function getOffsets(_,count){const offsets=new Float64Array(count),n=_.length;for(let i=0;i<n;++i)offsets[i]=_[i]||0;for(_=n;_<count;++_)offsets[_]=offsets[n-1];return offsets}function getAnchors(_,count){const anchors=new Int8Array(count),n=_.length;for(let i=0;i<n;++i)anchors[i]|=anchorCode[_[i]];for(_=n;_<count;++_)anchors[_]=anchors[n-1];return anchors}function markType(item){return item&&item.mark&&item.mark.marktype}\nfunction markBoundary(marktype,grouptype,lineAnchor,markIndex){const xy=d=>[d.x,d.x,d.x,d.y,d.y,d.y];return marktype?\"line\"===marktype||\"area\"===marktype?d=>xy(d.datum):\"line\"===grouptype?d=>{d=d.datum.items[markIndex].items;return xy(d.length?d[\"start\"===lineAnchor?0:d.length-1]:{x:NaN,y:NaN})}:d=>{d=d.datum.bounds;return[d.x1,(d.x1+d.x2)/2,d.x2,d.y1,(d.y1+d.y2)/2,d.y2]}:xy}function Label(params){vegaDataflow.Transform.call(this,null,params)}const RIGHT0=new Uint32Array(33),RIGHT1=new Uint32Array(33);\nRIGHT1[0]=0;RIGHT0[0]=~RIGHT1[0];for(let i=1;32>=i;++i)RIGHT1[i]=RIGHT1[i-1]<<1|1,RIGHT0[i]=~RIGHT1[i];const X_DIR=[-1,-1,1,1],Y_DIR=[-1,1,-1,1],Aligns=[\"right\",\"center\",\"left\"],Baselines=[\"bottom\",\"middle\",\"top\"],anchorCode={\"top-left\":0,top:1,\"top-right\":2,left:4,middle:5,right:6,\"bottom-left\":8,bottom:9,\"bottom-right\":10},placeAreaLabel={naive:function($,bitmaps,avoidBaseMark,markIndex){const width=$.width,height=$.height;return function(d){const items=d.datum.datum.items[markIndex].items,n=items.length,\ntextHeight=d.datum.fontSize,textWidth=vegaScenegraph.textMetrics.width(d.datum,d.datum.text);let maxAreaWidth=0;let x2,y1,y2,x,y;for(let i=0;i<n;++i){var x1=items[i].x;y1=items[i].y;x2=void 0===items[i].x2?x1:items[i].x2;y2=void 0===items[i].y2?y1:items[i].y2;x=(x1+x2)/2;y=(y1+y2)/2;x1=Math.abs(x2-x1+y2-y1);x1>=maxAreaWidth&&(maxAreaWidth=x1,d.x=x,d.y=y)}x=textWidth/2;y=textHeight/2;x1=d.x-x;x2=d.x+x;y1=d.y-y;y2=d.y+y;d.align=\"center\";0>x1&&x2<=width?d.align=\"left\":0<=x1&&width<x2&&(d.align=\"right\");\nd.baseline=\"middle\";0>y1&&y2<=height?d.baseline=\"top\":0<=y1&&height<y2&&(d.baseline=\"bottom\");return!0}},\"reduced-search\":function($,bitmaps,avoidBaseMark,markIndex){function tryLabel(_x,_y,maxSize,textWidth,textHeight){_x=$.invert(_x);_y=$.invert(_y);let lo=maxSize,hi=height,mid;if(!outOfBounds(_x,_y,textWidth,textHeight,width,height)&&!collision($,_x,_y,textHeight,textWidth,lo,bm0,bm1)&&!collision($,_x,_y,textHeight,textWidth,textHeight,bm0,null)){for(;1<=hi-lo;)mid=(lo+hi)/2,collision($,_x,_y,\ntextHeight,textWidth,mid,bm0,bm1)?hi=mid:lo=mid;if(lo>maxSize)return[_x,_y,lo,!0]}}const width=$.width,height=$.height,bm0=bitmaps[0],bm1=bitmaps[1];return function(d){const items=d.datum.datum.items[markIndex].items,n=items.length,textHeight=d.datum.fontSize,textWidth=vegaScenegraph.textMetrics.width(d.datum,d.datum.text);let maxSize=avoidBaseMark?textHeight:0,labelPlaced=!1,labelPlaced2=!1,maxAreaWidth=0;let x2;let y2;let _y,_x1,_xMid,_x2,_y1,_yMid,_y2,result;for(let i=0;i<n;++i){var x1=items[i].x;\nvar y1=items[i].y;x2=void 0===items[i].x2?x1:items[i].x2;y2=void 0===items[i].y2?y1:items[i].y2;if(x1>x2){var _x=x1;x1=x2;x2=_x}y1>y2&&(_x=y1,y1=y2,y2=_x);_x1=$(x1);_x2=$(x2);_xMid=~~((_x1+_x2)/2);_y1=$(y1);_y2=$(y2);_yMid=~~((_y1+_y2)/2);for(_x=_xMid;_x>=_x1;--_x)for(_y=_yMid;_y>=_y1;--_y)(result=tryLabel(_x,_y,maxSize,textWidth,textHeight))&&([d.x,d.y,maxSize,labelPlaced]=result);for(_x=_xMid;_x<=_x2;++_x)for(_y=_yMid;_y<=_y2;++_y)(result=tryLabel(_x,_y,maxSize,textWidth,textHeight))&&([d.x,d.y,\nmaxSize,labelPlaced]=result);labelPlaced||avoidBaseMark||(_x=Math.abs(x2-x1+y2-y1),x1=(x1+x2)/2,y1=(y1+y2)/2,_x>=maxAreaWidth&&!outOfBounds(x1,y1,textWidth,textHeight,width,height)&&!collision($,x1,y1,textHeight,textWidth,textHeight,bm0,null)&&(maxAreaWidth=_x,d.x=x1,d.y=y1,labelPlaced2=!0))}return labelPlaced||labelPlaced2?(x1=textWidth/2,y1=textHeight/2,bm0.setRange($(d.x-x1),$(d.y-y1),$(d.x+x1),$(d.y+y1)),d.align=\"center\",d.baseline=\"middle\",!0):!1}},floodfill:function($,bitmaps,avoidBaseMark,\nmarkIndex){const width=$.width,height=$.height,bm0=bitmaps[0],bm1=bitmaps[1],bm2=$.bitmap();return function(d){const items=d.datum.datum.items[markIndex].items,n=items.length,textHeight=d.datum.fontSize,textWidth=vegaScenegraph.textMetrics.width(d.datum,d.datum.text),stack=[];let maxSize=avoidBaseMark?textHeight:0,labelPlaced=!1,labelPlaced2=!1,maxAreaWidth=0,x1,x2,y1,y2,x,y;var mid;for(let i=0;i<n;++i){x1=items[i].x;y1=items[i].y;x2=void 0===items[i].x2?x1:items[i].x2;y2=void 0===items[i].y2?y1:\nitems[i].y2;for(stack.push([$((x1+x2)/2),$((y1+y2)/2)]);stack.length;)if([_x,_y]=stack.pop(),!(bm0.get(_x,_y)||bm1.get(_x,_y)||bm2.get(_x,_y))){bm2.set(_x,_y);for(mid=0;4>mid;++mid)x=_x+X_DIR[mid],y=_y+Y_DIR[mid],bm2.outOfBounds(x,y,x,y)||stack.push([x,y]);x=$.invert(_x);y=$.invert(_y);var _x=maxSize;var _y=height;if(!outOfBounds(x,y,textWidth,textHeight,width,height)&&!collision($,x,y,textHeight,textWidth,_x,bm0,bm1)&&!collision($,x,y,textHeight,textWidth,textHeight,bm0,null)){for(;1<=_y-_x;)mid=\n(_x+_y)/2,collision($,x,y,textHeight,textWidth,mid,bm0,bm1)?_y=mid:_x=mid;_x>maxSize&&(d.x=x,d.y=y,maxSize=_x,labelPlaced=!0)}}labelPlaced||avoidBaseMark||(_x=Math.abs(x2-x1+y2-y1),x=(x1+x2)/2,y=(y1+y2)/2,_x>=maxAreaWidth&&!outOfBounds(x,y,textWidth,textHeight,width,height)&&!collision($,x,y,textHeight,textWidth,textHeight,bm0,null)&&(maxAreaWidth=_x,d.x=x,d.y=y,labelPlaced2=!0))}return labelPlaced||labelPlaced2?(x=textWidth/2,y=textHeight/2,bm0.setRange($(d.x-x),$(d.y-y),$(d.x+x),$(d.y+y)),d.align=\n\"center\",d.baseline=\"middle\",!0):!1}}},Output=[\"x\",\"y\",\"opacity\",\"align\",\"baseline\"],Anchors=\"top-left left bottom-left top bottom top-right right bottom-right\".split(\" \");Label.Definition={type:\"Label\",metadata:{modifies:!0},params:[{name:\"size\",type:\"number\",array:!0,length:2,required:!0},{name:\"sort\",type:\"compare\"},{name:\"anchor\",type:\"string\",array:!0,default:Anchors},{name:\"offset\",type:\"number\",array:!0,default:[1]},{name:\"padding\",type:\"number\",default:0},{name:\"lineAnchor\",type:\"string\",\nvalues:[\"start\",\"end\"],default:\"end\"},{name:\"markIndex\",type:\"number\",default:0},{name:\"avoidBaseMark\",type:\"boolean\",default:!0},{name:\"avoidMarks\",type:\"data\",array:!0},{name:\"method\",type:\"string\",default:\"naive\"},{name:\"as\",type:\"string\",array:!0,length:Output.length,default:Output}]};vegaUtil.inherits(Label,vegaDataflow.Transform,{transform(_,pulse){function modp(param){param=_[param];return vegaUtil.isFunction(param)&&pulse.modified(param.fields)}const mod=_.modified();if(mod||pulse.changed(pulse.ADD_REM)||\nmodp(\"sort\")){_.size&&2===_.size.length||vegaUtil.error(\"Size parameter should be specified as a [width, height] array.\");var as=_.as||Output;labelLayout(pulse.materialize(pulse.SOURCE).source,_.size,_.sort,vegaUtil.array(_.offset||1),vegaUtil.array(_.anchor||Anchors),_.avoidMarks||[],!1===_.avoidBaseMark?!1:!0,_.lineAnchor||\"end\",_.markIndex||0,_.padding||0,_.method||\"naive\").forEach(l=>{const t=l.datum;t[as[0]]=l.x;t[as[1]]=l.y;t[as[2]]=l.opacity;t[as[3]]=l.align;t[as[4]]=l.baseline});return pulse.reflow(mod).modifies(as)}}});\nexports.label=Label;Object.defineProperty(exports,\"__esModule\",{value:!0})})}","~:source","shadow$provide[\"module$node_modules$vega_label$build$vega_label\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-canvas'), require('vega-dataflow'), require('vega-scenegraph'), require('vega-util')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-canvas', 'vega-dataflow', 'vega-scenegraph', 'vega-util'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaCanvas, vegaDataflow, vegaScenegraph, vegaUtil) { 'use strict';\n\n  const ALPHA_MASK = 0xff000000; // alpha value equivalent to opacity 0.0625\n\n  const INSIDE_OPACITY_IN_ALPHA = 0x10000000;\n  const INSIDE_OPACITY = 0.0625;\n  function baseBitmaps($, data) {\n    const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided\n\n    (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\n    return [bitmap, undefined];\n  }\n  function markBitmaps($, avoidMarks, labelInside, isGroupArea) {\n    // create canvas\n    const width = $.width,\n          height = $.height,\n          border = labelInside || isGroupArea,\n          context = vegaCanvas.canvas(width, height).getContext('2d'); // render all marks to be avoided into canvas\n\n    avoidMarks.forEach(items => draw(context, items, border)); // get canvas buffer, create bitmaps\n\n    const buffer = new Uint32Array(context.getImageData(0, 0, width, height).data.buffer),\n          layer1 = $.bitmap(),\n          layer2 = border && $.bitmap(); // populate bitmap layers\n\n    let x, y, u, v, alpha;\n\n    for (y = 0; y < height; ++y) {\n      for (x = 0; x < width; ++x) {\n        alpha = buffer[y * width + x] & ALPHA_MASK;\n\n        if (alpha) {\n          u = $(x);\n          v = $(y);\n          if (!isGroupArea) layer1.set(u, v); // update interior bitmap\n\n          if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA) layer2.set(u, v); // update border bitmap\n        }\n      }\n    }\n\n    return [layer1, layer2];\n  }\n\n  function draw(context, items, interior) {\n    if (!items.length) return;\n    const type = items[0].mark.marktype;\n\n    if (type === 'group') {\n      items.forEach(group => {\n        group.items.forEach(mark => draw(context, mark.items, interior));\n      });\n    } else {\n      vegaScenegraph.Marks[type].draw(context, {\n        items: interior ? items.map(prepare) : items\n      });\n    }\n  }\n  /**\n   * Prepare item before drawing into canvas (setting stroke and opacity)\n   * @param {object} source item to be prepared\n   * @returns prepared item\n   */\n\n\n  function prepare(source) {\n    const item = vegaDataflow.rederive(source, {});\n\n    if (item.stroke) {\n      item.strokeOpacity = 1;\n    }\n\n    if (item.fill) {\n      item.fillOpacity = INSIDE_OPACITY;\n      item.stroke = '#000';\n      item.strokeOpacity = 1;\n      item.strokeWidth = 2;\n    }\n\n    return item;\n  }\n\n  const DIV = 5,\n        // bit shift from x, y index to bit vector array index\n  MOD = 31,\n        // bit mask for index lookup within a bit vector\n  SIZE = 32,\n        // individual bit vector size\n  RIGHT0 = new Uint32Array(SIZE + 1),\n        // left-anchored bit vectors, full -> 0\n  RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\n\n  RIGHT1[0] = 0;\n  RIGHT0[0] = ~RIGHT1[0];\n\n  for (let i = 1; i <= SIZE; ++i) {\n    RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;\n    RIGHT0[i] = ~RIGHT1[i];\n  }\n\n  function Bitmap (w, h) {\n    const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\n\n    function _set(index, mask) {\n      array[index] |= mask;\n    }\n\n    function _clear(index, mask) {\n      array[index] &= mask;\n    }\n\n    return {\n      array: array,\n      get: (x, y) => {\n        const index = y * w + x;\n        return array[index >>> DIV] & 1 << (index & MOD);\n      },\n      set: (x, y) => {\n        const index = y * w + x;\n\n        _set(index >>> DIV, 1 << (index & MOD));\n      },\n      clear: (x, y) => {\n        const index = y * w + x;\n\n        _clear(index >>> DIV, ~(1 << (index & MOD)));\n      },\n      getRange: (x, y, x2, y2) => {\n        let r = y2,\n            start,\n            end,\n            indexStart,\n            indexEnd;\n\n        for (; r >= y; --r) {\n          start = r * w + x;\n          end = r * w + x2;\n          indexStart = start >>> DIV;\n          indexEnd = end >>> DIV;\n\n          if (indexStart === indexEnd) {\n            if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\n              return true;\n            }\n          } else {\n            if (array[indexStart] & RIGHT0[start & MOD]) return true;\n            if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\n\n            for (let i = indexStart + 1; i < indexEnd; ++i) {\n              if (array[i]) return true;\n            }\n          }\n        }\n\n        return false;\n      },\n      setRange: (x, y, x2, y2) => {\n        let start, end, indexStart, indexEnd, i;\n\n        for (; y <= y2; ++y) {\n          start = y * w + x;\n          end = y * w + x2;\n          indexStart = start >>> DIV;\n          indexEnd = end >>> DIV;\n\n          if (indexStart === indexEnd) {\n            _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\n          } else {\n            _set(indexStart, RIGHT0[start & MOD]);\n\n            _set(indexEnd, RIGHT1[(end & MOD) + 1]);\n\n            for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\n          }\n        }\n      },\n      clearRange: (x, y, x2, y2) => {\n        let start, end, indexStart, indexEnd, i;\n\n        for (; y <= y2; ++y) {\n          start = y * w + x;\n          end = y * w + x2;\n          indexStart = start >>> DIV;\n          indexEnd = end >>> DIV;\n\n          if (indexStart === indexEnd) {\n            _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\n          } else {\n            _clear(indexStart, RIGHT1[start & MOD]);\n\n            _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\n\n            for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\n          }\n        }\n      },\n      outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\n    };\n  }\n\n  function scaler (width, height, padding) {\n    const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),\n          w = ~~((width + 2 * padding + ratio) / ratio),\n          h = ~~((height + 2 * padding + ratio) / ratio),\n          scale = _ => ~~((_ + padding) / ratio);\n\n    scale.invert = _ => _ * ratio - padding;\n\n    scale.bitmap = () => Bitmap(w, h);\n\n    scale.ratio = ratio;\n    scale.padding = padding;\n    scale.width = width;\n    scale.height = height;\n    return scale;\n  }\n\n  function placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {\n    const width = $.width,\n          height = $.height; // try to place a label within an input area mark\n\n    return function (d) {\n      const items = d.datum.datum.items[markIndex].items,\n            // area points\n      n = items.length,\n            // number of points\n      textHeight = d.datum.fontSize,\n            // label width\n      textWidth = vegaScenegraph.textMetrics.width(d.datum, d.datum.text); // label height\n\n      let maxAreaWidth = 0,\n          x1,\n          x2,\n          y1,\n          y2,\n          x,\n          y,\n          areaWidth; // for each area sample point\n\n      for (let i = 0; i < n; ++i) {\n        x1 = items[i].x;\n        y1 = items[i].y;\n        x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n        y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n        x = (x1 + x2) / 2;\n        y = (y1 + y2) / 2;\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\n\n        if (areaWidth >= maxAreaWidth) {\n          maxAreaWidth = areaWidth;\n          d.x = x;\n          d.y = y;\n        }\n      }\n\n      x = textWidth / 2;\n      y = textHeight / 2;\n      x1 = d.x - x;\n      x2 = d.x + x;\n      y1 = d.y - y;\n      y2 = d.y + y;\n      d.align = 'center';\n\n      if (x1 < 0 && x2 <= width) {\n        d.align = 'left';\n      } else if (0 <= x1 && width < x2) {\n        d.align = 'right';\n      }\n\n      d.baseline = 'middle';\n\n      if (y1 < 0 && y2 <= height) {\n        d.baseline = 'top';\n      } else if (0 <= y1 && height < y2) {\n        d.baseline = 'bottom';\n      }\n\n      return true;\n    };\n  }\n\n  function outOfBounds(x, y, textWidth, textHeight, width, height) {\n    let r = textWidth / 2;\n    return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;\n  }\n  function collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\n    const w = textWidth * h / (textHeight * 2),\n          x1 = $(x - w),\n          x2 = $(x + w),\n          y1 = $(y - (h = h / 2)),\n          y2 = $(y + h);\n    return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\n  }\n\n  function placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex) {\n    const width = $.width,\n          height = $.height,\n          bm0 = bitmaps[0],\n          // where labels have been placed\n    bm1 = bitmaps[1]; // area outlines\n\n    function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\n      const x = $.invert(_x),\n            y = $.invert(_y);\n      let lo = maxSize,\n          hi = height,\n          mid;\n\n      if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n        // if the label fits at the current sample point,\n        // perform binary search to find the largest font size that fits\n        while (hi - lo >= 1) {\n          mid = (lo + hi) / 2;\n\n          if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n            hi = mid;\n          } else {\n            lo = mid;\n          }\n        } // place label if current lower bound exceeds prior max font size\n\n\n        if (lo > maxSize) {\n          return [x, y, lo, true];\n        }\n      }\n    } // try to place a label within an input area mark\n\n\n    return function (d) {\n      const items = d.datum.datum.items[markIndex].items,\n            // area points\n      n = items.length,\n            // number of points\n      textHeight = d.datum.fontSize,\n            // label width\n      textWidth = vegaScenegraph.textMetrics.width(d.datum, d.datum.text); // label height\n\n      let maxSize = avoidBaseMark ? textHeight : 0,\n          labelPlaced = false,\n          labelPlaced2 = false,\n          maxAreaWidth = 0,\n          x1,\n          x2,\n          y1,\n          y2,\n          x,\n          y,\n          _x,\n          _y,\n          _x1,\n          _xMid,\n          _x2,\n          _y1,\n          _yMid,\n          _y2,\n          areaWidth,\n          result,\n          swapTmp; // for each area sample point\n\n\n      for (let i = 0; i < n; ++i) {\n        x1 = items[i].x;\n        y1 = items[i].y;\n        x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n        y2 = items[i].y2 === undefined ? y1 : items[i].y2;\n\n        if (x1 > x2) {\n          swapTmp = x1;\n          x1 = x2;\n          x2 = swapTmp;\n        }\n\n        if (y1 > y2) {\n          swapTmp = y1;\n          y1 = y2;\n          y2 = swapTmp;\n        }\n\n        _x1 = $(x1);\n        _x2 = $(x2);\n        _xMid = ~~((_x1 + _x2) / 2);\n        _y1 = $(y1);\n        _y2 = $(y2);\n        _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border\n\n        for (_x = _xMid; _x >= _x1; --_x) {\n          for (_y = _yMid; _y >= _y1; --_y) {\n            result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n            if (result) {\n              [d.x, d.y, maxSize, labelPlaced] = result;\n            }\n          }\n        } // search along the line from mid point between the 2 border to upper border\n\n\n        for (_x = _xMid; _x <= _x2; ++_x) {\n          for (_y = _yMid; _y <= _y2; ++_y) {\n            result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\n\n            if (result) {\n              [d.x, d.y, maxSize, labelPlaced] = result;\n            }\n          }\n        } // place label at slice center if not placed through other means\n        // and if we're not avoiding overlap with other areas\n\n\n        if (!labelPlaced && !avoidBaseMark) {\n          // one span is zero, hence we can add\n          areaWidth = Math.abs(x2 - x1 + y2 - y1);\n          x = (x1 + x2) / 2;\n          y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n          if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n            maxAreaWidth = areaWidth;\n            d.x = x;\n            d.y = y;\n            labelPlaced2 = true;\n          }\n        }\n      } // record current label placement information, update label bitmap\n\n\n      if (labelPlaced || labelPlaced2) {\n        x = textWidth / 2;\n        y = textHeight / 2;\n        bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n        d.align = 'center';\n        d.baseline = 'middle';\n        return true;\n      } else {\n        return false;\n      }\n    };\n  }\n\n  const X_DIR = [-1, -1, 1, 1];\n  const Y_DIR = [-1, 1, -1, 1];\n  function placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex) {\n    const width = $.width,\n          height = $.height,\n          bm0 = bitmaps[0],\n          // where labels have been placed\n    bm1 = bitmaps[1],\n          // area outlines\n    bm2 = $.bitmap(); // flood-fill visitations\n    // try to place a label within an input area mark\n\n    return function (d) {\n      const items = d.datum.datum.items[markIndex].items,\n            // area points\n      n = items.length,\n            // number of points\n      textHeight = d.datum.fontSize,\n            // label width\n      textWidth = vegaScenegraph.textMetrics.width(d.datum, d.datum.text),\n            // label height\n      stack = []; // flood fill stack\n\n      let maxSize = avoidBaseMark ? textHeight : 0,\n          labelPlaced = false,\n          labelPlaced2 = false,\n          maxAreaWidth = 0,\n          x1,\n          x2,\n          y1,\n          y2,\n          x,\n          y,\n          _x,\n          _y,\n          lo,\n          hi,\n          mid,\n          areaWidth; // for each area sample point\n\n\n      for (let i = 0; i < n; ++i) {\n        x1 = items[i].x;\n        y1 = items[i].y;\n        x2 = items[i].x2 === undefined ? x1 : items[i].x2;\n        y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack\n\n        stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points\n\n        while (stack.length) {\n          [_x, _y] = stack.pop(); // exit if point already marked\n\n          if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap\n          // add search points for all (in bound) directions\n\n          bm2.set(_x, _y);\n\n          for (let j = 0; j < 4; ++j) {\n            x = _x + X_DIR[j];\n            y = _y + Y_DIR[j];\n            if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\n          } // unscale point back to x, y space\n\n\n          x = $.invert(_x);\n          y = $.invert(_y);\n          lo = maxSize;\n          hi = height; // TODO: make this bound smaller\n\n          if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n            // if the label fits at the current sample point,\n            // perform binary search to find the largest font size that fits\n            while (hi - lo >= 1) {\n              mid = (lo + hi) / 2;\n\n              if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\n                hi = mid;\n              } else {\n                lo = mid;\n              }\n            } // place label if current lower bound exceeds prior max font size\n\n\n            if (lo > maxSize) {\n              d.x = x;\n              d.y = y;\n              maxSize = lo;\n              labelPlaced = true;\n            }\n          }\n        } // place label at slice center if not placed through other means\n        // and if we're not avoiding overlap with other areas\n\n\n        if (!labelPlaced && !avoidBaseMark) {\n          // one span is zero, hence we can add\n          areaWidth = Math.abs(x2 - x1 + y2 - y1);\n          x = (x1 + x2) / 2;\n          y = (y1 + y2) / 2; // place label if it fits and improves the max area width\n\n          if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\n            maxAreaWidth = areaWidth;\n            d.x = x;\n            d.y = y;\n            labelPlaced2 = true;\n          }\n        }\n      } // record current label placement information, update label bitmap\n\n\n      if (labelPlaced || labelPlaced2) {\n        x = textWidth / 2;\n        y = textHeight / 2;\n        bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\n        d.align = 'center';\n        d.baseline = 'middle';\n        return true;\n      } else {\n        return false;\n      }\n    };\n  }\n\n  const Aligns = ['right', 'center', 'left'],\n        Baselines = ['bottom', 'middle', 'top'];\n  function placeMarkLabel ($, bitmaps, anchors, offsets) {\n    const width = $.width,\n          height = $.height,\n          bm0 = bitmaps[0],\n          bm1 = bitmaps[1],\n          n = offsets.length;\n    return function (d) {\n      const boundary = d.boundary,\n            textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound\n\n      if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {\n        return false;\n      }\n\n      let textWidth = 0,\n          dx,\n          dy,\n          isInside,\n          sizeFactor,\n          insideFactor,\n          x1,\n          x2,\n          y1,\n          y2,\n          xc,\n          yc,\n          _x1,\n          _x2,\n          _y1,\n          _y2; // for each anchor and offset\n\n\n      for (let i = 0; i < n; ++i) {\n        dx = (anchors[i] & 0x3) - 1;\n        dy = (anchors[i] >>> 0x2 & 0x3) - 1;\n        isInside = dx === 0 && dy === 0 || offsets[i] < 0;\n        sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\n        insideFactor = offsets[i] < 0 ? -1 : 1;\n        x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\n        yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;\n        y1 = yc - textHeight / 2;\n        y2 = yc + textHeight / 2;\n        _x1 = $(x1);\n        _y1 = $(y1);\n        _y2 = $(y2);\n\n        if (!textWidth) {\n          // to avoid finding width of text label,\n          if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\n            // skip this anchor/offset option if we fail to place a label with 1px width\n            continue;\n          } else {\n            // Otherwise, find the label width\n            textWidth = vegaScenegraph.textMetrics.width(d.datum, d.datum.text);\n          }\n        }\n\n        xc = x1 + insideFactor * textWidth * dx / 2;\n        x1 = xc - textWidth / 2;\n        x2 = xc + textWidth / 2;\n        _x1 = $(x1);\n        _x2 = $(x2);\n\n        if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\n          // place label if the position is placeable\n          d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\n          d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\n          d.align = Aligns[dx * insideFactor + 1];\n          d.baseline = Baselines[dy * insideFactor + 1];\n          bm0.setRange(_x1, _y1, _x2, _y2);\n          return true;\n        }\n      }\n\n      return false;\n    };\n  } // Test if a label with the given dimensions can be added without overlap\n\n  function test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\n    return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x1, y1, x2, y2, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));\n  }\n\n  function isInMarkBound(x1, y1, x2, y2, boundary) {\n    return boundary[0] <= x1 && x2 <= boundary[2] && boundary[3] <= y1 && y2 <= boundary[5];\n  }\n\n  const TOP = 0x0,\n        MIDDLE = 0x4,\n        BOTTOM = 0x8,\n        LEFT = 0x0,\n        CENTER = 0x1,\n        RIGHT = 0x2; // Mapping from text anchor to number representation\n\n  const anchorCode = {\n    'top-left': TOP + LEFT,\n    'top': TOP + CENTER,\n    'top-right': TOP + RIGHT,\n    'left': MIDDLE + LEFT,\n    'middle': MIDDLE + CENTER,\n    'right': MIDDLE + RIGHT,\n    'bottom-left': BOTTOM + LEFT,\n    'bottom': BOTTOM + CENTER,\n    'bottom-right': BOTTOM + RIGHT\n  };\n  const placeAreaLabel = {\n    'naive': placeAreaLabelNaive,\n    'reduced-search': placeAreaLabelReducedSearch,\n    'floodfill': placeAreaLabelFloodFill\n  };\n  function labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {\n    // early exit for empty data\n    if (!texts.length) return texts;\n    const positions = Math.max(offset.length, anchor.length),\n          offsets = getOffsets(offset, positions),\n          anchors = getAnchors(anchor, positions),\n          marktype = markType(texts[0].datum),\n          grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\n          isGroupArea = grouptype === 'area',\n          boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\n          $ = scaler(size[0], size[1], padding),\n          isNaiveGroupArea = isGroupArea && method === 'naive'; // prepare text mark data for placing\n\n    const data = texts.map(d => ({\n      datum: d,\n      opacity: 0,\n      x: undefined,\n      y: undefined,\n      align: undefined,\n      baseline: undefined,\n      boundary: boundary(d)\n    }));\n    let bitmaps;\n\n    if (!isNaiveGroupArea) {\n      // sort labels in priority order, if comparator is provided\n      if (compare) {\n        data.sort((a, b) => compare(a.datum, b.datum));\n      } // flag indicating if label can be placed inside its base mark\n\n\n      let labelInside = false;\n\n      for (let i = 0; i < anchors.length && !labelInside; ++i) {\n        // label inside if anchor is at center\n        // label inside if offset to be inside the mark bound\n        labelInside = anchors[i] === 0x5 || offsets[i] < 0;\n      } // extract data information from base mark when base mark is to be avoided\n      // base mark is implicitly avoided if it is a group area\n\n\n      if (marktype && (avoidBaseMark || isGroupArea)) {\n        avoidMarks = [texts.map(d => d.datum)].concat(avoidMarks);\n      } // generate bitmaps for layout calculation\n\n\n      bitmaps = avoidMarks.length ? markBitmaps($, avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);\n    } // generate label placement function\n\n\n    const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($, bitmaps, anchors, offsets); // place all labels\n\n    data.forEach(d => d.opacity = +place(d));\n    return data;\n  }\n\n  function getOffsets(_, count) {\n    const offsets = new Float64Array(count),\n          n = _.length;\n\n    for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;\n\n    for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];\n\n    return offsets;\n  }\n\n  function getAnchors(_, count) {\n    const anchors = new Int8Array(count),\n          n = _.length;\n\n    for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];\n\n    for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];\n\n    return anchors;\n  }\n\n  function markType(item) {\n    return item && item.mark && item.mark.marktype;\n  }\n  /**\n   * Factory function for function for getting base mark boundary, depending\n   * on mark and group type. When mark type is undefined, line or area: boundary\n   * is the coordinate of each data point. When base mark is grouped line,\n   * boundary is either at the beginning or end of the line depending on the\n   * value of lineAnchor. Otherwise, use bounds of base mark.\n   */\n\n\n  function markBoundary(marktype, grouptype, lineAnchor, markIndex) {\n    const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\n\n    if (!marktype) {\n      return xy; // no reactive geometry\n    } else if (marktype === 'line' || marktype === 'area') {\n      return d => xy(d.datum);\n    } else if (grouptype === 'line') {\n      return d => {\n        const items = d.datum.items[markIndex].items;\n        return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {\n          x: NaN,\n          y: NaN\n        });\n      };\n    } else {\n      return d => {\n        const b = d.datum.bounds;\n        return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\n      };\n    }\n  }\n\n  const Output = ['x', 'y', 'opacity', 'align', 'baseline'];\n  const Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];\n  /**\n   * Compute text label layout to annotate marks.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\n   * @param {function(*,*): number} [params.sort] - An optional\n   *   comparator function for sorting label data in priority order.\n   * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\n   *   The available options are 'top-left', 'left', 'bottom-left', 'top',\n   *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\n   * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\n   *   This parameter  is parallel to the list of anchor points.\n   * @param {number} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\n   * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\n   *   position for labels. One of 'start' or 'end'.\n   * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\n   *   which mark within the group should be labeled.\n   * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\n   *   layout should avoid overlap.\n   * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\n   *   overlap with the underlying base mark being labeled.\n   * @param {string} [params.method='naive'] - For area make labels only, a method for\n   *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\n   * @param {Array<string>} [params.as] - The output fields written by the transform.\n   *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\n   */\n\n  function Label(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n  Label.Definition = {\n    type: 'Label',\n    metadata: {\n      modifies: true\n    },\n    params: [{\n      name: 'size',\n      type: 'number',\n      array: true,\n      length: 2,\n      required: true\n    }, {\n      name: 'sort',\n      type: 'compare'\n    }, {\n      name: 'anchor',\n      type: 'string',\n      array: true,\n      default: Anchors\n    }, {\n      name: 'offset',\n      type: 'number',\n      array: true,\n      default: [1]\n    }, {\n      name: 'padding',\n      type: 'number',\n      default: 0\n    }, {\n      name: 'lineAnchor',\n      type: 'string',\n      values: ['start', 'end'],\n      default: 'end'\n    }, {\n      name: 'markIndex',\n      type: 'number',\n      default: 0\n    }, {\n      name: 'avoidBaseMark',\n      type: 'boolean',\n      default: true\n    }, {\n      name: 'avoidMarks',\n      type: 'data',\n      array: true\n    }, {\n      name: 'method',\n      type: 'string',\n      default: 'naive'\n    }, {\n      name: 'as',\n      type: 'string',\n      array: true,\n      length: Output.length,\n      default: Output\n    }]\n  };\n  vegaUtil.inherits(Label, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      function modp(param) {\n        const p = _[param];\n        return vegaUtil.isFunction(p) && pulse.modified(p.fields);\n      }\n\n      const mod = _.modified();\n\n      if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\n\n      if (!_.size || _.size.length !== 2) {\n        vegaUtil.error('Size parameter should be specified as a [width, height] array.');\n      }\n\n      const as = _.as || Output; // run label layout\n\n      labelLayout(pulse.materialize(pulse.SOURCE).source, _.size, _.sort, vegaUtil.array(_.offset || 1), vegaUtil.array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark === false ? false : true, _.lineAnchor || 'end', _.markIndex || 0, _.padding || 0, _.method || 'naive').forEach(l => {\n        // write layout results to data stream\n        const t = l.datum;\n        t[as[0]] = l.x;\n        t[as[1]] = l.y;\n        t[as[2]] = l.opacity;\n        t[as[3]] = l.align;\n        t[as[4]] = l.baseline;\n      });\n      return pulse.reflow(mod).modifies(as);\n    }\n\n  });\n\n  exports.label = Label;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$vega_dataflow$build$vega_dataflow","~$shadow.js","~$module$node_modules$vega_scenegraph$build$vega_scenegraph","~$module$node_modules$vega_canvas$build$vega_canvas_min","~$module$node_modules$vega_util$build$vega_util"]],"~:properties",["^5",["modifies","values","invert","width","align","ratio","params","height","outOfBounds","label","x","__esModule","padding","datum","vega","setRange","name","stroke","clearRange","value","items","boundary","strokeWidth","getRange","strokeOpacity","baseline","metadata","length","required","type","y","Definition","transforms","fillOpacity","set","clear","bitmap","get","default","array","opacity"]],"~:compiled-at",1621210442460,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$vega_label$build$vega_label.js\",\n\"lineCount\":30,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/vega-label/build/vega-label.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$vega_label$build$vega_label\\\"] = function(global,require,module,exports) {\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-canvas'), require('vega-dataflow'), require('vega-scenegraph'), require('vega-util')) :\\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-canvas', 'vega-dataflow', 'vega-scenegraph', 'vega-util'], factory) :\\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega, global.vega));\\n}(this, (function (exports, vegaCanvas, vegaDataflow, vegaScenegraph, vegaUtil) { 'use strict';\\n\\n  const ALPHA_MASK = 0xff000000; // alpha value equivalent to opacity 0.0625\\n\\n  const INSIDE_OPACITY_IN_ALPHA = 0x10000000;\\n  const INSIDE_OPACITY = 0.0625;\\n  function baseBitmaps($, data) {\\n    const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided\\n\\n    (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));\\n    return [bitmap, undefined];\\n  }\\n  function markBitmaps($, avoidMarks, labelInside, isGroupArea) {\\n    // create canvas\\n    const width = $.width,\\n          height = $.height,\\n          border = labelInside || isGroupArea,\\n          context = vegaCanvas.canvas(width, height).getContext('2d'); // render all marks to be avoided into canvas\\n\\n    avoidMarks.forEach(items => draw(context, items, border)); // get canvas buffer, create bitmaps\\n\\n    const buffer = new Uint32Array(context.getImageData(0, 0, width, height).data.buffer),\\n          layer1 = $.bitmap(),\\n          layer2 = border && $.bitmap(); // populate bitmap layers\\n\\n    let x, y, u, v, alpha;\\n\\n    for (y = 0; y < height; ++y) {\\n      for (x = 0; x < width; ++x) {\\n        alpha = buffer[y * width + x] & ALPHA_MASK;\\n\\n        if (alpha) {\\n          u = $(x);\\n          v = $(y);\\n          if (!isGroupArea) layer1.set(u, v); // update interior bitmap\\n\\n          if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA) layer2.set(u, v); // update border bitmap\\n        }\\n      }\\n    }\\n\\n    return [layer1, layer2];\\n  }\\n\\n  function draw(context, items, interior) {\\n    if (!items.length) return;\\n    const type = items[0].mark.marktype;\\n\\n    if (type === 'group') {\\n      items.forEach(group => {\\n        group.items.forEach(mark => draw(context, mark.items, interior));\\n      });\\n    } else {\\n      vegaScenegraph.Marks[type].draw(context, {\\n        items: interior ? items.map(prepare) : items\\n      });\\n    }\\n  }\\n  /**\\n   * Prepare item before drawing into canvas (setting stroke and opacity)\\n   * @param {object} source item to be prepared\\n   * @returns prepared item\\n   */\\n\\n\\n  function prepare(source) {\\n    const item = vegaDataflow.rederive(source, {});\\n\\n    if (item.stroke) {\\n      item.strokeOpacity = 1;\\n    }\\n\\n    if (item.fill) {\\n      item.fillOpacity = INSIDE_OPACITY;\\n      item.stroke = '#000';\\n      item.strokeOpacity = 1;\\n      item.strokeWidth = 2;\\n    }\\n\\n    return item;\\n  }\\n\\n  const DIV = 5,\\n        // bit shift from x, y index to bit vector array index\\n  MOD = 31,\\n        // bit mask for index lookup within a bit vector\\n  SIZE = 32,\\n        // individual bit vector size\\n  RIGHT0 = new Uint32Array(SIZE + 1),\\n        // left-anchored bit vectors, full -> 0\\n  RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full\\n\\n  RIGHT1[0] = 0;\\n  RIGHT0[0] = ~RIGHT1[0];\\n\\n  for (let i = 1; i <= SIZE; ++i) {\\n    RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;\\n    RIGHT0[i] = ~RIGHT1[i];\\n  }\\n\\n  function Bitmap (w, h) {\\n    const array = new Uint32Array(~~((w * h + SIZE) / SIZE));\\n\\n    function _set(index, mask) {\\n      array[index] |= mask;\\n    }\\n\\n    function _clear(index, mask) {\\n      array[index] &= mask;\\n    }\\n\\n    return {\\n      array: array,\\n      get: (x, y) => {\\n        const index = y * w + x;\\n        return array[index >>> DIV] & 1 << (index & MOD);\\n      },\\n      set: (x, y) => {\\n        const index = y * w + x;\\n\\n        _set(index >>> DIV, 1 << (index & MOD));\\n      },\\n      clear: (x, y) => {\\n        const index = y * w + x;\\n\\n        _clear(index >>> DIV, ~(1 << (index & MOD)));\\n      },\\n      getRange: (x, y, x2, y2) => {\\n        let r = y2,\\n            start,\\n            end,\\n            indexStart,\\n            indexEnd;\\n\\n        for (; r >= y; --r) {\\n          start = r * w + x;\\n          end = r * w + x2;\\n          indexStart = start >>> DIV;\\n          indexEnd = end >>> DIV;\\n\\n          if (indexStart === indexEnd) {\\n            if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {\\n              return true;\\n            }\\n          } else {\\n            if (array[indexStart] & RIGHT0[start & MOD]) return true;\\n            if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;\\n\\n            for (let i = indexStart + 1; i < indexEnd; ++i) {\\n              if (array[i]) return true;\\n            }\\n          }\\n        }\\n\\n        return false;\\n      },\\n      setRange: (x, y, x2, y2) => {\\n        let start, end, indexStart, indexEnd, i;\\n\\n        for (; y <= y2; ++y) {\\n          start = y * w + x;\\n          end = y * w + x2;\\n          indexStart = start >>> DIV;\\n          indexEnd = end >>> DIV;\\n\\n          if (indexStart === indexEnd) {\\n            _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);\\n          } else {\\n            _set(indexStart, RIGHT0[start & MOD]);\\n\\n            _set(indexEnd, RIGHT1[(end & MOD) + 1]);\\n\\n            for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);\\n          }\\n        }\\n      },\\n      clearRange: (x, y, x2, y2) => {\\n        let start, end, indexStart, indexEnd, i;\\n\\n        for (; y <= y2; ++y) {\\n          start = y * w + x;\\n          end = y * w + x2;\\n          indexStart = start >>> DIV;\\n          indexEnd = end >>> DIV;\\n\\n          if (indexStart === indexEnd) {\\n            _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);\\n          } else {\\n            _clear(indexStart, RIGHT1[start & MOD]);\\n\\n            _clear(indexEnd, RIGHT0[(end & MOD) + 1]);\\n\\n            for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);\\n          }\\n        }\\n      },\\n      outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w\\n    };\\n  }\\n\\n  function scaler (width, height, padding) {\\n    const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),\\n          w = ~~((width + 2 * padding + ratio) / ratio),\\n          h = ~~((height + 2 * padding + ratio) / ratio),\\n          scale = _ => ~~((_ + padding) / ratio);\\n\\n    scale.invert = _ => _ * ratio - padding;\\n\\n    scale.bitmap = () => Bitmap(w, h);\\n\\n    scale.ratio = ratio;\\n    scale.padding = padding;\\n    scale.width = width;\\n    scale.height = height;\\n    return scale;\\n  }\\n\\n  function placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {\\n    const width = $.width,\\n          height = $.height; // try to place a label within an input area mark\\n\\n    return function (d) {\\n      const items = d.datum.datum.items[markIndex].items,\\n            // area points\\n      n = items.length,\\n            // number of points\\n      textHeight = d.datum.fontSize,\\n            // label width\\n      textWidth = vegaScenegraph.textMetrics.width(d.datum, d.datum.text); // label height\\n\\n      let maxAreaWidth = 0,\\n          x1,\\n          x2,\\n          y1,\\n          y2,\\n          x,\\n          y,\\n          areaWidth; // for each area sample point\\n\\n      for (let i = 0; i < n; ++i) {\\n        x1 = items[i].x;\\n        y1 = items[i].y;\\n        x2 = items[i].x2 === undefined ? x1 : items[i].x2;\\n        y2 = items[i].y2 === undefined ? y1 : items[i].y2;\\n        x = (x1 + x2) / 2;\\n        y = (y1 + y2) / 2;\\n        areaWidth = Math.abs(x2 - x1 + y2 - y1);\\n\\n        if (areaWidth >= maxAreaWidth) {\\n          maxAreaWidth = areaWidth;\\n          d.x = x;\\n          d.y = y;\\n        }\\n      }\\n\\n      x = textWidth / 2;\\n      y = textHeight / 2;\\n      x1 = d.x - x;\\n      x2 = d.x + x;\\n      y1 = d.y - y;\\n      y2 = d.y + y;\\n      d.align = 'center';\\n\\n      if (x1 < 0 && x2 <= width) {\\n        d.align = 'left';\\n      } else if (0 <= x1 && width < x2) {\\n        d.align = 'right';\\n      }\\n\\n      d.baseline = 'middle';\\n\\n      if (y1 < 0 && y2 <= height) {\\n        d.baseline = 'top';\\n      } else if (0 <= y1 && height < y2) {\\n        d.baseline = 'bottom';\\n      }\\n\\n      return true;\\n    };\\n  }\\n\\n  function outOfBounds(x, y, textWidth, textHeight, width, height) {\\n    let r = textWidth / 2;\\n    return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;\\n  }\\n  function collision($, x, y, textHeight, textWidth, h, bm0, bm1) {\\n    const w = textWidth * h / (textHeight * 2),\\n          x1 = $(x - w),\\n          x2 = $(x + w),\\n          y1 = $(y - (h = h / 2)),\\n          y2 = $(y + h);\\n    return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);\\n  }\\n\\n  function placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex) {\\n    const width = $.width,\\n          height = $.height,\\n          bm0 = bitmaps[0],\\n          // where labels have been placed\\n    bm1 = bitmaps[1]; // area outlines\\n\\n    function tryLabel(_x, _y, maxSize, textWidth, textHeight) {\\n      const x = $.invert(_x),\\n            y = $.invert(_y);\\n      let lo = maxSize,\\n          hi = height,\\n          mid;\\n\\n      if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\\n        // if the label fits at the current sample point,\\n        // perform binary search to find the largest font size that fits\\n        while (hi - lo >= 1) {\\n          mid = (lo + hi) / 2;\\n\\n          if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\\n            hi = mid;\\n          } else {\\n            lo = mid;\\n          }\\n        } // place label if current lower bound exceeds prior max font size\\n\\n\\n        if (lo > maxSize) {\\n          return [x, y, lo, true];\\n        }\\n      }\\n    } // try to place a label within an input area mark\\n\\n\\n    return function (d) {\\n      const items = d.datum.datum.items[markIndex].items,\\n            // area points\\n      n = items.length,\\n            // number of points\\n      textHeight = d.datum.fontSize,\\n            // label width\\n      textWidth = vegaScenegraph.textMetrics.width(d.datum, d.datum.text); // label height\\n\\n      let maxSize = avoidBaseMark ? textHeight : 0,\\n          labelPlaced = false,\\n          labelPlaced2 = false,\\n          maxAreaWidth = 0,\\n          x1,\\n          x2,\\n          y1,\\n          y2,\\n          x,\\n          y,\\n          _x,\\n          _y,\\n          _x1,\\n          _xMid,\\n          _x2,\\n          _y1,\\n          _yMid,\\n          _y2,\\n          areaWidth,\\n          result,\\n          swapTmp; // for each area sample point\\n\\n\\n      for (let i = 0; i < n; ++i) {\\n        x1 = items[i].x;\\n        y1 = items[i].y;\\n        x2 = items[i].x2 === undefined ? x1 : items[i].x2;\\n        y2 = items[i].y2 === undefined ? y1 : items[i].y2;\\n\\n        if (x1 > x2) {\\n          swapTmp = x1;\\n          x1 = x2;\\n          x2 = swapTmp;\\n        }\\n\\n        if (y1 > y2) {\\n          swapTmp = y1;\\n          y1 = y2;\\n          y2 = swapTmp;\\n        }\\n\\n        _x1 = $(x1);\\n        _x2 = $(x2);\\n        _xMid = ~~((_x1 + _x2) / 2);\\n        _y1 = $(y1);\\n        _y2 = $(y2);\\n        _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border\\n\\n        for (_x = _xMid; _x >= _x1; --_x) {\\n          for (_y = _yMid; _y >= _y1; --_y) {\\n            result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\\n\\n            if (result) {\\n              [d.x, d.y, maxSize, labelPlaced] = result;\\n            }\\n          }\\n        } // search along the line from mid point between the 2 border to upper border\\n\\n\\n        for (_x = _xMid; _x <= _x2; ++_x) {\\n          for (_y = _yMid; _y <= _y2; ++_y) {\\n            result = tryLabel(_x, _y, maxSize, textWidth, textHeight);\\n\\n            if (result) {\\n              [d.x, d.y, maxSize, labelPlaced] = result;\\n            }\\n          }\\n        } // place label at slice center if not placed through other means\\n        // and if we're not avoiding overlap with other areas\\n\\n\\n        if (!labelPlaced && !avoidBaseMark) {\\n          // one span is zero, hence we can add\\n          areaWidth = Math.abs(x2 - x1 + y2 - y1);\\n          x = (x1 + x2) / 2;\\n          y = (y1 + y2) / 2; // place label if it fits and improves the max area width\\n\\n          if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\\n            maxAreaWidth = areaWidth;\\n            d.x = x;\\n            d.y = y;\\n            labelPlaced2 = true;\\n          }\\n        }\\n      } // record current label placement information, update label bitmap\\n\\n\\n      if (labelPlaced || labelPlaced2) {\\n        x = textWidth / 2;\\n        y = textHeight / 2;\\n        bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\\n        d.align = 'center';\\n        d.baseline = 'middle';\\n        return true;\\n      } else {\\n        return false;\\n      }\\n    };\\n  }\\n\\n  const X_DIR = [-1, -1, 1, 1];\\n  const Y_DIR = [-1, 1, -1, 1];\\n  function placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex) {\\n    const width = $.width,\\n          height = $.height,\\n          bm0 = bitmaps[0],\\n          // where labels have been placed\\n    bm1 = bitmaps[1],\\n          // area outlines\\n    bm2 = $.bitmap(); // flood-fill visitations\\n    // try to place a label within an input area mark\\n\\n    return function (d) {\\n      const items = d.datum.datum.items[markIndex].items,\\n            // area points\\n      n = items.length,\\n            // number of points\\n      textHeight = d.datum.fontSize,\\n            // label width\\n      textWidth = vegaScenegraph.textMetrics.width(d.datum, d.datum.text),\\n            // label height\\n      stack = []; // flood fill stack\\n\\n      let maxSize = avoidBaseMark ? textHeight : 0,\\n          labelPlaced = false,\\n          labelPlaced2 = false,\\n          maxAreaWidth = 0,\\n          x1,\\n          x2,\\n          y1,\\n          y2,\\n          x,\\n          y,\\n          _x,\\n          _y,\\n          lo,\\n          hi,\\n          mid,\\n          areaWidth; // for each area sample point\\n\\n\\n      for (let i = 0; i < n; ++i) {\\n        x1 = items[i].x;\\n        y1 = items[i].y;\\n        x2 = items[i].x2 === undefined ? x1 : items[i].x2;\\n        y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack\\n\\n        stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points\\n\\n        while (stack.length) {\\n          [_x, _y] = stack.pop(); // exit if point already marked\\n\\n          if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap\\n          // add search points for all (in bound) directions\\n\\n          bm2.set(_x, _y);\\n\\n          for (let j = 0; j < 4; ++j) {\\n            x = _x + X_DIR[j];\\n            y = _y + Y_DIR[j];\\n            if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);\\n          } // unscale point back to x, y space\\n\\n\\n          x = $.invert(_x);\\n          y = $.invert(_y);\\n          lo = maxSize;\\n          hi = height; // TODO: make this bound smaller\\n\\n          if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\\n            // if the label fits at the current sample point,\\n            // perform binary search to find the largest font size that fits\\n            while (hi - lo >= 1) {\\n              mid = (lo + hi) / 2;\\n\\n              if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {\\n                hi = mid;\\n              } else {\\n                lo = mid;\\n              }\\n            } // place label if current lower bound exceeds prior max font size\\n\\n\\n            if (lo > maxSize) {\\n              d.x = x;\\n              d.y = y;\\n              maxSize = lo;\\n              labelPlaced = true;\\n            }\\n          }\\n        } // place label at slice center if not placed through other means\\n        // and if we're not avoiding overlap with other areas\\n\\n\\n        if (!labelPlaced && !avoidBaseMark) {\\n          // one span is zero, hence we can add\\n          areaWidth = Math.abs(x2 - x1 + y2 - y1);\\n          x = (x1 + x2) / 2;\\n          y = (y1 + y2) / 2; // place label if it fits and improves the max area width\\n\\n          if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {\\n            maxAreaWidth = areaWidth;\\n            d.x = x;\\n            d.y = y;\\n            labelPlaced2 = true;\\n          }\\n        }\\n      } // record current label placement information, update label bitmap\\n\\n\\n      if (labelPlaced || labelPlaced2) {\\n        x = textWidth / 2;\\n        y = textHeight / 2;\\n        bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));\\n        d.align = 'center';\\n        d.baseline = 'middle';\\n        return true;\\n      } else {\\n        return false;\\n      }\\n    };\\n  }\\n\\n  const Aligns = ['right', 'center', 'left'],\\n        Baselines = ['bottom', 'middle', 'top'];\\n  function placeMarkLabel ($, bitmaps, anchors, offsets) {\\n    const width = $.width,\\n          height = $.height,\\n          bm0 = bitmaps[0],\\n          bm1 = bitmaps[1],\\n          n = offsets.length;\\n    return function (d) {\\n      const boundary = d.boundary,\\n            textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound\\n\\n      if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {\\n        return false;\\n      }\\n\\n      let textWidth = 0,\\n          dx,\\n          dy,\\n          isInside,\\n          sizeFactor,\\n          insideFactor,\\n          x1,\\n          x2,\\n          y1,\\n          y2,\\n          xc,\\n          yc,\\n          _x1,\\n          _x2,\\n          _y1,\\n          _y2; // for each anchor and offset\\n\\n\\n      for (let i = 0; i < n; ++i) {\\n        dx = (anchors[i] & 0x3) - 1;\\n        dy = (anchors[i] >>> 0x2 & 0x3) - 1;\\n        isInside = dx === 0 && dy === 0 || offsets[i] < 0;\\n        sizeFactor = dx && dy ? Math.SQRT1_2 : 1;\\n        insideFactor = offsets[i] < 0 ? -1 : 1;\\n        x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;\\n        yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;\\n        y1 = yc - textHeight / 2;\\n        y2 = yc + textHeight / 2;\\n        _x1 = $(x1);\\n        _y1 = $(y1);\\n        _y2 = $(y2);\\n\\n        if (!textWidth) {\\n          // to avoid finding width of text label,\\n          if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {\\n            // skip this anchor/offset option if we fail to place a label with 1px width\\n            continue;\\n          } else {\\n            // Otherwise, find the label width\\n            textWidth = vegaScenegraph.textMetrics.width(d.datum, d.datum.text);\\n          }\\n        }\\n\\n        xc = x1 + insideFactor * textWidth * dx / 2;\\n        x1 = xc - textWidth / 2;\\n        x2 = xc + textWidth / 2;\\n        _x1 = $(x1);\\n        _x2 = $(x2);\\n\\n        if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {\\n          // place label if the position is placeable\\n          d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;\\n          d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;\\n          d.align = Aligns[dx * insideFactor + 1];\\n          d.baseline = Baselines[dy * insideFactor + 1];\\n          bm0.setRange(_x1, _y1, _x2, _y2);\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    };\\n  } // Test if a label with the given dimensions can be added without overlap\\n\\n  function test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {\\n    return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x1, y1, x2, y2, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));\\n  }\\n\\n  function isInMarkBound(x1, y1, x2, y2, boundary) {\\n    return boundary[0] <= x1 && x2 <= boundary[2] && boundary[3] <= y1 && y2 <= boundary[5];\\n  }\\n\\n  const TOP = 0x0,\\n        MIDDLE = 0x4,\\n        BOTTOM = 0x8,\\n        LEFT = 0x0,\\n        CENTER = 0x1,\\n        RIGHT = 0x2; // Mapping from text anchor to number representation\\n\\n  const anchorCode = {\\n    'top-left': TOP + LEFT,\\n    'top': TOP + CENTER,\\n    'top-right': TOP + RIGHT,\\n    'left': MIDDLE + LEFT,\\n    'middle': MIDDLE + CENTER,\\n    'right': MIDDLE + RIGHT,\\n    'bottom-left': BOTTOM + LEFT,\\n    'bottom': BOTTOM + CENTER,\\n    'bottom-right': BOTTOM + RIGHT\\n  };\\n  const placeAreaLabel = {\\n    'naive': placeAreaLabelNaive,\\n    'reduced-search': placeAreaLabelReducedSearch,\\n    'floodfill': placeAreaLabelFloodFill\\n  };\\n  function labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {\\n    // early exit for empty data\\n    if (!texts.length) return texts;\\n    const positions = Math.max(offset.length, anchor.length),\\n          offsets = getOffsets(offset, positions),\\n          anchors = getAnchors(anchor, positions),\\n          marktype = markType(texts[0].datum),\\n          grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,\\n          isGroupArea = grouptype === 'area',\\n          boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),\\n          $ = scaler(size[0], size[1], padding),\\n          isNaiveGroupArea = isGroupArea && method === 'naive'; // prepare text mark data for placing\\n\\n    const data = texts.map(d => ({\\n      datum: d,\\n      opacity: 0,\\n      x: undefined,\\n      y: undefined,\\n      align: undefined,\\n      baseline: undefined,\\n      boundary: boundary(d)\\n    }));\\n    let bitmaps;\\n\\n    if (!isNaiveGroupArea) {\\n      // sort labels in priority order, if comparator is provided\\n      if (compare) {\\n        data.sort((a, b) => compare(a.datum, b.datum));\\n      } // flag indicating if label can be placed inside its base mark\\n\\n\\n      let labelInside = false;\\n\\n      for (let i = 0; i < anchors.length && !labelInside; ++i) {\\n        // label inside if anchor is at center\\n        // label inside if offset to be inside the mark bound\\n        labelInside = anchors[i] === 0x5 || offsets[i] < 0;\\n      } // extract data information from base mark when base mark is to be avoided\\n      // base mark is implicitly avoided if it is a group area\\n\\n\\n      if (marktype && (avoidBaseMark || isGroupArea)) {\\n        avoidMarks = [texts.map(d => d.datum)].concat(avoidMarks);\\n      } // generate bitmaps for layout calculation\\n\\n\\n      bitmaps = avoidMarks.length ? markBitmaps($, avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);\\n    } // generate label placement function\\n\\n\\n    const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($, bitmaps, anchors, offsets); // place all labels\\n\\n    data.forEach(d => d.opacity = +place(d));\\n    return data;\\n  }\\n\\n  function getOffsets(_, count) {\\n    const offsets = new Float64Array(count),\\n          n = _.length;\\n\\n    for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;\\n\\n    for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];\\n\\n    return offsets;\\n  }\\n\\n  function getAnchors(_, count) {\\n    const anchors = new Int8Array(count),\\n          n = _.length;\\n\\n    for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];\\n\\n    for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];\\n\\n    return anchors;\\n  }\\n\\n  function markType(item) {\\n    return item && item.mark && item.mark.marktype;\\n  }\\n  /**\\n   * Factory function for function for getting base mark boundary, depending\\n   * on mark and group type. When mark type is undefined, line or area: boundary\\n   * is the coordinate of each data point. When base mark is grouped line,\\n   * boundary is either at the beginning or end of the line depending on the\\n   * value of lineAnchor. Otherwise, use bounds of base mark.\\n   */\\n\\n\\n  function markBoundary(marktype, grouptype, lineAnchor, markIndex) {\\n    const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];\\n\\n    if (!marktype) {\\n      return xy; // no reactive geometry\\n    } else if (marktype === 'line' || marktype === 'area') {\\n      return d => xy(d.datum);\\n    } else if (grouptype === 'line') {\\n      return d => {\\n        const items = d.datum.items[markIndex].items;\\n        return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {\\n          x: NaN,\\n          y: NaN\\n        });\\n      };\\n    } else {\\n      return d => {\\n        const b = d.datum.bounds;\\n        return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];\\n      };\\n    }\\n  }\\n\\n  const Output = ['x', 'y', 'opacity', 'align', 'baseline'];\\n  const Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];\\n  /**\\n   * Compute text label layout to annotate marks.\\n   * @constructor\\n   * @param {object} params - The parameters for this operator.\\n   * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.\\n   * @param {function(*,*): number} [params.sort] - An optional\\n   *   comparator function for sorting label data in priority order.\\n   * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.\\n   *   The available options are 'top-left', 'left', 'bottom-left', 'top',\\n   *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.\\n   * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.\\n   *   This parameter  is parallel to the list of anchor points.\\n   * @param {number} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.\\n   * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor\\n   *   position for labels. One of 'start' or 'end'.\\n   * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating\\n   *   which mark within the group should be labeled.\\n   * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label\\n   *   layout should avoid overlap.\\n   * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid\\n   *   overlap with the underlying base mark being labeled.\\n   * @param {string} [params.method='naive'] - For area make labels only, a method for\\n   *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.\\n   * @param {Array<string>} [params.as] - The output fields written by the transform.\\n   *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].\\n   */\\n\\n  function Label(params) {\\n    vegaDataflow.Transform.call(this, null, params);\\n  }\\n  Label.Definition = {\\n    type: 'Label',\\n    metadata: {\\n      modifies: true\\n    },\\n    params: [{\\n      name: 'size',\\n      type: 'number',\\n      array: true,\\n      length: 2,\\n      required: true\\n    }, {\\n      name: 'sort',\\n      type: 'compare'\\n    }, {\\n      name: 'anchor',\\n      type: 'string',\\n      array: true,\\n      default: Anchors\\n    }, {\\n      name: 'offset',\\n      type: 'number',\\n      array: true,\\n      default: [1]\\n    }, {\\n      name: 'padding',\\n      type: 'number',\\n      default: 0\\n    }, {\\n      name: 'lineAnchor',\\n      type: 'string',\\n      values: ['start', 'end'],\\n      default: 'end'\\n    }, {\\n      name: 'markIndex',\\n      type: 'number',\\n      default: 0\\n    }, {\\n      name: 'avoidBaseMark',\\n      type: 'boolean',\\n      default: true\\n    }, {\\n      name: 'avoidMarks',\\n      type: 'data',\\n      array: true\\n    }, {\\n      name: 'method',\\n      type: 'string',\\n      default: 'naive'\\n    }, {\\n      name: 'as',\\n      type: 'string',\\n      array: true,\\n      length: Output.length,\\n      default: Output\\n    }]\\n  };\\n  vegaUtil.inherits(Label, vegaDataflow.Transform, {\\n    transform(_, pulse) {\\n      function modp(param) {\\n        const p = _[param];\\n        return vegaUtil.isFunction(p) && pulse.modified(p.fields);\\n      }\\n\\n      const mod = _.modified();\\n\\n      if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;\\n\\n      if (!_.size || _.size.length !== 2) {\\n        vegaUtil.error('Size parameter should be specified as a [width, height] array.');\\n      }\\n\\n      const as = _.as || Output; // run label layout\\n\\n      labelLayout(pulse.materialize(pulse.SOURCE).source, _.size, _.sort, vegaUtil.array(_.offset || 1), vegaUtil.array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark === false ? false : true, _.lineAnchor || 'end', _.markIndex || 0, _.padding || 0, _.method || 'naive').forEach(l => {\\n        // write layout results to data stream\\n        const t = l.datum;\\n        t[as[0]] = l.x;\\n        t[as[1]] = l.y;\\n        t[as[2]] = l.opacity;\\n        t[as[3]] = l.align;\\n        t[as[4]] = l.baseline;\\n      });\\n      return pulse.reflow(mod).modifies(as);\\n    }\\n\\n  });\\n\\n  exports.label = Label;\\n\\n  Object.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"factory\",\"define\",\"amd\",\"globalThis\",\"self\",\"vega\",\"transforms\",\"vegaCanvas\",\"vegaDataflow\",\"vegaScenegraph\",\"vegaUtil\",\"baseBitmaps\",\"$\",\"data\",\"bitmap\",\"forEach\",\"d\",\"set\",\"boundary\",\"undefined\",\"markBitmaps\",\"avoidMarks\",\"labelInside\",\"isGroupArea\",\"width\",\"height\",\"border\",\"context\",\"canvas\",\"getContext\",\"items\",\"draw\",\"buffer\",\"Uint32Array\",\"getImageData\",\"layer1\",\"layer2\",\"x\",\"y\",\"u\",\"v\",\"alpha\",\"ALPHA_MASK\",\"INSIDE_OPACITY_IN_ALPHA\",\"interior\",\"length\",\"type\",\"mark\",\"marktype\",\"group\",\"Marks\",\"map\",\"prepare\",\"source\",\"item\",\"rederive\",\"stroke\",\"strokeOpacity\",\"fill\",\"fillOpacity\",\"INSIDE_OPACITY\",\"strokeWidth\",\"Bitmap\",\"w\",\"h\",\"array\",\"SIZE\",\"get\",\"index\",\"DIV\",\"MOD\",\"clear\",\"mask\",\"getRange\",\"x2\",\"y2\",\"end\",\"indexStart\",\"indexEnd\",\"r\",\"start\",\"RIGHT0\",\"RIGHT1\",\"i\",\"setRange\",\"clearRange\",\"outOfBounds\",\"scaler\",\"padding\",\"ratio\",\"Math\",\"max\",\"sqrt\",\"scale\",\"_\",\"invert\",\"scale.invert\",\"scale.bitmap\",\"textWidth\",\"textHeight\",\"collision\",\"bm0\",\"bm1\",\"x1\",\"y1\",\"placeMarkLabel\",\"bitmaps\",\"anchors\",\"offsets\",\"n\",\"datum\",\"fontSize\",\"dx\",\"dy\",\"insideFactor\",\"yc\",\"_y1\",\"_y2\",\"isInside\",\"sizeFactor\",\"SQRT1_2\",\"_x1\",\"_x2\",\"textMetrics\",\"text\",\"xc\",\"align\",\"Aligns\",\"baseline\",\"Baselines\",\"labelLayout\",\"texts\",\"size\",\"compare\",\"offset\",\"anchor\",\"avoidBaseMark\",\"lineAnchor\",\"markIndex\",\"method\",\"positions\",\"getOffsets\",\"getAnchors\",\"markType\",\"grouptype\",\"markBoundary\",\"isNaiveGroupArea\",\"opacity\",\"sort\",\"a\",\"b\",\"concat\",\"place\",\"placeAreaLabel\",\"count\",\"Float64Array\",\"Int8Array\",\"anchorCode\",\"xy\",\"NaN\",\"bounds\",\"Label\",\"params\",\"Transform\",\"call\",\"X_DIR\",\"Y_DIR\",\"placeAreaLabelNaive\",\"maxAreaWidth\",\"areaWidth\",\"abs\",\"placeAreaLabelReducedSearch\",\"tryLabel\",\"_x\",\"_y\",\"maxSize\",\"lo\",\"hi\",\"mid\",\"labelPlaced\",\"labelPlaced2\",\"_xMid\",\"_yMid\",\"result\",\"swapTmp\",\"placeAreaLabelFloodFill\",\"bm2\",\"stack\",\"push\",\"pop\",\"j\",\"Output\",\"Anchors\",\"Definition\",\"metadata\",\"modifies\",\"name\",\"required\",\"default\",\"values\",\"inherits\",\"transform\",\"pulse\",\"modp\",\"param\",\"p\",\"isFunction\",\"modified\",\"fields\",\"mod\",\"changed\",\"ADD_REM\",\"error\",\"as\",\"materialize\",\"SOURCE\",\"l\",\"t\",\"reflow\",\"label\",\"Object\",\"defineProperty\",\"value\"]\n}\n"]