["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-grid-layout/build/calculateUtils.js"],"~:js","shadow$provide.module$node_modules$react_grid_layout$build$calculateUtils=function(global,require,module,exports){function calcGridColWidth(positionParams){var cols=positionParams.cols;return(positionParams.containerWidth-positionParams.margin[0]*(cols-1)-2*positionParams.containerPadding[0])/cols}function calcGridItemWHPx(gridUnits,colOrRowSize,marginPx){return Number.isFinite(gridUnits)?Math.round(colOrRowSize*gridUnits+Math.max(0,gridUnits-1)*marginPx):gridUnits}function clamp(num,lowerBound,upperBound){return Math.max(Math.min(num,\nupperBound),lowerBound)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.calcGridColWidth=calcGridColWidth;exports.calcGridItemWHPx=calcGridItemWHPx;exports.calcGridItemPosition=function(positionParams,x,y,w,h,state){var margin=positionParams.margin,containerPadding=positionParams.containerPadding,rowHeight=positionParams.rowHeight;positionParams=calcGridColWidth(positionParams);var out={};state&&state.resizing?(out.width=Math.round(state.resizing.width),out.height=Math.round(state.resizing.height)):\n(out.width=calcGridItemWHPx(w,positionParams,margin[0]),out.height=calcGridItemWHPx(h,rowHeight,margin[1]));state&&state.dragging?(out.top=Math.round(state.dragging.top),out.left=Math.round(state.dragging.left)):(out.top=Math.round((rowHeight+margin[1])*y+containerPadding[1]),out.left=Math.round((positionParams+margin[0])*x+containerPadding[0]));return out};exports.calcXY=function(positionParams,top,left,w,h){var margin=positionParams.margin,cols=positionParams.cols,rowHeight=positionParams.rowHeight,\nmaxRows=positionParams.maxRows;positionParams=calcGridColWidth(positionParams);left=Math.round((left-margin[0])/(positionParams+margin[0]));top=Math.round((top-margin[1])/(rowHeight+margin[1]));left=clamp(left,0,cols-w);top=clamp(top,0,maxRows-h);return{x:left,y:top}};exports.calcWH=function(positionParams,width,height,x,y){var margin=positionParams.margin,maxRows=positionParams.maxRows,cols=positionParams.cols,rowHeight=positionParams.rowHeight;positionParams=calcGridColWidth(positionParams);width=\nMath.round((width+margin[0])/(positionParams+margin[0]));height=Math.round((height+margin[1])/(rowHeight+margin[1]));width=clamp(width,0,cols-x);height=clamp(height,0,maxRows-y);return{w:width,h:height}};exports.clamp=clamp}","~:source","shadow$provide[\"module$node_modules$react_grid_layout$build$calculateUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcXY = calcXY;\nexports.calcWH = calcWH;\nexports.clamp = clamp;\n\n/*:: import type { Position } from \"./utils\";*/\n\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams\n/*: PositionParams*/\n)\n/*: number*/\n{\n  var margin = positionParams.margin,\n      containerPadding = positionParams.containerPadding,\n      containerWidth = positionParams.containerWidth,\n      cols = positionParams.cols;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n} // This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\n\n\nfunction calcGridItemWHPx(gridUnits\n/*: number*/\n, colOrRowSize\n/*: number*/\n, marginPx\n/*: number*/\n)\n/*: number*/\n{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\n\n\nfunction calcGridItemPosition(positionParams\n/*: PositionParams*/\n, x\n/*: number*/\n, y\n/*: number*/\n, w\n/*: number*/\n, h\n/*: number*/\n, state\n/*: ?Object*/\n)\n/*: Position*/\n{\n  var margin = positionParams.margin,\n      containerPadding = positionParams.containerPadding,\n      rowHeight = positionParams.rowHeight;\n  var colWidth = calcGridColWidth(positionParams);\n  var out = {}; // If resizing, use the exact width and height as returned from resizing callbacks.\n\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  } // Otherwise, calculate from grid units.\n  else {\n      out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n      out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n    } // If dragging, use the exact width and height as returned from dragging callbacks.\n\n\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } // Otherwise, calculate from grid units.\n  else {\n      out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n      out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n    }\n\n  return out;\n}\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\n\n\nfunction calcXY(positionParams\n/*: PositionParams*/\n, top\n/*: number*/\n, left\n/*: number*/\n, w\n/*: number*/\n, h\n/*: number*/\n)\n/*: { x: number, y: number }*/\n{\n  var margin = positionParams.margin,\n      cols = positionParams.cols,\n      rowHeight = positionParams.rowHeight,\n      maxRows = positionParams.maxRows;\n  var colWidth = calcGridColWidth(positionParams); // left = colWidth * x + margin * (x + 1)\n  // l = cx + m(x+1)\n  // l = cx + mx + m\n  // l - m = cx + mx\n  // l - m = x(c + m)\n  // (l - m) / (c + m) = x\n  // x = (left - margin) / (coldWidth + margin)\n\n  var x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n  var y = Math.round((top - margin[1]) / (rowHeight + margin[1])); // Capping\n\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @return {Object}                         w, h as grid units.\n */\n\n\nfunction calcWH(positionParams\n/*: PositionParams*/\n, width\n/*: number*/\n, height\n/*: number*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: { w: number, h: number }*/\n{\n  var margin = positionParams.margin,\n      maxRows = positionParams.maxRows,\n      cols = positionParams.cols,\n      rowHeight = positionParams.rowHeight;\n  var colWidth = calcGridColWidth(positionParams); // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n\n  var w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  var h = Math.round((height + margin[1]) / (rowHeight + margin[1])); // Capping\n\n  w = clamp(w, 0, cols - x);\n  h = clamp(h, 0, maxRows - y);\n  return {\n    w: w,\n    h: h\n  };\n} // Similar to _.clamp\n\n\nfunction clamp(num\n/*: number*/\n, lowerBound\n/*: number*/\n, upperBound\n/*: number*/\n)\n/*: number*/\n{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["w","width","calcGridItemPosition","top","height","x","__esModule","calcGridItemWHPx","calcXY","value","clamp","calcWH","y","calcGridColWidth","h","left"]],"~:compiled-at",1621210442661,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_grid_layout$build$calculateUtils.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-grid-layout/build/calculateUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_grid_layout$build$calculateUtils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.calcGridColWidth = calcGridColWidth;\\nexports.calcGridItemWHPx = calcGridItemWHPx;\\nexports.calcGridItemPosition = calcGridItemPosition;\\nexports.calcXY = calcXY;\\nexports.calcWH = calcWH;\\nexports.clamp = clamp;\\n\\n/*:: import type { Position } from \\\"./utils\\\";*/\\n\\n/*:: export type PositionParams = {\\n  margin: [number, number],\\n  containerPadding: [number, number],\\n  containerWidth: number,\\n  cols: number,\\n  rowHeight: number,\\n  maxRows: number\\n};*/\\n// Helper for generating column width\\nfunction calcGridColWidth(positionParams\\n/*: PositionParams*/\\n)\\n/*: number*/\\n{\\n  var margin = positionParams.margin,\\n      containerPadding = positionParams.containerPadding,\\n      containerWidth = positionParams.containerWidth,\\n      cols = positionParams.cols;\\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\\n} // This can either be called:\\n// calcGridItemWHPx(w, colWidth, margin[0])\\n// or\\n// calcGridItemWHPx(h, rowHeight, margin[1])\\n\\n\\nfunction calcGridItemWHPx(gridUnits\\n/*: number*/\\n, colOrRowSize\\n/*: number*/\\n, marginPx\\n/*: number*/\\n)\\n/*: number*/\\n{\\n  // 0 * Infinity === NaN, which causes problems with resize contraints\\n  if (!Number.isFinite(gridUnits)) return gridUnits;\\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\\n}\\n/**\\n * Return position on the page given an x, y, w, h.\\n * left, top, width, height are all in pixels.\\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\\n * @param  {Number}  x                      X coordinate in grid units.\\n * @param  {Number}  y                      Y coordinate in grid units.\\n * @param  {Number}  w                      W coordinate in grid units.\\n * @param  {Number}  h                      H coordinate in grid units.\\n * @return {Position}                       Object containing coords.\\n */\\n\\n\\nfunction calcGridItemPosition(positionParams\\n/*: PositionParams*/\\n, x\\n/*: number*/\\n, y\\n/*: number*/\\n, w\\n/*: number*/\\n, h\\n/*: number*/\\n, state\\n/*: ?Object*/\\n)\\n/*: Position*/\\n{\\n  var margin = positionParams.margin,\\n      containerPadding = positionParams.containerPadding,\\n      rowHeight = positionParams.rowHeight;\\n  var colWidth = calcGridColWidth(positionParams);\\n  var out = {}; // If resizing, use the exact width and height as returned from resizing callbacks.\\n\\n  if (state && state.resizing) {\\n    out.width = Math.round(state.resizing.width);\\n    out.height = Math.round(state.resizing.height);\\n  } // Otherwise, calculate from grid units.\\n  else {\\n      out.width = calcGridItemWHPx(w, colWidth, margin[0]);\\n      out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\\n    } // If dragging, use the exact width and height as returned from dragging callbacks.\\n\\n\\n  if (state && state.dragging) {\\n    out.top = Math.round(state.dragging.top);\\n    out.left = Math.round(state.dragging.left);\\n  } // Otherwise, calculate from grid units.\\n  else {\\n      out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\\n      out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\\n    }\\n\\n  return out;\\n}\\n/**\\n * Translate x and y coordinates from pixels to grid units.\\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\\n * @param  {Number} top                     Top position (relative to parent) in pixels.\\n * @param  {Number} left                    Left position (relative to parent) in pixels.\\n * @param  {Number} w                       W coordinate in grid units.\\n * @param  {Number} h                       H coordinate in grid units.\\n * @return {Object}                         x and y in grid units.\\n */\\n\\n\\nfunction calcXY(positionParams\\n/*: PositionParams*/\\n, top\\n/*: number*/\\n, left\\n/*: number*/\\n, w\\n/*: number*/\\n, h\\n/*: number*/\\n)\\n/*: { x: number, y: number }*/\\n{\\n  var margin = positionParams.margin,\\n      cols = positionParams.cols,\\n      rowHeight = positionParams.rowHeight,\\n      maxRows = positionParams.maxRows;\\n  var colWidth = calcGridColWidth(positionParams); // left = colWidth * x + margin * (x + 1)\\n  // l = cx + m(x+1)\\n  // l = cx + mx + m\\n  // l - m = cx + mx\\n  // l - m = x(c + m)\\n  // (l - m) / (c + m) = x\\n  // x = (left - margin) / (coldWidth + margin)\\n\\n  var x = Math.round((left - margin[0]) / (colWidth + margin[0]));\\n  var y = Math.round((top - margin[1]) / (rowHeight + margin[1])); // Capping\\n\\n  x = clamp(x, 0, cols - w);\\n  y = clamp(y, 0, maxRows - h);\\n  return {\\n    x: x,\\n    y: y\\n  };\\n}\\n/**\\n * Given a height and width in pixel values, calculate grid units.\\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\\n * @param  {Number} height                  Height in pixels.\\n * @param  {Number} width                   Width in pixels.\\n * @param  {Number} x                       X coordinate in grid units.\\n * @param  {Number} y                       Y coordinate in grid units.\\n * @return {Object}                         w, h as grid units.\\n */\\n\\n\\nfunction calcWH(positionParams\\n/*: PositionParams*/\\n, width\\n/*: number*/\\n, height\\n/*: number*/\\n, x\\n/*: number*/\\n, y\\n/*: number*/\\n)\\n/*: { w: number, h: number }*/\\n{\\n  var margin = positionParams.margin,\\n      maxRows = positionParams.maxRows,\\n      cols = positionParams.cols,\\n      rowHeight = positionParams.rowHeight;\\n  var colWidth = calcGridColWidth(positionParams); // width = colWidth * w - (margin * (w - 1))\\n  // ...\\n  // w = (width + margin) / (colWidth + margin)\\n\\n  var w = Math.round((width + margin[0]) / (colWidth + margin[0]));\\n  var h = Math.round((height + margin[1]) / (rowHeight + margin[1])); // Capping\\n\\n  w = clamp(w, 0, cols - x);\\n  h = clamp(h, 0, maxRows - y);\\n  return {\\n    w: w,\\n    h: h\\n  };\\n} // Similar to _.clamp\\n\\n\\nfunction clamp(num\\n/*: number*/\\n, lowerBound\\n/*: number*/\\n, upperBound\\n/*: number*/\\n)\\n/*: number*/\\n{\\n  return Math.max(Math.min(num, upperBound), lowerBound);\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"calcGridColWidth\",\"positionParams\",\"cols\",\"containerWidth\",\"margin\",\"containerPadding\",\"calcGridItemWHPx\",\"gridUnits\",\"colOrRowSize\",\"marginPx\",\"Number\",\"isFinite\",\"Math\",\"round\",\"max\",\"clamp\",\"num\",\"lowerBound\",\"upperBound\",\"min\",\"Object\",\"defineProperty\",\"value\",\"calcGridItemPosition\",\"x\",\"y\",\"w\",\"h\",\"state\",\"rowHeight\",\"colWidth\",\"out\",\"resizing\",\"width\",\"height\",\"dragging\",\"top\",\"left\",\"calcXY\",\"maxRows\",\"calcWH\"]\n}\n"]