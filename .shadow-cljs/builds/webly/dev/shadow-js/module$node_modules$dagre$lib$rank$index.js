["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/dagre/lib/rank/index.js"],"~:js","shadow$provide.module$node_modules$dagre$lib$rank$index=function(global,require,module,exports){var longestPath=require(\"module$node_modules$dagre$lib$rank$util\").longestPath,feasibleTree=require(\"module$node_modules$dagre$lib$rank$feasible_tree\"),networkSimplex=require(\"module$node_modules$dagre$lib$rank$network_simplex\");module.exports=function(g){switch(g.graph().ranker){case \"network-simplex\":networkSimplex(g);break;case \"tight-tree\":longestPath(g);feasibleTree(g);break;case \"longest-path\":longestPathRanker(g);\nbreak;default:networkSimplex(g)}};var longestPathRanker=longestPath}","~:source","shadow$provide[\"module$node_modules$dagre$lib$rank$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar rankUtil = require(\"./util\");\nvar longestPath = rankUtil.longestPath;\nvar feasibleTree = require(\"./feasible-tree\");\nvar networkSimplex = require(\"./network-simplex\");\n\nmodule.exports = rank;\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch(g.graph().ranker) {\n  case \"network-simplex\": networkSimplexRanker(g); break;\n  case \"tight-tree\": tightTreeRanker(g); break;\n  case \"longest-path\": longestPathRanker(g); break;\n  default: networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$dagre$lib$rank$util","~$module$node_modules$dagre$lib$rank$feasible_tree","~$shadow.js","~$module$node_modules$dagre$lib$rank$network_simplex"]],"~:properties",["^5",[]],"~:compiled-at",1621210442121,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$dagre$lib$rank$index.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,CAAA,wCAAA,CAA6D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAIrG,IAAIC,YADWH,OAAAI,CAAQ,yCAARA,CACYD,CAAAA,WAA3B,CACIE,aAAeL,OAAA,CAAQ,kDAAR,CADnB,CAEIM,eAAiBN,OAAA,CAAQ,oDAAR,CAErBC,OAAOC,CAAAA,OAAP,CAqBAK,QAAa,CAACC,CAAD,CAAI,CACf,OAAOA,CAAEC,CAAAA,KAAF,EAAUC,CAAAA,MAAjB,EACA,KAAK,iBAAL,CAgBAJ,cAAA,CAhB6CE,CAgB7C,CAhBiD,MACjD,MAAK,YAAL,CAUAL,WAAA,CAVmCK,CAUnC,CACAH,aAAA,CAXmCG,CAWnC,CAXuC,MACvC,MAAK,cAAL,CAAqBG,iBAAA,CAAkBH,CAAlB,CAAsB;KAC3C,SAaAF,cAAA,CAb8BE,CAa9B,CAjBA,CADe,CAUjB,KAAIG,kBAAoBR,WAvC6E;\",\n\"sources\":[\"node_modules/dagre/lib/rank/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$dagre$lib$rank$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar rankUtil = require(\\\"./util\\\");\\nvar longestPath = rankUtil.longestPath;\\nvar feasibleTree = require(\\\"./feasible-tree\\\");\\nvar networkSimplex = require(\\\"./network-simplex\\\");\\n\\nmodule.exports = rank;\\n\\n/*\\n * Assigns a rank to each node in the input graph that respects the \\\"minlen\\\"\\n * constraint specified on edges between nodes.\\n *\\n * This basic structure is derived from Gansner, et al., \\\"A Technique for\\n * Drawing Directed Graphs.\\\"\\n *\\n * Pre-conditions:\\n *\\n *    1. Graph must be a connected DAG\\n *    2. Graph nodes must be objects\\n *    3. Graph edges must have \\\"weight\\\" and \\\"minlen\\\" attributes\\n *\\n * Post-conditions:\\n *\\n *    1. Graph nodes will have a \\\"rank\\\" attribute based on the results of the\\n *       algorithm. Ranks can start at any index (including negative), we'll\\n *       fix them up later.\\n */\\nfunction rank(g) {\\n  switch(g.graph().ranker) {\\n  case \\\"network-simplex\\\": networkSimplexRanker(g); break;\\n  case \\\"tight-tree\\\": tightTreeRanker(g); break;\\n  case \\\"longest-path\\\": longestPathRanker(g); break;\\n  default: networkSimplexRanker(g);\\n  }\\n}\\n\\n// A fast and simple ranker, but results are far from optimal.\\nvar longestPathRanker = longestPath;\\n\\nfunction tightTreeRanker(g) {\\n  longestPath(g);\\n  feasibleTree(g);\\n}\\n\\nfunction networkSimplexRanker(g) {\\n  networkSimplex(g);\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"longestPath\",\"rankUtil\",\"feasibleTree\",\"networkSimplex\",\"rank\",\"g\",\"graph\",\"ranker\",\"longestPathRanker\"]\n}\n"]