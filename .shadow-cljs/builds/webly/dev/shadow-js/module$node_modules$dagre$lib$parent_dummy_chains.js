["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/dagre/lib/parent-dummy-chains.js"],"~:js","shadow$provide.module$node_modules$dagre$lib$parent_dummy_chains=function(global,require,module,exports){function postorder(g){function dfs(v){var low=lim;_.forEach(g.children(v),dfs);result[v]={low,lim:lim++}}var result={},lim=0;_.forEach(g.children(),dfs);return result}var _=require(\"module$node_modules$dagre$lib$lodash\");module.exports=function(g){var postorderNums=postorder(g);_.forEach(g.graph().dummyChains,function(v$jscomp$0){var node=g.node(v$jscomp$0),edgeObj=node.edgeObj,v=edgeObj.v;var JSCompiler_object_inline_path_5295=\nedgeObj.w;node=[];var wPath=[],low=Math.min(postorderNums[v].low,postorderNums[JSCompiler_object_inline_path_5295].low),lim=Math.max(postorderNums[v].lim,postorderNums[JSCompiler_object_inline_path_5295].lim);do v=g.parent(v),node.push(v);while(v&&(postorderNums[v].low>low||lim>postorderNums[v].lim));low=v;for(v=JSCompiler_object_inline_path_5295;(v=g.parent(v))!==low;)wPath.push(v);JSCompiler_object_inline_path_5295=node.concat(wPath.reverse());wPath=0;lim=JSCompiler_object_inline_path_5295[wPath];\nfor(v=!0;v$jscomp$0!==edgeObj.w;){node=g.node(v$jscomp$0);if(v){for(;(lim=JSCompiler_object_inline_path_5295[wPath])!==low&&g.node(lim).maxRank<node.rank;)wPath++;lim===low&&(v=!1)}if(!v){for(;wPath<JSCompiler_object_inline_path_5295.length-1&&g.node(JSCompiler_object_inline_path_5295[wPath+1]).minRank<=node.rank;)wPath++;lim=JSCompiler_object_inline_path_5295[wPath]}g.setParent(v$jscomp$0,lim);v$jscomp$0=g.successors(v$jscomp$0)[0]}})}}","~:source","shadow$provide[\"module$node_modules$dagre$lib$parent_dummy_chains\"] = function(global,require,module,exports) {\nvar _ = require(\"./lodash\");\n\nmodule.exports = parentDummyChains;\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _.forEach(g.graph().dummyChains, function(v) {\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca &&\n               g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 &&\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent;\n  var lca;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent &&\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\n\nfunction postorder(g) {\n  var result = {};\n  var lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n    _.forEach(g.children(v), dfs);\n    result[v] = { low: low, lim: lim++ };\n  }\n  _.forEach(g.children(), dfs);\n\n  return result;\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$dagre$lib$lodash"]],"~:properties",["^5",["low","lim"]],"~:compiled-at",1621210442122,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$dagre$lib$parent_dummy_chains.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/dagre/lib/parent-dummy-chains.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$dagre$lib$parent_dummy_chains\\\"] = function(global,require,module,exports) {\\nvar _ = require(\\\"./lodash\\\");\\n\\nmodule.exports = parentDummyChains;\\n\\nfunction parentDummyChains(g) {\\n  var postorderNums = postorder(g);\\n\\n  _.forEach(g.graph().dummyChains, function(v) {\\n    var node = g.node(v);\\n    var edgeObj = node.edgeObj;\\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\\n    var path = pathData.path;\\n    var lca = pathData.lca;\\n    var pathIdx = 0;\\n    var pathV = path[pathIdx];\\n    var ascending = true;\\n\\n    while (v !== edgeObj.w) {\\n      node = g.node(v);\\n\\n      if (ascending) {\\n        while ((pathV = path[pathIdx]) !== lca &&\\n               g.node(pathV).maxRank < node.rank) {\\n          pathIdx++;\\n        }\\n\\n        if (pathV === lca) {\\n          ascending = false;\\n        }\\n      }\\n\\n      if (!ascending) {\\n        while (pathIdx < path.length - 1 &&\\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\\n          pathIdx++;\\n        }\\n        pathV = path[pathIdx];\\n      }\\n\\n      g.setParent(v, pathV);\\n      v = g.successors(v)[0];\\n    }\\n  });\\n}\\n\\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\\n// full path and the LCA.\\nfunction findPath(g, postorderNums, v, w) {\\n  var vPath = [];\\n  var wPath = [];\\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\\n  var parent;\\n  var lca;\\n\\n  // Traverse up from v to find the LCA\\n  parent = v;\\n  do {\\n    parent = g.parent(parent);\\n    vPath.push(parent);\\n  } while (parent &&\\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\\n  lca = parent;\\n\\n  // Traverse from w to LCA\\n  parent = w;\\n  while ((parent = g.parent(parent)) !== lca) {\\n    wPath.push(parent);\\n  }\\n\\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\\n}\\n\\nfunction postorder(g) {\\n  var result = {};\\n  var lim = 0;\\n\\n  function dfs(v) {\\n    var low = lim;\\n    _.forEach(g.children(v), dfs);\\n    result[v] = { low: low, lim: lim++ };\\n  }\\n  _.forEach(g.children(), dfs);\\n\\n  return result;\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"postorder\",\"g\",\"dfs\",\"v\",\"low\",\"lim\",\"_\",\"forEach\",\"children\",\"result\",\"parentDummyChains\",\"postorderNums\",\"graph\",\"dummyChains\",\"node\",\"edgeObj\",\"w\",\"vPath\",\"wPath\",\"Math\",\"min\",\"max\",\"parent\",\"push\",\"lca\",\"concat\",\"reverse\",\"pathIdx\",\"pathV\",\"path\",\"ascending\",\"maxRank\",\"rank\",\"length\",\"minRank\",\"setParent\",\"successors\"]\n}\n"]