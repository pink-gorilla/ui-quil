["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/base64-js/index.js"],"~:js","shadow$provide.module$node_modules$base64_js$index=function(global,require,module,exports){function getLens(b64){var len=b64.length;if(0<len%4)throw Error(\"Invalid string. Length must be a multiple of 4\");b64=b64.indexOf(\"\\x3d\");-1===b64&&(b64=len);return[b64,b64===len?0:4-b64%4]}exports.byteLength=function(b64){b64=getLens(b64);var placeHoldersLen=b64[1];return 3*(b64[0]+placeHoldersLen)/4-placeHoldersLen};exports.toByteArray=function(b64){var lens=getLens(b64);var tmp=lens[0];lens=lens[1];var arr=\nnew Arr(3*(tmp+lens)/4-lens),curByte=0,len=0<lens?tmp-4:tmp,i;for(i=0;i<len;i+=4)tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)],arr[curByte++]=tmp>>16&255,arr[curByte++]=tmp>>8&255,arr[curByte++]=tmp&255;2===lens&&(tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4,arr[curByte++]=tmp&255);1===lens&&(tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+\n2)]>>2,arr[curByte++]=tmp>>8&255,arr[curByte++]=tmp&255);return arr};exports.fromByteArray=function(uint8$jscomp$0){for(var len=uint8$jscomp$0.length,extraBytes=len%3,parts=[],i=0,len2=len-extraBytes;i<len2;i+=16383){for(var JSCompiler_temp_const=parts,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.push,JSCompiler_inline_result,uint8=uint8$jscomp$0,end=i+16383>len2?len2:i+16383,output=[],i$jscomp$0=i;i$jscomp$0<end;i$jscomp$0+=3)JSCompiler_inline_result=(uint8[i$jscomp$0]<<16&16711680)+(uint8[i$jscomp$0+\n1]<<8&65280)+(uint8[i$jscomp$0+2]&255),output.push(lookup[JSCompiler_inline_result>>18&63]+lookup[JSCompiler_inline_result>>12&63]+lookup[JSCompiler_inline_result>>6&63]+lookup[JSCompiler_inline_result&63]);JSCompiler_inline_result=output.join(\"\");JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,JSCompiler_inline_result)}1===extraBytes?(uint8$jscomp$0=uint8$jscomp$0[len-1],parts.push(lookup[uint8$jscomp$0>>2]+lookup[uint8$jscomp$0<<4&63]+\"\\x3d\\x3d\")):2===extraBytes&&(uint8$jscomp$0=(uint8$jscomp$0[len-\n2]<<8)+uint8$jscomp$0[len-1],parts.push(lookup[uint8$jscomp$0>>10]+lookup[uint8$jscomp$0>>4&63]+lookup[uint8$jscomp$0<<2&63]+\"\\x3d\"));return parts.join(\"\")};var lookup=[],revLookup=[],Arr=\"undefined\"!==typeof Uint8Array?Uint8Array:Array;for(global=0;64>global;++global)lookup[global]=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[global],revLookup[\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".charCodeAt(global)]=global;revLookup[45]=62;revLookup[95]=63}","~:source","shadow$provide[\"module$node_modules$base64_js$index\"] = function(global,require,module,exports) {\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["byteLength","fromByteArray","toByteArray"]],"~:compiled-at",1621210442292,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$base64_js$index.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/base64-js/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$base64_js$index\\\"] = function(global,require,module,exports) {\\n'use strict'\\n\\nexports.byteLength = byteLength\\nexports.toByteArray = toByteArray\\nexports.fromByteArray = fromByteArray\\n\\nvar lookup = []\\nvar revLookup = []\\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\\n\\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\\nfor (var i = 0, len = code.length; i < len; ++i) {\\n  lookup[i] = code[i]\\n  revLookup[code.charCodeAt(i)] = i\\n}\\n\\n// Support decoding URL-safe base64 strings, as Node.js does.\\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\\nrevLookup['-'.charCodeAt(0)] = 62\\nrevLookup['_'.charCodeAt(0)] = 63\\n\\nfunction getLens (b64) {\\n  var len = b64.length\\n\\n  if (len % 4 > 0) {\\n    throw new Error('Invalid string. Length must be a multiple of 4')\\n  }\\n\\n  // Trim off extra bytes after placeholder bytes are found\\n  // See: https://github.com/beatgammit/base64-js/issues/42\\n  var validLen = b64.indexOf('=')\\n  if (validLen === -1) validLen = len\\n\\n  var placeHoldersLen = validLen === len\\n    ? 0\\n    : 4 - (validLen % 4)\\n\\n  return [validLen, placeHoldersLen]\\n}\\n\\n// base64 is 4/3 + up to two characters of the original data\\nfunction byteLength (b64) {\\n  var lens = getLens(b64)\\n  var validLen = lens[0]\\n  var placeHoldersLen = lens[1]\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\n}\\n\\nfunction _byteLength (b64, validLen, placeHoldersLen) {\\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\\n}\\n\\nfunction toByteArray (b64) {\\n  var tmp\\n  var lens = getLens(b64)\\n  var validLen = lens[0]\\n  var placeHoldersLen = lens[1]\\n\\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\\n\\n  var curByte = 0\\n\\n  // if there are placeholders, only get up to the last complete 4 chars\\n  var len = placeHoldersLen > 0\\n    ? validLen - 4\\n    : validLen\\n\\n  var i\\n  for (i = 0; i < len; i += 4) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 18) |\\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\\n      revLookup[b64.charCodeAt(i + 3)]\\n    arr[curByte++] = (tmp >> 16) & 0xFF\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  if (placeHoldersLen === 2) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 2) |\\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  if (placeHoldersLen === 1) {\\n    tmp =\\n      (revLookup[b64.charCodeAt(i)] << 10) |\\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\\n    arr[curByte++] = (tmp >> 8) & 0xFF\\n    arr[curByte++] = tmp & 0xFF\\n  }\\n\\n  return arr\\n}\\n\\nfunction tripletToBase64 (num) {\\n  return lookup[num >> 18 & 0x3F] +\\n    lookup[num >> 12 & 0x3F] +\\n    lookup[num >> 6 & 0x3F] +\\n    lookup[num & 0x3F]\\n}\\n\\nfunction encodeChunk (uint8, start, end) {\\n  var tmp\\n  var output = []\\n  for (var i = start; i < end; i += 3) {\\n    tmp =\\n      ((uint8[i] << 16) & 0xFF0000) +\\n      ((uint8[i + 1] << 8) & 0xFF00) +\\n      (uint8[i + 2] & 0xFF)\\n    output.push(tripletToBase64(tmp))\\n  }\\n  return output.join('')\\n}\\n\\nfunction fromByteArray (uint8) {\\n  var tmp\\n  var len = uint8.length\\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\\n  var parts = []\\n  var maxChunkLength = 16383 // must be multiple of 3\\n\\n  // go through the array every three bytes, we'll deal with trailing stuff later\\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\\n  }\\n\\n  // pad the end with zeros, but make sure to not forget the extra bytes\\n  if (extraBytes === 1) {\\n    tmp = uint8[len - 1]\\n    parts.push(\\n      lookup[tmp >> 2] +\\n      lookup[(tmp << 4) & 0x3F] +\\n      '=='\\n    )\\n  } else if (extraBytes === 2) {\\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\\n    parts.push(\\n      lookup[tmp >> 10] +\\n      lookup[(tmp >> 4) & 0x3F] +\\n      lookup[(tmp << 2) & 0x3F] +\\n      '='\\n    )\\n  }\\n\\n  return parts.join('')\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getLens\",\"b64\",\"len\",\"length\",\"Error\",\"validLen\",\"indexOf\",\"placeHoldersLen\",\"byteLength\",\"lens\",\"toByteArray\",\"arr\",\"Arr\",\"curByte\",\"i\",\"tmp\",\"revLookup\",\"charCodeAt\",\"fromByteArray\",\"uint8\",\"extraBytes\",\"parts\",\"len2\",\"maxChunkLength\",\"push\",\"output\",\"end\",\"lookup\",\"join\",\"Uint8Array\",\"Array\",\"code\"]\n}\n"]