["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-grid-layout/build/utils.js"],"~:js","shadow$provide.module$node_modules$react_grid_layout$build$utils=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}));keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=\n1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){var value=source[key];key in target?Object.defineProperty(target,key,{value,enumerable:!0,configurable:!0,writable:!0}):target[key]=value}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}return target}\nfunction bottom(layout){for(var max=0,bottomY,i=0,len=layout.length;i<len;i++)bottomY=layout[i].y+layout[i].h,bottomY>max&&(max=bottomY);return max}function modifyLayout(layout,layoutItem){for(var newLayout=Array(layout.length),i=0,len=layout.length;i<len;i++)newLayout[i]=layoutItem.i===layout[i].i?layoutItem:layout[i];return newLayout}function cloneLayoutItem(layoutItem){return{w:layoutItem.w,h:layoutItem.h,x:layoutItem.x,y:layoutItem.y,i:layoutItem.i,minW:layoutItem.minW,maxW:layoutItem.maxW,minH:layoutItem.minH,\nmaxH:layoutItem.maxH,moved:!!layoutItem.moved,static:!!layoutItem.static,isDraggable:layoutItem.isDraggable,isResizable:layoutItem.isResizable,resizeHandles:layoutItem.resizeHandles,isBounded:layoutItem.isBounded}}function collides(l1,l2){return l1.i===l2.i||l1.x+l1.w<=l2.x||l1.x>=l2.x+l2.w||l1.y+l1.h<=l2.y||l1.y>=l2.y+l2.h?!1:!0}function compact(layout,compactType,cols){for(var compareWith=getStatics(layout),sorted=sortLayoutItems(layout,compactType),out=Array(layout.length),i=0,len=sorted.length;i<\nlen;i++){var l=cloneLayoutItem(sorted[i]);l.static||(l=compactItem(compareWith,l,compactType,cols,sorted),compareWith.push(l));out[layout.indexOf(sorted[i])]=l;l.moved=!1}return out}function resolveCompactionCollision(layout,item,moveToCoord,axis){var sizeProp=heightWidth[axis];item[axis]+=1;for(var i=layout.map(function(layoutItem){return layoutItem.i}).indexOf(item.i)+1;i<layout.length;i++){var otherItem=layout[i];if(!otherItem.static){if(otherItem.y>item.y+item.h)break;collides(item,otherItem)&&\nresolveCompactionCollision(layout,otherItem,moveToCoord+item[sizeProp],axis)}}item[axis]=moveToCoord}function compactItem(compareWith,l,compactType,cols,fullLayout){var compactH=\"horizontal\"===compactType;if(\"vertical\"===compactType)for(l.y=Math.min(bottom(compareWith),l.y);0<l.y&&!getFirstCollision(compareWith,l);)l.y--;else if(compactH)for(;0<l.x&&!getFirstCollision(compareWith,l);)l.x--;for(;compactType=getFirstCollision(compareWith,l);)compactH?resolveCompactionCollision(fullLayout,l,compactType.x+\ncompactType.w,\"x\"):resolveCompactionCollision(fullLayout,l,compactType.y+compactType.h,\"y\"),compactH&&l.x+l.w>cols&&(l.x=cols-l.w,l.y++);l.y=Math.max(l.y,0);l.x=Math.max(l.x,0);return l}function correctBounds(layout,bounds){for(var collidesWith=getStatics(layout),i=0,len=layout.length;i<len;i++){var l=layout[i];l.x+l.w>bounds.cols&&(l.x=bounds.cols-l.w);0>l.x&&(l.x=0,l.w=bounds.cols);if(l.static)for(;getFirstCollision(collidesWith,l);)l.y++;else collidesWith.push(l)}return layout}function getLayoutItem(layout,\nid){for(var i=0,len=layout.length;i<len;i++)if(layout[i].i===id)return layout[i]}function getFirstCollision(layout,layoutItem){for(var i=0,len=layout.length;i<len;i++)if(collides(layout[i],layoutItem))return layout[i]}function getAllCollisions(layout,layoutItem){return layout.filter(function(l){return collides(l,layoutItem)})}function getStatics(layout){return layout.filter(function(l){return l.static})}function moveElement(layout,l,x,y,isUserAction,preventCollision,compactType,cols){if(l.static&&\n!0!==l.isDraggable||l.y===y&&l.x===x)return layout;log(\"Moving element \".concat(l.i,\" to [\").concat(String(x),\",\").concat(String(y),\"] from [\").concat(l.x,\",\").concat(l.y,\"]\"));var oldX=l.x,oldY=l.y;\"number\"===typeof x&&(l.x=x);\"number\"===typeof y&&(l.y=y);l.moved=!0;var sorted=sortLayoutItems(layout,compactType);if(\"vertical\"===compactType&&\"number\"===typeof y?oldY>=y:\"horizontal\"===compactType&&\"number\"===typeof x&&oldX>=x)sorted=sorted.reverse();x=getAllCollisions(sorted,l);if(preventCollision&&\nx.length)return log(\"Collision prevented on \".concat(l.i,\", reverting.\")),l.x=oldX,l.y=oldY,l.moved=!1,layout;preventCollision=0;for(oldX=x.length;preventCollision<oldX;preventCollision++)oldY=x[preventCollision],log(\"Resolving collision between \".concat(l.i,\" at [\").concat(l.x,\",\").concat(l.y,\"] and \").concat(oldY.i,\" at [\").concat(oldY.x,\",\").concat(oldY.y,\"]\")),oldY.moved||(layout=oldY.static?moveElementAwayFromCollision(layout,oldY,l,isUserAction,compactType,cols):moveElementAwayFromCollision(layout,\nl,oldY,isUserAction,compactType,cols));return layout}function moveElementAwayFromCollision(layout,collidesWith,itemToMove,isUserAction,compactType,cols){var compactH=\"horizontal\"===compactType,compactV=\"horizontal\"!==compactType,preventCollision=collidesWith.static;return isUserAction&&(isUserAction=!1,collidesWith={x:compactH?Math.max(collidesWith.x-itemToMove.w,0):itemToMove.x,y:compactV?Math.max(collidesWith.y-itemToMove.h,0):itemToMove.y,w:itemToMove.w,h:itemToMove.h,i:\"-1\"},!getFirstCollision(layout,\ncollidesWith))?(log(\"Doing reverse collision on \".concat(itemToMove.i,\" up to [\").concat(collidesWith.x,\",\").concat(collidesWith.y,\"].\")),moveElement(layout,itemToMove,compactH?collidesWith.x:void 0,compactV?collidesWith.y:void 0,isUserAction,preventCollision,compactType,cols)):moveElement(layout,itemToMove,compactH?itemToMove.x+1:void 0,compactV?itemToMove.y+1:void 0,isUserAction,preventCollision,compactType,cols)}function sortLayoutItems(layout,compactType){return\"horizontal\"===compactType?sortLayoutItemsByColRow(layout):\nsortLayoutItemsByRowCol(layout)}function sortLayoutItemsByRowCol(layout){return layout.slice(0).sort(function(a,b){return a.y>b.y||a.y===b.y&&a.x>b.x?1:a.y===b.y&&a.x===b.x?0:-1})}function sortLayoutItemsByColRow(layout){return layout.slice(0).sort(function(a,b){return a.x>b.x||a.x===b.x&&a.y>b.y?1:-1})}function validateLayout(layout){var contextName=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\"Layout\",subProps=[\"x\",\"y\",\"w\",\"h\"];if(!Array.isArray(layout))throw Error(contextName+\" must be an array!\");\nfor(var i=0,len=layout.length;i<len;i++){for(var item=layout[i],j=0;j<subProps.length;j++)if(\"number\"!==typeof item[subProps[j]])throw Error(\"ReactGridLayout: \"+contextName+\"[\"+i+\"].\"+subProps[j]+\" must be a number!\");if(item.i&&\"string\"!==typeof item.i)throw Error(\"ReactGridLayout: \"+contextName+\"[\"+i+\"].i must be a string!\");if(void 0!==item.static&&\"boolean\"!==typeof item.static)throw Error(\"ReactGridLayout: \"+contextName+\"[\"+i+\"].static must be a boolean!\");}}function log(){var _console;DEBUG&&\n(_console=console).log.apply(_console,arguments)}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.bottom=bottom;exports.cloneLayout=function(layout){for(var newLayout=Array(layout.length),i=0,len=layout.length;i<len;i++)newLayout[i]=cloneLayoutItem(layout[i]);return newLayout};exports.modifyLayout=modifyLayout;exports.withLayoutItem=function(layout,itemKey,cb){itemKey=getLayoutItem(layout,itemKey);if(!itemKey)return[layout,null];itemKey=cb(cloneLayoutItem(itemKey));layout=modifyLayout(layout,\nitemKey);return[layout,itemKey]};exports.cloneLayoutItem=cloneLayoutItem;exports.childrenEqual=function(a,b){return(0,_lodash.default)(_react.default.Children.map(a,function(c){return c.key}),_react.default.Children.map(b,function(c){return c.key}))};exports.fastPositionEqual=function(a,b){return a.left===b.left&&a.top===b.top&&a.width===b.width&&a.height===b.height};exports.collides=collides;exports.compact=compact;exports.compactItem=compactItem;exports.correctBounds=correctBounds;exports.getLayoutItem=\ngetLayoutItem;exports.getFirstCollision=getFirstCollision;exports.getAllCollisions=getAllCollisions;exports.getStatics=getStatics;exports.moveElement=moveElement;exports.moveElementAwayFromCollision=moveElementAwayFromCollision;exports.perc=function(num){return 100*num+\"%\"};exports.setTransform=function(_ref){var top=_ref.top,width=_ref.width,height=_ref.height;_ref=\"translate(\".concat(_ref.left,\"px,\").concat(top,\"px)\");return{transform:_ref,WebkitTransform:_ref,MozTransform:_ref,msTransform:_ref,\nOTransform:_ref,width:\"\".concat(width,\"px\"),height:\"\".concat(height,\"px\"),position:\"absolute\"}};exports.setTopLeft=function(_ref2){var left=_ref2.left,width=_ref2.width,height=_ref2.height;return{top:\"\".concat(_ref2.top,\"px\"),left:\"\".concat(left,\"px\"),width:\"\".concat(width,\"px\"),height:\"\".concat(height,\"px\"),position:\"absolute\"}};exports.sortLayoutItems=sortLayoutItems;exports.sortLayoutItemsByRowCol=sortLayoutItemsByRowCol;exports.sortLayoutItemsByColRow=sortLayoutItemsByColRow;exports.synchronizeLayoutWithChildren=\nfunction(initialLayout,children,cols,compactType){initialLayout=initialLayout||[];var layout=[];_react.default.Children.forEach(children,function(child,i){var exists=getLayoutItem(initialLayout,String(child.key));exists?layout[i]=cloneLayoutItem(exists):(!isProduction&&child.props._grid&&console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. Please use `data-grid` or add your properties directly to the `layout`.\"),(exists=child.props[\"data-grid\"]||child.props._grid)?(isProduction||\nvalidateLayout([exists],\"ReactGridLayout.children\"),layout[i]=cloneLayoutItem(_objectSpread(_objectSpread({},exists),{},{i:child.key}))):layout[i]=cloneLayoutItem({w:1,h:1,x:0,y:bottom(layout),i:String(child.key)}))});children=correctBounds(layout,{cols});return compact(children,compactType,cols)};exports.validateLayout=validateLayout;exports.compactType=function(props){props=props||{};var compactType=props.compactType;return!1===props.verticalCompact?null:compactType};exports.autoBindHandlers=function(el,\nfns){fns.forEach(function(key){return el[key]=el[key].bind(el)})};exports.noop=exports.fastRGLPropsEqual=void 0;var _lodash=_interopRequireDefault(require(\"module$node_modules$lodash_DOT_isequal$index\")),_react=_interopRequireDefault(require(\"module$node_modules$react$index\")),isProduction=!1,DEBUG=!1;global=require(\"module$node_modules$react_grid_layout$build$fastRGLPropsEqual\");exports.fastRGLPropsEqual=global;var heightWidth={x:\"w\",y:\"h\"};exports.noop=function(){}}","~:source","shadow$provide[\"module$node_modules$react_grid_layout$build$utils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.cloneLayout = cloneLayout;\nexports.modifyLayout = modifyLayout;\nexports.withLayoutItem = withLayoutItem;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.childrenEqual = childrenEqual;\nexports.fastPositionEqual = fastPositionEqual;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.correctBounds = correctBounds;\nexports.getLayoutItem = getLayoutItem;\nexports.getFirstCollision = getFirstCollision;\nexports.getAllCollisions = getAllCollisions;\nexports.getStatics = getStatics;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.perc = perc;\nexports.setTransform = setTransform;\nexports.setTopLeft = setTopLeft;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.compactType = compactType;\nexports.autoBindHandlers = autoBindHandlers;\nexports.noop = exports.fastRGLPropsEqual = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\n\n\nfunction modifyLayout(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n\n  return newLayout;\n} // Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\n\n\nfunction withLayoutItem(layout\n/*: Layout*/\n, itemKey\n/*: string*/\n, cb\n/*: LayoutItem => LayoutItem*/\n)\n/*: [Layout, ?LayoutItem]*/\n{\n  var item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n)\n/*: boolean*/\n{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  } // Ensure that there are no negative positions\n\n\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l); // There was a collision; abort\n\n  if (preventCollision && collisions.length) {\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);else return sortLayoutItemsByRowCol(layout);\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  , i\n  /*: number*/\n  ) {\n    // Don't overwrite if it already exists.\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout[i] = cloneLayoutItem(exists);\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + // eslint-disable-line\n        \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        } // FIXME clone not really necessary here\n\n\n        layout[i] = cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout[i] = cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        });\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n\n    if (item.i && typeof item.i !== \"string\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].i must be a string!\");\n    }\n\n    if (item.static !== undefined && typeof item.static !== \"boolean\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].static must be a boolean!\");\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n} // Flow can't really figure this out, so we just use Object\n\n\nfunction autoBindHandlers(el\n/*: Object*/\n, fns\n/*: Array<string>*/\n)\n/*: void*/\n{\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_grid_layout$build$fastRGLPropsEqual","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$lodash_DOT_isequal$index"]],"~:properties",["^5",["compactType","w","compact","static","width","top","moveElementAwayFromCollision","isBounded","height","autoBindHandlers","noop","isDraggable","synchronizeLayoutWithChildren","getFirstCollision","x","__esModule","compactItem","transform","perc","moveElement","collides","withLayoutItem","OTransform","position","configurable","setTopLeft","WebkitTransform","maxW","value","msTransform","sortLayoutItemsByRowCol","enumerable","maxH","getAllCollisions","moved","isResizable","modifyLayout","writable","minW","cloneLayout","fastPositionEqual","sortLayoutItemsByColRow","sortLayoutItems","cloneLayoutItem","i","cols","y","fastRGLPropsEqual","childrenEqual","bottom","minH","resizeHandles","correctBounds","validateLayout","h","setTransform","MozTransform","getLayoutItem","default","getStatics","left"]],"~:compiled-at",1621210442660,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_grid_layout$build$utils.js\",\n\"lineCount\":21,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-grid-layout/build/utils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_grid_layout$build$utils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.bottom = bottom;\\nexports.cloneLayout = cloneLayout;\\nexports.modifyLayout = modifyLayout;\\nexports.withLayoutItem = withLayoutItem;\\nexports.cloneLayoutItem = cloneLayoutItem;\\nexports.childrenEqual = childrenEqual;\\nexports.fastPositionEqual = fastPositionEqual;\\nexports.collides = collides;\\nexports.compact = compact;\\nexports.compactItem = compactItem;\\nexports.correctBounds = correctBounds;\\nexports.getLayoutItem = getLayoutItem;\\nexports.getFirstCollision = getFirstCollision;\\nexports.getAllCollisions = getAllCollisions;\\nexports.getStatics = getStatics;\\nexports.moveElement = moveElement;\\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\\nexports.perc = perc;\\nexports.setTransform = setTransform;\\nexports.setTopLeft = setTopLeft;\\nexports.sortLayoutItems = sortLayoutItems;\\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\\nexports.validateLayout = validateLayout;\\nexports.compactType = compactType;\\nexports.autoBindHandlers = autoBindHandlers;\\nexports.noop = exports.fastRGLPropsEqual = void 0;\\n\\nvar _lodash = _interopRequireDefault(require(\\\"lodash.isequal\\\"));\\n\\nvar _react = _interopRequireDefault(require(\\\"react\\\"));\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\\n\\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\\n\\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\nvar isProduction = process.env.NODE_ENV === \\\"production\\\";\\nvar DEBUG = false;\\n/**\\n * Return the bottom coordinate of the layout.\\n *\\n * @param  {Array} layout Layout array.\\n * @return {Number}       Bottom coordinate.\\n */\\n\\nfunction bottom(layout\\n/*: Layout*/\\n)\\n/*: number*/\\n{\\n  var max = 0,\\n      bottomY;\\n\\n  for (var i = 0, len = layout.length; i < len; i++) {\\n    bottomY = layout[i].y + layout[i].h;\\n    if (bottomY > max) max = bottomY;\\n  }\\n\\n  return max;\\n}\\n\\nfunction cloneLayout(layout\\n/*: Layout*/\\n)\\n/*: Layout*/\\n{\\n  var newLayout = Array(layout.length);\\n\\n  for (var i = 0, len = layout.length; i < len; i++) {\\n    newLayout[i] = cloneLayoutItem(layout[i]);\\n  }\\n\\n  return newLayout;\\n} // Modify a layoutItem inside a layout. Returns a new Layout,\\n// does not mutate. Carries over all other LayoutItems unmodified.\\n\\n\\nfunction modifyLayout(layout\\n/*: Layout*/\\n, layoutItem\\n/*: LayoutItem*/\\n)\\n/*: Layout*/\\n{\\n  var newLayout = Array(layout.length);\\n\\n  for (var i = 0, len = layout.length; i < len; i++) {\\n    if (layoutItem.i === layout[i].i) {\\n      newLayout[i] = layoutItem;\\n    } else {\\n      newLayout[i] = layout[i];\\n    }\\n  }\\n\\n  return newLayout;\\n} // Function to be called to modify a layout item.\\n// Does defensive clones to ensure the layout is not modified.\\n\\n\\nfunction withLayoutItem(layout\\n/*: Layout*/\\n, itemKey\\n/*: string*/\\n, cb\\n/*: LayoutItem => LayoutItem*/\\n)\\n/*: [Layout, ?LayoutItem]*/\\n{\\n  var item = getLayoutItem(layout, itemKey);\\n  if (!item) return [layout, null];\\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\\n  // FIXME could do this faster if we already knew the index\\n\\n  layout = modifyLayout(layout, item);\\n  return [layout, item];\\n} // Fast path to cloning, since this is monomorphic\\n\\n\\nfunction cloneLayoutItem(layoutItem\\n/*: LayoutItem*/\\n)\\n/*: LayoutItem*/\\n{\\n  return {\\n    w: layoutItem.w,\\n    h: layoutItem.h,\\n    x: layoutItem.x,\\n    y: layoutItem.y,\\n    i: layoutItem.i,\\n    minW: layoutItem.minW,\\n    maxW: layoutItem.maxW,\\n    minH: layoutItem.minH,\\n    maxH: layoutItem.maxH,\\n    moved: Boolean(layoutItem.moved),\\n    static: Boolean(layoutItem.static),\\n    // These can be null/undefined\\n    isDraggable: layoutItem.isDraggable,\\n    isResizable: layoutItem.isResizable,\\n    resizeHandles: layoutItem.resizeHandles,\\n    isBounded: layoutItem.isBounded\\n  };\\n}\\n/**\\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\\n * This will catch differences in keys, order, and length.\\n */\\n\\n\\nfunction childrenEqual(a\\n/*: ReactChildren*/\\n, b\\n/*: ReactChildren*/\\n)\\n/*: boolean*/\\n{\\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\\n    return c.key;\\n  }), _react.default.Children.map(b, function (c) {\\n    return c.key;\\n  }));\\n}\\n/**\\n * See `fastRGLPropsEqual.js`.\\n * We want this to run as fast as possible - it is called often - and to be\\n * resilient to new props that we add. So rather than call lodash.isEqual,\\n * which isn't suited to comparing props very well, we use this specialized\\n * function in conjunction with preval to generate the fastest possible comparison\\n * function, tuned for exactly our props.\\n */\\n\\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\\n\\n\\nvar fastRGLPropsEqual\\n/*: FastRGLPropsEqual*/\\n= require(\\\"./fastRGLPropsEqual\\\"); // Like the above, but a lot simpler.\\n\\n\\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\\n\\nfunction fastPositionEqual(a\\n/*: Position*/\\n, b\\n/*: Position*/\\n)\\n/*: boolean*/\\n{\\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\\n}\\n/**\\n * Given two layoutitems, check if they collide.\\n */\\n\\n\\nfunction collides(l1\\n/*: LayoutItem*/\\n, l2\\n/*: LayoutItem*/\\n)\\n/*: boolean*/\\n{\\n  if (l1.i === l2.i) return false; // same element\\n\\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\\n\\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\\n\\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\\n\\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\\n\\n  return true; // boxes overlap\\n}\\n/**\\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\\n * between items.\\n *\\n * Does not modify layout items (clones). Creates a new layout array.\\n *\\n * @param  {Array} layout Layout.\\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\\n *   vertically.\\n * @return {Array}       Compacted Layout.\\n */\\n\\n\\nfunction compact(layout\\n/*: Layout*/\\n, compactType\\n/*: CompactType*/\\n, cols\\n/*: number*/\\n)\\n/*: Layout*/\\n{\\n  // Statics go in the compareWith array right away so items flow around them.\\n  var compareWith = getStatics(layout); // We go through the items by row and column.\\n\\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\\n\\n  var out = Array(layout.length);\\n\\n  for (var i = 0, len = sorted.length; i < len; i++) {\\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\\n\\n    if (!l.static) {\\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\\n      // Statics are already in this array.\\n\\n      compareWith.push(l);\\n    } // Add to output array to make sure they still come out in the right order.\\n\\n\\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\\n\\n    l.moved = false;\\n  }\\n\\n  return out;\\n}\\n\\nvar heightWidth = {\\n  x: \\\"w\\\",\\n  y: \\\"h\\\"\\n};\\n/**\\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\\n */\\n\\nfunction resolveCompactionCollision(layout\\n/*: Layout*/\\n, item\\n/*: LayoutItem*/\\n, moveToCoord\\n/*: number*/\\n, axis\\n/*: \\\"x\\\" | \\\"y\\\"*/\\n) {\\n  var sizeProp = heightWidth[axis];\\n  item[axis] += 1;\\n  var itemIndex = layout.map(function (layoutItem) {\\n    return layoutItem.i;\\n  }).indexOf(item.i); // Go through each item we collide with.\\n\\n  for (var i = itemIndex + 1; i < layout.length; i++) {\\n    var otherItem = layout[i]; // Ignore static items\\n\\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\\n    // We can do this b/c it's a sorted layout\\n\\n    if (otherItem.y > item.y + item.h) break;\\n\\n    if (collides(item, otherItem)) {\\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\\n    }\\n  }\\n\\n  item[axis] = moveToCoord;\\n}\\n/**\\n * Compact an item in the layout.\\n *\\n * Modifies item.\\n *\\n */\\n\\n\\nfunction compactItem(compareWith\\n/*: Layout*/\\n, l\\n/*: LayoutItem*/\\n, compactType\\n/*: CompactType*/\\n, cols\\n/*: number*/\\n, fullLayout\\n/*: Layout*/\\n)\\n/*: LayoutItem*/\\n{\\n  var compactV = compactType === \\\"vertical\\\";\\n  var compactH = compactType === \\\"horizontal\\\";\\n\\n  if (compactV) {\\n    // Bottom 'y' possible is the bottom of the layout.\\n    // This allows you to do nice stuff like specify {y: Infinity}\\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\\n\\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\\n      l.y--;\\n    }\\n  } else if (compactH) {\\n    // Move the element left as far as it can go without colliding.\\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\\n      l.x--;\\n    }\\n  } // Move it down, and keep moving it down if it's colliding.\\n\\n\\n  var collides;\\n\\n  while (collides = getFirstCollision(compareWith, l)) {\\n    if (compactH) {\\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \\\"x\\\");\\n    } else {\\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \\\"y\\\");\\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\\n\\n\\n    if (compactH && l.x + l.w > cols) {\\n      l.x = cols - l.w;\\n      l.y++;\\n    }\\n  } // Ensure that there are no negative positions\\n\\n\\n  l.y = Math.max(l.y, 0);\\n  l.x = Math.max(l.x, 0);\\n  return l;\\n}\\n/**\\n * Given a layout, make sure all elements fit within its bounds.\\n *\\n * Modifies layout items.\\n *\\n * @param  {Array} layout Layout array.\\n * @param  {Number} bounds Number of columns.\\n */\\n\\n\\nfunction correctBounds(layout\\n/*: Layout*/\\n, bounds\\n/*: { cols: number }*/\\n)\\n/*: Layout*/\\n{\\n  var collidesWith = getStatics(layout);\\n\\n  for (var i = 0, len = layout.length; i < len; i++) {\\n    var l = layout[i]; // Overflows right\\n\\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\\n\\n    if (l.x < 0) {\\n      l.x = 0;\\n      l.w = bounds.cols;\\n    }\\n\\n    if (!l.static) collidesWith.push(l);else {\\n      // If this is static and collides with other statics, we must move it down.\\n      // We have to do something nicer than just letting them overlap.\\n      while (getFirstCollision(collidesWith, l)) {\\n        l.y++;\\n      }\\n    }\\n  }\\n\\n  return layout;\\n}\\n/**\\n * Get a layout item by ID. Used so we can override later on if necessary.\\n *\\n * @param  {Array}  layout Layout array.\\n * @param  {String} id     ID\\n * @return {LayoutItem}    Item at ID.\\n */\\n\\n\\nfunction getLayoutItem(layout\\n/*: Layout*/\\n, id\\n/*: string*/\\n)\\n/*: ?LayoutItem*/\\n{\\n  for (var i = 0, len = layout.length; i < len; i++) {\\n    if (layout[i].i === id) return layout[i];\\n  }\\n}\\n/**\\n * Returns the first item this layout collides with.\\n * It doesn't appear to matter which order we approach this from, although\\n * perhaps that is the wrong thing to do.\\n *\\n * @param  {Object} layoutItem Layout item.\\n * @return {Object|undefined}  A colliding layout item, or undefined.\\n */\\n\\n\\nfunction getFirstCollision(layout\\n/*: Layout*/\\n, layoutItem\\n/*: LayoutItem*/\\n)\\n/*: ?LayoutItem*/\\n{\\n  for (var i = 0, len = layout.length; i < len; i++) {\\n    if (collides(layout[i], layoutItem)) return layout[i];\\n  }\\n}\\n\\nfunction getAllCollisions(layout\\n/*: Layout*/\\n, layoutItem\\n/*: LayoutItem*/\\n)\\n/*: Array<LayoutItem>*/\\n{\\n  return layout.filter(function (l) {\\n    return collides(l, layoutItem);\\n  });\\n}\\n/**\\n * Get all static elements.\\n * @param  {Array} layout Array of layout objects.\\n * @return {Array}        Array of static layout items..\\n */\\n\\n\\nfunction getStatics(layout\\n/*: Layout*/\\n)\\n/*: Array<LayoutItem>*/\\n{\\n  return layout.filter(function (l) {\\n    return l.static;\\n  });\\n}\\n/**\\n * Move an element. Responsible for doing cascading movements of other elements.\\n *\\n * Modifies layout items.\\n *\\n * @param  {Array}      layout            Full layout to modify.\\n * @param  {LayoutItem} l                 element to move.\\n * @param  {Number}     [x]               X position in grid units.\\n * @param  {Number}     [y]               Y position in grid units.\\n */\\n\\n\\nfunction moveElement(layout\\n/*: Layout*/\\n, l\\n/*: LayoutItem*/\\n, x\\n/*: ?number*/\\n, y\\n/*: ?number*/\\n, isUserAction\\n/*: ?boolean*/\\n, preventCollision\\n/*: ?boolean*/\\n, compactType\\n/*: CompactType*/\\n, cols\\n/*: number*/\\n)\\n/*: Layout*/\\n{\\n  // If this is static and not explicitly enabled as draggable,\\n  // no move is possible, so we can short-circuit this immediately.\\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\\n\\n  if (l.y === y && l.x === x) return layout;\\n  log(\\\"Moving element \\\".concat(l.i, \\\" to [\\\").concat(String(x), \\\",\\\").concat(String(y), \\\"] from [\\\").concat(l.x, \\\",\\\").concat(l.y, \\\"]\\\"));\\n  var oldX = l.x;\\n  var oldY = l.y; // This is quite a bit faster than extending the object\\n\\n  if (typeof x === \\\"number\\\") l.x = x;\\n  if (typeof y === \\\"number\\\") l.y = y;\\n  l.moved = true; // If this collides with anything, move it.\\n  // When doing this comparison, we have to sort the items we compare with\\n  // to ensure, in the case of multiple collisions, that we're getting the\\n  // nearest collision.\\n\\n  var sorted = sortLayoutItems(layout, compactType);\\n  var movingUp = compactType === \\\"vertical\\\" && typeof y === \\\"number\\\" ? oldY >= y : compactType === \\\"horizontal\\\" && typeof x === \\\"number\\\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\\n\\n  if (movingUp) sorted = sorted.reverse();\\n  var collisions = getAllCollisions(sorted, l); // There was a collision; abort\\n\\n  if (preventCollision && collisions.length) {\\n    log(\\\"Collision prevented on \\\".concat(l.i, \\\", reverting.\\\"));\\n    l.x = oldX;\\n    l.y = oldY;\\n    l.moved = false;\\n    return layout;\\n  } // Move each item that collides away from this element.\\n\\n\\n  for (var i = 0, len = collisions.length; i < len; i++) {\\n    var collision = collisions[i];\\n    log(\\\"Resolving collision between \\\".concat(l.i, \\\" at [\\\").concat(l.x, \\\",\\\").concat(l.y, \\\"] and \\\").concat(collision.i, \\\" at [\\\").concat(collision.x, \\\",\\\").concat(collision.y, \\\"]\\\")); // Short circuit so we can't infinite loop\\n\\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\\n\\n    if (collision.static) {\\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\\n    } else {\\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\\n    }\\n  }\\n\\n  return layout;\\n}\\n/**\\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\\n * We attempt to move it up if there's room, otherwise it goes below.\\n *\\n * @param  {Array} layout            Full layout to modify.\\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\\n */\\n\\n\\nfunction moveElementAwayFromCollision(layout\\n/*: Layout*/\\n, collidesWith\\n/*: LayoutItem*/\\n, itemToMove\\n/*: LayoutItem*/\\n, isUserAction\\n/*: ?boolean*/\\n, compactType\\n/*: CompactType*/\\n, cols\\n/*: number*/\\n)\\n/*: Layout*/\\n{\\n  var compactH = compactType === \\\"horizontal\\\"; // Compact vertically if not set to horizontal\\n\\n  var compactV = compactType !== \\\"horizontal\\\";\\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\\n  // If there is enough space above the collision to put this element, move it there.\\n  // We only do this on the main collision as this can get funky in cascades and cause\\n  // unwanted swapping behavior.\\n\\n  if (isUserAction) {\\n    // Reset isUserAction flag because we're not in the main collision anymore.\\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\\n\\n    var fakeItem\\n    /*: LayoutItem*/\\n    = {\\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\\n      w: itemToMove.w,\\n      h: itemToMove.h,\\n      i: \\\"-1\\\"\\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\\n\\n    if (!getFirstCollision(layout, fakeItem)) {\\n      log(\\\"Doing reverse collision on \\\".concat(itemToMove.i, \\\" up to [\\\").concat(fakeItem.x, \\\",\\\").concat(fakeItem.y, \\\"].\\\"));\\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\\n    }\\n  }\\n\\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\\n}\\n/**\\n * Helper to convert a number to a percentage string.\\n *\\n * @param  {Number} num Any number\\n * @return {String}     That number as a percentage.\\n */\\n\\n\\nfunction perc(num\\n/*: number*/\\n)\\n/*: string*/\\n{\\n  return num * 100 + \\\"%\\\";\\n}\\n\\nfunction setTransform(_ref)\\n/*: Object*/\\n{\\n  var top = _ref.top,\\n      left = _ref.left,\\n      width = _ref.width,\\n      height = _ref.height;\\n  // Replace unitless items with px\\n  var translate = \\\"translate(\\\".concat(left, \\\"px,\\\").concat(top, \\\"px)\\\");\\n  return {\\n    transform: translate,\\n    WebkitTransform: translate,\\n    MozTransform: translate,\\n    msTransform: translate,\\n    OTransform: translate,\\n    width: \\\"\\\".concat(width, \\\"px\\\"),\\n    height: \\\"\\\".concat(height, \\\"px\\\"),\\n    position: \\\"absolute\\\"\\n  };\\n}\\n\\nfunction setTopLeft(_ref2)\\n/*: Object*/\\n{\\n  var top = _ref2.top,\\n      left = _ref2.left,\\n      width = _ref2.width,\\n      height = _ref2.height;\\n  return {\\n    top: \\\"\\\".concat(top, \\\"px\\\"),\\n    left: \\\"\\\".concat(left, \\\"px\\\"),\\n    width: \\\"\\\".concat(width, \\\"px\\\"),\\n    height: \\\"\\\".concat(height, \\\"px\\\"),\\n    position: \\\"absolute\\\"\\n  };\\n}\\n/**\\n * Get layout items sorted from top left to right and down.\\n *\\n * @return {Array} Array of layout objects.\\n * @return {Array}        Layout, sorted static items first.\\n */\\n\\n\\nfunction sortLayoutItems(layout\\n/*: Layout*/\\n, compactType\\n/*: CompactType*/\\n)\\n/*: Layout*/\\n{\\n  if (compactType === \\\"horizontal\\\") return sortLayoutItemsByColRow(layout);else return sortLayoutItemsByRowCol(layout);\\n}\\n/**\\n * Sort layout items by row ascending and column ascending.\\n *\\n * Does not modify Layout.\\n */\\n\\n\\nfunction sortLayoutItemsByRowCol(layout\\n/*: Layout*/\\n)\\n/*: Layout*/\\n{\\n  // Slice to clone array as sort modifies\\n  return layout.slice(0).sort(function (a, b) {\\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\\n      return 1;\\n    } else if (a.y === b.y && a.x === b.x) {\\n      // Without this, we can get different sort results in IE vs. Chrome/FF\\n      return 0;\\n    }\\n\\n    return -1;\\n  });\\n}\\n/**\\n * Sort layout items by column ascending then row ascending.\\n *\\n * Does not modify Layout.\\n */\\n\\n\\nfunction sortLayoutItemsByColRow(layout\\n/*: Layout*/\\n)\\n/*: Layout*/\\n{\\n  return layout.slice(0).sort(function (a, b) {\\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\\n      return 1;\\n    }\\n\\n    return -1;\\n  });\\n}\\n/**\\n * Generate a layout using the initialLayout and children as a template.\\n * Missing entries will be added, extraneous ones will be truncated.\\n *\\n * Does not modify initialLayout.\\n *\\n * @param  {Array}  initialLayout Layout passed in through props.\\n * @param  {String} breakpoint    Current responsive breakpoint.\\n * @param  {?String} compact      Compaction option.\\n * @return {Array}                Working layout.\\n */\\n\\n\\nfunction synchronizeLayoutWithChildren(initialLayout\\n/*: Layout*/\\n, children\\n/*: ReactChildren*/\\n, cols\\n/*: number*/\\n, compactType\\n/*: CompactType*/\\n)\\n/*: Layout*/\\n{\\n  initialLayout = initialLayout || []; // Generate one layout item per child.\\n\\n  var layout\\n  /*: LayoutItem[]*/\\n  = [];\\n\\n  _react.default.Children.forEach(children, function (child\\n  /*: ReactElement<any>*/\\n  , i\\n  /*: number*/\\n  ) {\\n    // Don't overwrite if it already exists.\\n    var exists = getLayoutItem(initialLayout, String(child.key));\\n\\n    if (exists) {\\n      layout[i] = cloneLayoutItem(exists);\\n    } else {\\n      if (!isProduction && child.props._grid) {\\n        console.warn(\\\"`_grid` properties on children have been deprecated as of React 15.2. \\\" + // eslint-disable-line\\n        \\\"Please use `data-grid` or add your properties directly to the `layout`.\\\");\\n      }\\n\\n      var g = child.props[\\\"data-grid\\\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\\n\\n      if (g) {\\n        if (!isProduction) {\\n          validateLayout([g], \\\"ReactGridLayout.children\\\");\\n        } // FIXME clone not really necessary here\\n\\n\\n        layout[i] = cloneLayoutItem(_objectSpread(_objectSpread({}, g), {}, {\\n          i: child.key\\n        }));\\n      } else {\\n        // Nothing provided: ensure this is added to the bottom\\n        // FIXME clone not really necessary here\\n        layout[i] = cloneLayoutItem({\\n          w: 1,\\n          h: 1,\\n          x: 0,\\n          y: bottom(layout),\\n          i: String(child.key)\\n        });\\n      }\\n    }\\n  }); // Correct the layout.\\n\\n\\n  var correctedLayout = correctBounds(layout, {\\n    cols: cols\\n  });\\n  return compact(correctedLayout, compactType, cols);\\n}\\n/**\\n * Validate a layout. Throws errors.\\n *\\n * @param  {Array}  layout        Array of layout items.\\n * @param  {String} [contextName] Context name for errors.\\n * @throw  {Error}                Validation error.\\n */\\n\\n\\nfunction validateLayout(layout\\n/*: Layout*/\\n)\\n/*: void*/\\n{\\n  var contextName\\n  /*: string*/\\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \\\"Layout\\\";\\n  var subProps = [\\\"x\\\", \\\"y\\\", \\\"w\\\", \\\"h\\\"];\\n  if (!Array.isArray(layout)) throw new Error(contextName + \\\" must be an array!\\\");\\n\\n  for (var i = 0, len = layout.length; i < len; i++) {\\n    var item = layout[i];\\n\\n    for (var j = 0; j < subProps.length; j++) {\\n      if (typeof item[subProps[j]] !== \\\"number\\\") {\\n        throw new Error(\\\"ReactGridLayout: \\\" + contextName + \\\"[\\\" + i + \\\"].\\\" + subProps[j] + \\\" must be a number!\\\");\\n      }\\n    }\\n\\n    if (item.i && typeof item.i !== \\\"string\\\") {\\n      throw new Error(\\\"ReactGridLayout: \\\" + contextName + \\\"[\\\" + i + \\\"].i must be a string!\\\");\\n    }\\n\\n    if (item.static !== undefined && typeof item.static !== \\\"boolean\\\") {\\n      throw new Error(\\\"ReactGridLayout: \\\" + contextName + \\\"[\\\" + i + \\\"].static must be a boolean!\\\");\\n    }\\n  }\\n} // Legacy support for verticalCompact: false\\n\\n\\nfunction compactType(props\\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\\n)\\n/*: CompactType*/\\n{\\n  var _ref3 = props || {},\\n      verticalCompact = _ref3.verticalCompact,\\n      compactType = _ref3.compactType;\\n\\n  return verticalCompact === false ? null : compactType;\\n} // Flow can't really figure this out, so we just use Object\\n\\n\\nfunction autoBindHandlers(el\\n/*: Object*/\\n, fns\\n/*: Array<string>*/\\n)\\n/*: void*/\\n{\\n  fns.forEach(function (key) {\\n    return el[key] = el[key].bind(el);\\n  });\\n}\\n\\nfunction log() {\\n  var _console;\\n\\n  if (!DEBUG) return; // eslint-disable-next-line no-console\\n\\n  (_console = console).log.apply(_console, arguments);\\n}\\n\\nvar noop = function noop() {};\\n\\nexports.noop = noop;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"ownKeys\",\"object\",\"enumerableOnly\",\"keys\",\"Object\",\"getOwnPropertySymbols\",\"symbols\",\"filter\",\"sym\",\"getOwnPropertyDescriptor\",\"enumerable\",\"push\",\"apply\",\"_objectSpread\",\"target\",\"i\",\"arguments\",\"length\",\"source\",\"forEach\",\"key\",\"defineProperty\",\"value\",\"configurable\",\"writable\",\"getOwnPropertyDescriptors\",\"defineProperties\",\"bottom\",\"layout\",\"max\",\"bottomY\",\"len\",\"y\",\"h\",\"modifyLayout\",\"layoutItem\",\"newLayout\",\"Array\",\"cloneLayoutItem\",\"w\",\"x\",\"minW\",\"maxW\",\"minH\",\"maxH\",\"moved\",\"static\",\"isDraggable\",\"isResizable\",\"resizeHandles\",\"isBounded\",\"collides\",\"l1\",\"l2\",\"compact\",\"compactType\",\"cols\",\"compareWith\",\"getStatics\",\"sorted\",\"sortLayoutItems\",\"out\",\"l\",\"compactItem\",\"indexOf\",\"resolveCompactionCollision\",\"item\",\"moveToCoord\",\"axis\",\"sizeProp\",\"heightWidth\",\"map\",\"itemIndex\",\"otherItem\",\"fullLayout\",\"compactH\",\"Math\",\"min\",\"getFirstCollision\",\"correctBounds\",\"bounds\",\"collidesWith\",\"getLayoutItem\",\"id\",\"getAllCollisions\",\"moveElement\",\"isUserAction\",\"preventCollision\",\"log\",\"concat\",\"String\",\"oldX\",\"oldY\",\"movingUp\",\"reverse\",\"collisions\",\"collision\",\"moveElementAwayFromCollision\",\"itemToMove\",\"compactV\",\"fakeItem\",\"undefined\",\"sortLayoutItemsByColRow\",\"sortLayoutItemsByRowCol\",\"slice\",\"sort\",\"a\",\"b\",\"validateLayout\",\"contextName\",\"subProps\",\"isArray\",\"Error\",\"j\",\"_console\",\"DEBUG\",\"console\",\"cloneLayout\",\"withLayoutItem\",\"itemKey\",\"cb\",\"childrenEqual\",\"_lodash\",\"_react\",\"Children\",\"c\",\"fastPositionEqual\",\"left\",\"top\",\"width\",\"height\",\"perc\",\"num\",\"setTransform\",\"_ref\",\"translate\",\"transform\",\"WebkitTransform\",\"MozTransform\",\"msTransform\",\"OTransform\",\"position\",\"setTopLeft\",\"_ref2\",\"synchronizeLayoutWithChildren\",\"initialLayout\",\"children\",\"child\",\"exists\",\"isProduction\",\"props\",\"_grid\",\"warn\",\"g\",\"correctedLayout\",\"_ref3\",\"verticalCompact\",\"autoBindHandlers\",\"el\",\"fns\",\"bind\",\"noop\",\"fastRGLPropsEqual\"]\n}\n"]