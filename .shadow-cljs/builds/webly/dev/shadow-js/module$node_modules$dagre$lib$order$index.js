["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/dagre/lib/order/index.js"],"~:js","shadow$provide.module$node_modules$dagre$lib$order$index=function(global,require,module,exports){function buildLayerGraphs(g,ranks,relationship){return _.map(ranks,function(rank){return buildLayerGraph(g,rank,relationship)})}function sweepLayerGraphs(layerGraphs,biasRight){var cg=new Graph;_.forEach(layerGraphs,function(lg){var root=lg.graph().root;root=sortSubgraph(lg,root,cg,biasRight);_.forEach(root.vs,function(v,i){lg.node(v).order=i});addSubgraphConstraints(lg,cg,root.vs)})}function assignOrder(g,\nlayering){_.forEach(layering,function(layer){_.forEach(layer,function(v,i){g.node(v).order=i})})}var _=require(\"module$node_modules$dagre$lib$lodash\"),initOrder=require(\"module$node_modules$dagre$lib$order$init_order\"),crossCount=require(\"module$node_modules$dagre$lib$order$cross_count\"),sortSubgraph=require(\"module$node_modules$dagre$lib$order$sort_subgraph\"),buildLayerGraph=require(\"module$node_modules$dagre$lib$order$build_layer_graph\"),addSubgraphConstraints=require(\"module$node_modules$dagre$lib$order$add_subgraph_constraints\"),\nGraph=require(\"module$node_modules$dagre$lib$graphlib\").Graph,util=require(\"module$node_modules$dagre$lib$util\");module.exports=function(g){var maxRank=util.maxRank(g),downLayerGraphs=buildLayerGraphs(g,_.range(1,maxRank+1),\"inEdges\");maxRank=buildLayerGraphs(g,_.range(maxRank-1,-1,-1),\"outEdges\");var layering=initOrder(g);assignOrder(g,layering);for(var bestCC=Number.POSITIVE_INFINITY,best,i=0,lastBest=0;4>lastBest;++i,++lastBest){sweepLayerGraphs(i%2?downLayerGraphs:maxRank,2<=i%4);layering=util.buildLayerMatrix(g);\nvar cc=crossCount(g,layering);cc<bestCC&&(lastBest=0,best=_.cloneDeep(layering),bestCC=cc)}assignOrder(g,best)}}","~:source","shadow$provide[\"module$node_modules$dagre$lib$order$index\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar initOrder = require(\"./init-order\");\nvar crossCount = require(\"./cross-count\");\nvar sortSubgraph = require(\"./sort-subgraph\");\nvar buildLayerGraph = require(\"./build-layer-graph\");\nvar addSubgraphConstraints = require(\"./add-subgraph-constraints\");\nvar Graph = require(\"../graphlib\").Graph;\nvar util = require(\"../util\");\n\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function(rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function(lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function(v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$dagre$lib$order$sort_subgraph","~$module$node_modules$dagre$lib$util","~$module$node_modules$dagre$lib$order$add_subgraph_constraints","~$shadow.js","~$module$node_modules$dagre$lib$order$build_layer_graph","~$module$node_modules$dagre$lib$order$cross_count","~$module$node_modules$dagre$lib$order$init_order","~$module$node_modules$dagre$lib$graphlib","~$module$node_modules$dagre$lib$lodash"]],"~:properties",["^5",["order"]],"~:compiled-at",1621210442128,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$dagre$lib$order$index.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/dagre/lib/order/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$dagre$lib$order$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _ = require(\\\"../lodash\\\");\\nvar initOrder = require(\\\"./init-order\\\");\\nvar crossCount = require(\\\"./cross-count\\\");\\nvar sortSubgraph = require(\\\"./sort-subgraph\\\");\\nvar buildLayerGraph = require(\\\"./build-layer-graph\\\");\\nvar addSubgraphConstraints = require(\\\"./add-subgraph-constraints\\\");\\nvar Graph = require(\\\"../graphlib\\\").Graph;\\nvar util = require(\\\"../util\\\");\\n\\nmodule.exports = order;\\n\\n/*\\n * Applies heuristics to minimize edge crossings in the graph and sets the best\\n * order solution as an order attribute on each node.\\n *\\n * Pre-conditions:\\n *\\n *    1. Graph must be DAG\\n *    2. Graph nodes must be objects with a \\\"rank\\\" attribute\\n *    3. Graph edges must have the \\\"weight\\\" attribute\\n *\\n * Post-conditions:\\n *\\n *    1. Graph nodes will have an \\\"order\\\" attribute based on the results of the\\n *       algorithm.\\n */\\nfunction order(g) {\\n  var maxRank = util.maxRank(g),\\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \\\"inEdges\\\"),\\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \\\"outEdges\\\");\\n\\n  var layering = initOrder(g);\\n  assignOrder(g, layering);\\n\\n  var bestCC = Number.POSITIVE_INFINITY,\\n    best;\\n\\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\\n\\n    layering = util.buildLayerMatrix(g);\\n    var cc = crossCount(g, layering);\\n    if (cc < bestCC) {\\n      lastBest = 0;\\n      best = _.cloneDeep(layering);\\n      bestCC = cc;\\n    }\\n  }\\n\\n  assignOrder(g, best);\\n}\\n\\nfunction buildLayerGraphs(g, ranks, relationship) {\\n  return _.map(ranks, function(rank) {\\n    return buildLayerGraph(g, rank, relationship);\\n  });\\n}\\n\\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\\n  var cg = new Graph();\\n  _.forEach(layerGraphs, function(lg) {\\n    var root = lg.graph().root;\\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\\n    _.forEach(sorted.vs, function(v, i) {\\n      lg.node(v).order = i;\\n    });\\n    addSubgraphConstraints(lg, cg, sorted.vs);\\n  });\\n}\\n\\nfunction assignOrder(g, layering) {\\n  _.forEach(layering, function(layer) {\\n    _.forEach(layer, function(v, i) {\\n      g.node(v).order = i;\\n    });\\n  });\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"buildLayerGraphs\",\"g\",\"ranks\",\"relationship\",\"_\",\"map\",\"rank\",\"buildLayerGraph\",\"sweepLayerGraphs\",\"layerGraphs\",\"biasRight\",\"cg\",\"Graph\",\"forEach\",\"lg\",\"root\",\"graph\",\"sorted\",\"sortSubgraph\",\"vs\",\"v\",\"i\",\"node\",\"order\",\"addSubgraphConstraints\",\"assignOrder\",\"layering\",\"layer\",\"initOrder\",\"crossCount\",\"util\",\"maxRank\",\"downLayerGraphs\",\"range\",\"upLayerGraphs\",\"bestCC\",\"Number\",\"POSITIVE_INFINITY\",\"best\",\"lastBest\",\"buildLayerMatrix\",\"cc\",\"cloneDeep\"]\n}\n"]