["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-grid-layout/build/responsiveUtils.js"],"~:js","shadow$provide.module$node_modules$react_grid_layout$build$responsiveUtils=function(global,require,module,exports){function sortBreakpoints(breakpoints){return Object.keys(breakpoints).sort(function(a,b){return breakpoints[a]-breakpoints[b]})}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.getBreakpointFromWidth=function(breakpoints,width){for(var sorted=sortBreakpoints(breakpoints),matching=sorted[0],i=1,len=sorted.length;i<len;i++){var breakpointName=sorted[i];width>breakpoints[breakpointName]&&\n(matching=breakpointName)}return matching};exports.getColsFromBreakpoint=function(breakpoint,cols){if(!cols[breakpoint])throw Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \"+breakpoint+\" is missing!\");return cols[breakpoint]};exports.findOrGenerateResponsiveLayout=function(layouts,breakpoints,breakpoint,lastBreakpoint,cols,compactType){if(layouts[breakpoint])return(0,_utils.cloneLayout)(layouts[breakpoint]);lastBreakpoint=layouts[lastBreakpoint];breakpoints=sortBreakpoints(breakpoints);\nbreakpoint=breakpoints.slice(breakpoints.indexOf(breakpoint));breakpoints=0;for(var len=breakpoint.length;breakpoints<len;breakpoints++){var b=breakpoint[breakpoints];if(layouts[b]){lastBreakpoint=layouts[b];break}}lastBreakpoint=(0,_utils.cloneLayout)(lastBreakpoint||[]);return(0,_utils.compact)((0,_utils.correctBounds)(lastBreakpoint,{cols}),compactType,cols)};exports.sortBreakpoints=sortBreakpoints;var _utils=require(\"module$node_modules$react_grid_layout$build$utils\")}","~:source","shadow$provide[\"module$node_modules$react_grid_layout$build$responsiveUtils\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.sortBreakpoints = sortBreakpoints;\n\nvar _utils = require(\"./utils\");\n\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nfunction getBreakpointFromWidth(breakpoints\n/*: Breakpoints<Breakpoint>*/\n, width\n/*: number*/\n)\n/*: Breakpoint*/\n{\n  var sorted = sortBreakpoints(breakpoints);\n  var matching = sorted[0];\n\n  for (var i = 1, len = sorted.length; i < len; i++) {\n    var breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n\n  return matching;\n}\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\n\n\nfunction getColsFromBreakpoint(breakpoint\n/*: Breakpoint*/\n, cols\n/*: Breakpoints<Breakpoint>*/\n)\n/*: number*/\n{\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n\n  return cols[breakpoint];\n}\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\n\n\nfunction findOrGenerateResponsiveLayout(layouts\n/*: ResponsiveLayout<Breakpoint>*/\n, breakpoints\n/*: Breakpoints<Breakpoint>*/\n, breakpoint\n/*: Breakpoint*/\n, lastBreakpoint\n/*: Breakpoint*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]); // Find or generate the next layout\n\n  var layout = layouts[lastBreakpoint];\n  var breakpointsSorted = sortBreakpoints(breakpoints);\n  var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n\n  for (var i = 0, len = breakpointsAbove.length; i < len; i++) {\n    var b = breakpointsAbove[i];\n\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n    cols: cols\n  }), compactType, cols);\n}\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\n\n\nfunction sortBreakpoints(breakpoints\n/*: Breakpoints<Breakpoint>*/\n)\n/*: Array<Breakpoint>*/\n{\n  var keys\n  /*: Array<string>*/\n  = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_grid_layout$build$utils","~$shadow.js"]],"~:properties",["^5",["__esModule","getBreakpointFromWidth","value","sortBreakpoints","cols","findOrGenerateResponsiveLayout","getColsFromBreakpoint"]],"~:compiled-at",1621210442675,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_grid_layout$build$responsiveUtils.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAA,2DAAA,CAAgF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAwHxHC,QAASA,gBAAe,CAACC,WAAD,CAIxB,CAIE,MADEC,OAAOC,CAAAA,IAAPA,CAAYF,WAAZE,CACUC,CAAAA,IAAL,CAAU,QAAS,CAACC,CAAD,CAAIC,CAAJ,CAAO,CAC/B,MAAOL,YAAA,CAAYI,CAAZ,CAAP,CAAwBJ,WAAA,CAAYK,CAAZ,CADO,CAA1B,CAJT,CAzHAJ,MAAOK,CAAAA,cAAP,CAAsBR,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CS,MAAO,CAAA,CADoC,CAA7C,CAGAT,QAAQU,CAAAA,sBAAR,CAcAA,QAA+B,CAACR,WAAD,CAE7BS,KAF6B,CAM/B,CAIE,IAHA,IAAIC,OAASX,eAAA,CAAgBC,WAAhB,CAAb,CACIW,SAAWD,MAAA,CAAO,CAAP,CADf,CAGSE,EAAI,CAHb,CAGgBC,IAAMH,MAAOI,CAAAA,MAA7B,CAAqCF,CAArC,CAAyCC,GAAzC,CAA8CD,CAAA,EAA9C,CAAmD,CACjD,IAAIG,eAAiBL,MAAA,CAAOE,CAAP,CACjBH,MAAJ,CAAYT,WAAA,CAAYe,cAAZ,CAAZ;CAAyCJ,QAAzC,CAAoDI,cAApD,CAFiD,CAKnD,MAAOJ,SATT,CAnBAb,QAAQkB,CAAAA,qBAAR,CAsCAA,QAA8B,CAACC,UAAD,CAE5BC,IAF4B,CAM9B,CACE,GAAI,CAACA,IAAA,CAAKD,UAAL,CAAL,CACE,KAAUE,MAAJ,CAAU,yDAAV,CAAsEF,UAAtE,CAAmF,cAAnF,CAAN,CAGF,MAAOC,KAAA,CAAKD,UAAL,CALT,CA3CAnB,QAAQsB,CAAAA,8BAAR,CAkEAA,QAAuC,CAACC,OAAD,CAErCrB,WAFqC,CAIrCiB,UAJqC,CAMrCK,cANqC,CAQrCJ,IARqC,CAUrCK,WAVqC,CAcvC,CAEE,GAAIF,OAAA,CAAQJ,UAAR,CAAJ,CAAyB,MAAO,CAAC,CAAA,CAAGO,MAAOC,CAAAA,WAAX,EAAwBJ,OAAA,CAAQJ,UAAR,CAAxB,CAE5BS,eAAAA,CAASL,OAAA,CAAQC,cAAR,CACTK,YAAAA,CAAoB5B,eAAA,CAAgBC,WAAhB,CACpB4B;UAAAA,CAAmBD,WAAkBE,CAAAA,KAAlB,CAAwBF,WAAkBG,CAAAA,OAAlB,CAA0Bb,UAA1B,CAAxB,CAEdL,YAAAA,CAAI,CAAb,KAAK,IAAWC,IAAMe,UAAiBd,CAAAA,MAAvC,CAA+CF,WAA/C,CAAmDC,GAAnD,CAAwDD,WAAA,EAAxD,CAA6D,CAC3D,IAAIP,EAAIuB,UAAA,CAAiBhB,WAAjB,CAER,IAAIS,OAAA,CAAQhB,CAAR,CAAJ,CAAgB,CACdqB,cAAA,CAASL,OAAA,CAAQhB,CAAR,CACT,MAFc,CAH2C,CAS7DqB,cAAA,CAAS,CAAC,CAAA,CAAGF,MAAOC,CAAAA,WAAX,EAAwBC,cAAxB,EAAkC,EAAlC,CAET,OAAO,CAAC,CAAA,CAAGF,MAAOO,CAAAA,OAAX,EAAoB,CAAC,CAAA,CAAGP,MAAOQ,CAAAA,aAAX,EAA0BN,cAA1B,CAAkC,CACrDR,IADqD,CAAlC,CAApB,CAEHK,WAFG,CAEUL,IAFV,CAnBT,CA/EApB,QAAQC,CAAAA,eAAR,CAA0BA,eAE1B,KAAIyB,OAAS5B,OAAA,CAAQ,mDAAR,CAX2G;\",\n\"sources\":[\"node_modules/react-grid-layout/build/responsiveUtils.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_grid_layout$build$responsiveUtils\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\\nexports.sortBreakpoints = sortBreakpoints;\\n\\nvar _utils = require(\\\"./utils\\\");\\n\\n/**\\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\\n *\\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\\n * @param  {Number} width Screen width.\\n * @return {String}       Highest breakpoint that is less than width.\\n */\\nfunction getBreakpointFromWidth(breakpoints\\n/*: Breakpoints<Breakpoint>*/\\n, width\\n/*: number*/\\n)\\n/*: Breakpoint*/\\n{\\n  var sorted = sortBreakpoints(breakpoints);\\n  var matching = sorted[0];\\n\\n  for (var i = 1, len = sorted.length; i < len; i++) {\\n    var breakpointName = sorted[i];\\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\\n  }\\n\\n  return matching;\\n}\\n/**\\n * Given a breakpoint, get the # of cols set for it.\\n * @param  {String} breakpoint Breakpoint name.\\n * @param  {Object} cols       Map of breakpoints to cols.\\n * @return {Number}            Number of cols.\\n */\\n\\n\\nfunction getColsFromBreakpoint(breakpoint\\n/*: Breakpoint*/\\n, cols\\n/*: Breakpoints<Breakpoint>*/\\n)\\n/*: number*/\\n{\\n  if (!cols[breakpoint]) {\\n    throw new Error(\\\"ResponsiveReactGridLayout: `cols` entry for breakpoint \\\" + breakpoint + \\\" is missing!\\\");\\n  }\\n\\n  return cols[breakpoint];\\n}\\n/**\\n * Given existing layouts and a new breakpoint, find or generate a new layout.\\n *\\n * This finds the layout above the new one and generates from it, if it exists.\\n *\\n * @param  {Object} layouts     Existing layouts.\\n * @param  {Array} breakpoints All breakpoints.\\n * @param  {String} breakpoint New breakpoint.\\n * @param  {String} breakpoint Last breakpoint (for fallback).\\n * @param  {Number} cols       Column count at new breakpoint.\\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\\n *   vertically.\\n * @return {Array}             New layout.\\n */\\n\\n\\nfunction findOrGenerateResponsiveLayout(layouts\\n/*: ResponsiveLayout<Breakpoint>*/\\n, breakpoints\\n/*: Breakpoints<Breakpoint>*/\\n, breakpoint\\n/*: Breakpoint*/\\n, lastBreakpoint\\n/*: Breakpoint*/\\n, cols\\n/*: number*/\\n, compactType\\n/*: CompactType*/\\n)\\n/*: Layout*/\\n{\\n  // If it already exists, just return it.\\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]); // Find or generate the next layout\\n\\n  var layout = layouts[lastBreakpoint];\\n  var breakpointsSorted = sortBreakpoints(breakpoints);\\n  var breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\\n\\n  for (var i = 0, len = breakpointsAbove.length; i < len; i++) {\\n    var b = breakpointsAbove[i];\\n\\n    if (layouts[b]) {\\n      layout = layouts[b];\\n      break;\\n    }\\n  }\\n\\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\\n\\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\\n    cols: cols\\n  }), compactType, cols);\\n}\\n/**\\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\\n * e.g. ['xxs', 'xs', 'sm', ...]\\n *\\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\\n * @return {Array}              Sorted breakpoints.\\n */\\n\\n\\nfunction sortBreakpoints(breakpoints\\n/*: Breakpoints<Breakpoint>*/\\n)\\n/*: Array<Breakpoint>*/\\n{\\n  var keys\\n  /*: Array<string>*/\\n  = Object.keys(breakpoints);\\n  return keys.sort(function (a, b) {\\n    return breakpoints[a] - breakpoints[b];\\n  });\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"sortBreakpoints\",\"breakpoints\",\"Object\",\"keys\",\"sort\",\"a\",\"b\",\"defineProperty\",\"value\",\"getBreakpointFromWidth\",\"width\",\"sorted\",\"matching\",\"i\",\"len\",\"length\",\"breakpointName\",\"getColsFromBreakpoint\",\"breakpoint\",\"cols\",\"Error\",\"findOrGenerateResponsiveLayout\",\"layouts\",\"lastBreakpoint\",\"compactType\",\"_utils\",\"cloneLayout\",\"layout\",\"breakpointsSorted\",\"breakpointsAbove\",\"slice\",\"indexOf\",\"compact\",\"correctBounds\"]\n}\n"]